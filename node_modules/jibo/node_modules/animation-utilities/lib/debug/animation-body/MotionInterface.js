/**
 * @author mattb
 */

"use strict";

var BodyData = require("./BodyData");
var Clock = require("../ifr-core/Clock");

/**
 * @param {string} bodyServiceURL - base URL for the body service
 * @param {string} [sessionToken] - optional session security token
 * @param {string} [baseDOFName] - base DOF name (optional)
 * @param {string} [middleDOFName] - middle DOF name (optional)
 * @param {string} [neckDOFName] - neck DOF name (optional)
 * @constructor
 */
var MotionInterface = function MotionInterface(bodyServiceURL, sessionToken, baseDOFName, middleDOFName, neckDOFName) {
	var baseDOF = baseDOFName || "bottomSection_r";
	var middleDOF = middleDOFName || "middleSection_r";
	var neckDOF = neckDOFName || "topSection_r";

	/** @type {Object.<string, string>} */
	this.dofToAxis = {};
	this.dofToAxis[baseDOF] = "pelvis";
	this.dofToAxis[middleDOF] = "torso";
	this.dofToAxis[neckDOF] = "neck";

	/** @type string[] */
	this.dofNames = [baseDOF, middleDOF, neckDOF];

	/** @type {number} */
	this.stateMessageCount = 0;
	/** @type {AxisState} */
	this.latestAxisState = null;

	/** @type {AxisCommand} */
	this.command = new BodyData.AxisCommand();
	this.command.pelvis = new BodyData.SingleAxisCommand();
	this.command.torso = new BodyData.SingleAxisCommand();
	this.command.neck = new BodyData.SingleAxisCommand();

	var self = this;

	if (sessionToken) {
		this.stateSocket = new WebSocket(bodyServiceURL + "/axis_state", sessionToken);
	} else {
		this.stateSocket = new WebSocket(bodyServiceURL + "/axis_state");
	}
	this.stateSocket.onmessage = function (event) {
		var data = JSON.parse(event.data);
		self.latestAxisState = new BodyData.AxisState().setFromJson(data);
		self.stateMessageCount++;
	};

	if (sessionToken) {
		this.commandSocket = new WebSocket(bodyServiceURL + "/axis_command", sessionToken);
	} else {
		this.commandSocket = new WebSocket(bodyServiceURL + "/axis_command");
	}
};

/**
 * @return {string[]}
 */
MotionInterface.prototype.getMotionDOFNames = function () {
	return this.dofNames;
};

/**
 * @param {string} dofName
 * @return {SingleAxisState}
 */
MotionInterface.prototype.getState = function (dofName) {
	if (!this.dofToAxis.hasOwnProperty(dofName)) {
		throw new Error("unknown motion DOF name: " + dofName);
	}

	if (this.latestAxisState !== null) {
		return this.latestAxisState[this.dofToAxis[dofName]];
	} else {
		return null;
	}
};

/**
 * @return {number}
 */
MotionInterface.prototype.getStateMessageCount = function () {
	return this.stateMessageCount;
};

/**
 * @param {string} dofName - DOF name
 * @param {AxisCommandMode} commandMode - command mode for the axis
 * @param {number|number[]} commandValue - command data (as defined by the given mode)
 * @param {number} [velocityLimit] - optional velocity limit in radians/second
 * @param {number} [accelerationLimit] - optional acceleration limit in radians/second^2
 * @param {number} [currentLimit] - optional current limit in amperes
 * @return {boolean} true if the command was set successfully
 */
MotionInterface.prototype.setCommand = function (dofName, commandMode, commandValue, velocityLimit, accelerationLimit, currentLimit) {
	if (!this.dofToAxis.hasOwnProperty(dofName)) {
		throw new Error("unknown motion DOF name: " + dofName);
	}

	var state = this.getState(dofName);
	if (state !== null) {
		/** @type {SingleAxisCommand} */
		var command = this.command[this.dofToAxis[dofName]];

		command.mode = commandMode;
		command.value = commandValue instanceof Array ? commandValue : [commandValue];
		command.vel_limit = velocityLimit !== undefined && velocityLimit !== null ? velocityLimit : state.vel_limit;
		command.acc_limit = accelerationLimit !== undefined && accelerationLimit !== null ? accelerationLimit : state.acc_limit;
		command.cur_limit = currentLimit !== undefined && currentLimit !== null ? currentLimit : state.cur_limit;

		return true;
	} else {
		return false;
	}
};

/**
 * @return {boolean} true if the command was sent successfully
 */
MotionInterface.prototype.sendCommand = function () {
	if (this.commandSocket.readyState === WebSocket.OPEN) {
		this.command.setTimestamp(Clock.currentTime());
		var cmd = JSON.stringify(this.command);
		this.commandSocket.send(cmd);
		return true;
	} else {
		return false;
	}
};

/**
 * @return {boolean} true if the motion interface is connected
 */
MotionInterface.prototype.isConnected = function () {
	return this.latestAxisState !== null && this.commandSocket.readyState === WebSocket.OPEN;
};

MotionInterface.prototype.close = function () {
	this.stateSocket.close();
	this.commandSocket.close();
};

module.exports = MotionInterface;
//# sourceMappingURL=../map/animation-body/MotionInterface.js.map
