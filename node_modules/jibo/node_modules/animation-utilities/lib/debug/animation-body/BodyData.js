/**
 * @author mattb
 */

"use strict";

var Time = require("../ifr-core/Time");
var slog = require("../ifr-core/SLog");

var AxisCommandMode = {
	NONE: 0,
	LIMP: 1,
	BRAKE: 2,
	PWM: 3,
	VELOCITY: 4,
	TRAJECTORY: 5,
	TORQUE: 6,
	POS_VEL: 7
};

/**
 * @constructor
 */
var SingleAxisState = function SingleAxisState() {
	/**
  * chronometer timestamp
  * @type {number[]} */
	this.ts = null;
	/**
  * absolute (indexed) position in radians, undefined until indexed
  * @type {number} */
	this.pos = null;
	/**
  * encoder position in radians, arbitrary zero based on power-up position
  * @type {number} */
	this.inc_pos = null;
	/**
  * velocity in radians/second
  * @type {number} */
	this.vel = null;
	/**
  * current in amperes
  * @type {number} */
	this.cur = null;
	/**
  * PWM value in % max PWM
  * @type {number} */
	this.pwm = null;
	/**
  * low-level flags for motor and driver status (integer)
  * @type {number} */
	this.status = null;
	/**
  * velocity limit in radians/second
  * @type {number} */
	this.vel_limit = null;
	/**
  * acceleration limit in radians/second^2
  * @type {number} */
	this.acc_limit = null;
	/**
  * current limit in amperes
  * @type {number} */
	this.cur_limit = null;
	/**
  * command mode of the axis {none=0, limp=1, brake=2, pwm=3, vel=4, traj=5, trq=6}
  * @type {number} */
	this.mode = null;
	/**
  * reference value of trajectory generator (depends on command)
  * @type {number} */
	this.ref = null;
	/**
  * reference position (may not be reported for all modes)
  * @type {number} */
	this.ref_pos = null;
	/**
  * reference acc (may not be reported for all modes)
  * @type {number} */
	this.ref_acc = null;
	/**
  * hardware-level tick counter (milliseconds)
  * @type {number} */
	this.ticks = null;
	/**
  * value of the integral term of the PID loop
  * @type {number} */
	this.integrator = null;
	/**
  * Low level motor fault flags (int)
  * @type {number} */
	this.fault_status = null;
};

/**
 * @return {Time} - chronometer timestamp as a Time instance
 */
SingleAxisState.prototype.getTimestamp = function () {
	if (this.ts === null) {
		return null;
	} else {
		return Time.createFromTimestamp(this.ts);
	}
};

/**
 * @return {boolean} - true if axis is indexed (0th bit of status)
 */
SingleAxisState.prototype.isIndexed = function () {
	if (this.status === null) {
		return false;
	} else {
		/*jshint bitwise:false*/
		return (this.status & 0x01) > 0;
		/*jshint bitwise:true*/
	}
};

/**
 * @param {Object} jsonData
 * @return {SingleAxisState}
 */
SingleAxisState.prototype.setFromJson = function (jsonData) {
	var keys = Object.keys(jsonData);
	for (var i = 0; i < keys.length; i++) {
		if (this.hasOwnProperty(keys[i])) {
			this[keys[i]] = jsonData[keys[i]];
		} else {
			slog.info("SingleAxisState: unknown JSON property name: " + keys[i]);
		}
	}
	return this;
};

/**
 * @constructor
 */
var AxisState = function AxisState() {
	/**
  * overall update chronometer timestamp
  * @type {number[]} */
	this.ts = null;
	/** @type {SingleAxisState} */
	this.pelvis = null;
	/** @type {SingleAxisState} */
	this.torso = null;
	/** @type {SingleAxisState} */
	this.neck = null;
};

/**
 * @return {Time} - overall update chronometer timestamp as a Time instance
 */
AxisState.prototype.getTimestamp = function () {
	if (this.ts === null) {
		return null;
	} else {
		return Time.createFromTimestamp(this.ts);
	}
};

/**
 * @param {Object} jsonData
 * @return {AxisState}
 */
AxisState.prototype.setFromJson = function (jsonData) {
	this.ts = jsonData.ts;
	this.pelvis = new SingleAxisState().setFromJson(jsonData.pelvis);
	this.torso = new SingleAxisState().setFromJson(jsonData.torso);
	this.neck = new SingleAxisState().setFromJson(jsonData.neck);
	return this;
};

/**
 * @constructor
 */
var SingleAxisCommand = function SingleAxisCommand() {
	/**
  * command mode {none=0, limp=1, brake=2, pwm=3, vel=4, traj=5, trq=6}
  * @type {number} */
	this.mode = null;
	/**
  * command target, as defined by the mode
  * @type {number[]} */
	this.value = null;
	/**
  * velocity limit in radians/second
  * @type {number} */
	this.vel_limit = null;
	/**
  * acceleration limit in radians/second^2
  * @type {number} */
	this.acc_limit = null;
	/**
  * current limit in amperes
  * @type {number} */
	this.cur_limit = null;
};

/**
 * @constructor
 */
var AxisCommand = function AxisCommand() {
	/**
  * chronometer timestamp
  * @type {number[]} */
	this.ts = null;
	/** @type {SingleAxisCommand} */
	this.pelvis = null;
	/** @type {SingleAxisCommand} */
	this.torso = null;
	/** @type {SingleAxisCommand} */
	this.neck = null;
};

/**
 * @param {Time} timestamp
 */
AxisCommand.prototype.setTimestamp = function (timestamp) {
	this.ts = timestamp._timestamp;
};

/**
 * @constructor
 */
var LEDCommand = function LEDCommand() {
	/**
  * chronometer timestamp
  * @type {number[]} */
	this.ts = null;
	/**
  * RGB color value, percentage of maximum [0.0, 1.0]
  * @type {number[]} */
	this.color = null;
	/**
  * desired rate of change of each color value, in percent/second
  * @type {number[]} */
	this.rate_limit = null;
};

/**
 * @param {Time} timestamp
 */
LEDCommand.prototype.setTimestamp = function (timestamp) {
	this.ts = timestamp._timestamp;
};

/**
 * @param {number} rateLimit - desired rate of change, in percent/second
 */
LEDCommand.prototype.setRateLimit = function (rateLimit) {
	this.rate_limit = [rateLimit, rateLimit, rateLimit];
};

module.exports.AxisCommandMode = AxisCommandMode;
module.exports.SingleAxisState = SingleAxisState;
module.exports.AxisState = AxisState;
module.exports.SingleAxisCommand = SingleAxisCommand;
module.exports.AxisCommand = AxisCommand;
module.exports.LEDCommand = LEDCommand;
//# sourceMappingURL=../map/animation-body/BodyData.js.map
