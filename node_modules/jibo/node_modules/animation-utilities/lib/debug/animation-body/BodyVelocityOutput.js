/**
 * @author mattb
 */

"use strict";

var BodyData = require("./BodyData");
var BodyOutput = require("./BodyOutput");

var PVController = require("../ifr-motion/feedback/PVController");

/**
 * Timeline output connecting to the body service.
 * Creates a local set of position-velocity feedback controllers wrapping
 * the (remote) velocity control mode on the body boards.
 * @param {Clock} clock - the timeline clock
 * @param {RobotInfo} robotInfo - robot info object
 * @param {string} bodyServiceURL - base URL for the body service
 * @param {boolean} [startEnabled] - optional, if true, start up with motors enabled (defaults to false)
 * @param {number} [updateIntervalMillis] - if specified and non-zero, auto-update at the given interval
 * @param {string} [sessionToken] - optional session security token
 * @constructor
 */
var BodyVelocityOutput = function BodyVelocityOutput(clock, robotInfo, bodyServiceURL, startEnabled, updateIntervalMillis, sessionToken) {
	BodyOutput.call(this, clock, robotInfo, bodyServiceURL, startEnabled, updateIntervalMillis, sessionToken);

	/** @type {PVController[]} */
	this.feedbackControllers = [];
	for (var i = 0; i < this.dofNames.length; i++) {
		this.feedbackControllers.push(new PVController());
	}
};

BodyVelocityOutput.prototype = Object.create(BodyOutput.prototype);
BodyVelocityOutput.prototype.constructor = BodyOutput;

BodyVelocityOutput.prototype.update = function () {
	var currentTime = this.clock.currentTime();

	var targets = this.computeTargetsForTime(currentTime.add(this.reactionTime));

	if (targets !== null && this.motionInterface.isConnected()) {
		for (var i = 0; i < this.dofNames.length; i++) {
			this.feedbackControllers[i].setTarget(currentTime, targets[i].position, targets[i].velocity);
			this.feedbackControllers[i].calculateForTime(currentTime);

			var commandVelocity = this.feedbackControllers[i].getCommandVelocity();
			var commandAcceleration = this.feedbackControllers[i].getCommandAcceleration();
			var commandMode = this.enabledArray[i] ? BodyData.AxisCommandMode.VELOCITY : BodyData.AxisCommandMode.LIMP;

			this.motionInterface.setCommand(this.dofNames[i], commandMode, commandVelocity, null, commandAcceleration, null);

			var state = this.motionInterface.getState(this.dofNames[i]);
			this.feedbackControllers[i].acceptFeedback(currentTime, state.pos, state.vel, state.ref);

			if (this.infoListeners.length > 0) {
				var info = {
					dofName: this.dofNames[i],
					timestamp: currentTime,
					observedPosition: state.pos,
					targetPosition: targets[i].position,
					observedVelocity: state.vel,
					commandVelocity: commandVelocity
				};
				for (var c = 0; c < this.infoListeners.length; c++) {
					this.infoListeners[c](info);
				}
			}
		}

		this.motionInterface.sendCommand();
	}
};

module.exports = BodyVelocityOutput;
//# sourceMappingURL=../map/animation-body/BodyVelocityOutput.js.map
