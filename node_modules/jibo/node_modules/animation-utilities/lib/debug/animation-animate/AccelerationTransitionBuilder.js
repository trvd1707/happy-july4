/**
 * @author jg, mattb
 */

"use strict";

var Motion = require("../ifr-motion/base/Motion");
var MotionValidator = require("../ifr-motion/base/MotionValidator");
var MotionTrack = require("../ifr-motion/base/MotionTrack");
var TimestampedBuffer = require("../ifr-motion/base/TimestampedBuffer");
var AccelPlanner = require("../ifr-motion/base/AccelPlanner");
var TransitionBuilder = require("./TransitionBuilder");

/**
 * Protected constructor for internal use only.
 *
 * AccelerationTransitionBuilders generate transition motions using configurable
 * acceleration and velocity limits.
 *
 * AccelerationTransitionBuilders can be created via the animation module's
 * [createAccelerationTransitionBuilder]{@link module:jibo/animate#createAccelerationTransitionBuilder} method.
 *
 * @param {RobotInfo} robotInfo - Protected constructor parameter.
 * @param {number} defaultMaxVelocity - Protected constructor parameter.
 * @param {number} defaultMaxAcceleration - Protected constructor parameter.
 * @constructor
 * @protected
 * @extends TransitionBuilder
 */
var AccelerationTransitionBuilder = function AccelerationTransitionBuilder(robotInfo, defaultMaxVelocity, defaultMaxAcceleration) {
	TransitionBuilder.call(this);

	/** @type {number} */
	/** @private */
	this.minTransitionTime = null;

	/** @type {number} */
	/** @private */
	this.defaultMaxVelocity = defaultMaxVelocity;
	/** @type {number} */
	/** @private */
	this.defaultMaxAccel = defaultMaxAcceleration;

	/** @type {Object<string,number>} */
	/** @private */
	this.maxVelocityByDOF = {};
	/** @type {Object<string,number>} */
	/** @private */
	this.maxAccelByDOF = {};

	/** @type {RobotInfo} */
	/** @private */
	this.robotInfo = robotInfo;
	/** @type {AccelPlanner} */
	/** @private */
	this.planner = new AccelPlanner();
};

AccelerationTransitionBuilder.prototype = Object.create(TransitionBuilder.prototype);
AccelerationTransitionBuilder.prototype.constructor = AccelerationTransitionBuilder;

/**
 * Sets this transition to use the specified max velocity and acceleration by default; i.e. for
 * all joints that do not have their own custom settings.
 *
 * @param {number} defaultMaxVelocity - Max velocity to use by default.
 * @param {number} defaultMaxAcceleration - Max acceleration to use by default.
 */
AccelerationTransitionBuilder.prototype.setDefaultLimits = function (defaultMaxVelocity, defaultMaxAcceleration) {
	this.defaultMaxVelocity = defaultMaxVelocity;
	this.defaultMaxAccel = defaultMaxAcceleration;
};

/**
 * Sets this transition to use the specified minimum duration regardless of joint positions.
 *
 * @param {number} time - Minimum transition time.
 */
AccelerationTransitionBuilder.prototype.setMinTransitionTime = function (time) {
	this.minTransitionTime = time;
};

/**
 * Sets this transition to use the specified max velocity and acceleration for the specified joints/DOFs.
 *
 * @param {string[]} dofNames - DOF names for which the specified limits should apply.
 * @param {number} maxVelocity - Max velocity to use for the specified DOFs.
 * @param {number} maxAcceleration - Max acceleration to use for the specified DOFs.
 */
AccelerationTransitionBuilder.prototype.setLimits = function (dofNames, maxVelocity, maxAcceleration) {
	for (var i = 0; i < dofNames.length; i++) {
		this.maxVelocityByDOF[dofNames[i]] = maxVelocity;
		this.maxAccelByDOF[dofNames[i]] = maxAcceleration;
	}
};

/**
 *
 * @param {Pose} fromPose
 * @param {Motion} toMotion
 * @param {number} timeOffsetInTo
 * @param {string[]} onDOFs
 *
 * @return {Motion}
 * @override
 */
AccelerationTransitionBuilder.prototype.generateTransition = function (fromPose, toMotion, timeOffsetInTo, onDOFs) {
	var dofName, valueFrom, velocityFrom, valueTo, di;
	var tickInterval = 1 / 30;

	//check validity
	for (di = 0; di < onDOFs.length; di++) {
		dofName = onDOFs[di];
		if (!this.robotInfo.getDOFInfo(dofName)) {
			throw new Error("Error transitioning, no dofInfo found for " + dofName);
		}
		var fromVar = fromPose.get(dofName, 0);
		if (fromVar == null || Array.isArray(fromVar) && fromVar.length < 1) {
			throw new Error("Error transitioning, no FROM value for " + dofName);
		}
	}
	MotionValidator.valuesExist(toMotion, onDOFs);

	var interpolatorSet = this.robotInfo.getKinematicInfo().getInterpolatorSet();

	var transition = new Motion("Transition:" + toMotion.getName());
	var duration = 0;

	var toPose = toMotion.getPoseAtTime(timeOffsetInTo, interpolatorSet);

	var dga = this.robotInfo.getKinematicInfo().getDOFGlobalAlignment();
	dga.refineToGloballyClosestTargetPose(fromPose, toPose, onDOFs);

	//var slowestJoint;
	//var slowestJointDistance;
	for (di = 0; di < onDOFs.length; di++) {
		dofName = onDOFs[di];
		if (this.robotInfo.getDOFInfo(dofName).isMetric()) {
			//non-metric cannot have a velocity
			valueFrom = fromPose.get(dofName, 0);
			velocityFrom = fromPose.get(dofName, 1);
			if (velocityFrom === null) {
				velocityFrom = 0;
			}
			valueTo = toPose.get(dofName, 0);
			var accel = this.defaultMaxAccel;
			if (this.maxAccelByDOF[dofName]) {
				//this dof has a custom acceleration selected
				accel = this.maxAccelByDOF[dofName];
			}

			var myTime = this.planner.computeWithFixedAccel(velocityFrom, 0, valueTo - valueFrom, accel)._totalTime;
			if (myTime > duration) {
				duration = myTime;
				//slowestJoint = dofName;
				//slowestJointDistance = Math.abs(valueTo - valueFrom);
			}
		}
	}
	//console.log("AccelerationTransitionBuilder: DOF:"+slowestJoint+" drove a transition time of "+duration+" for distance "+slowestJointDistance);

	if (this.minTransitionTime && this.minTransitionTime > duration) {
		duration = this.minTransitionTime;
	}

	/** @type {Object<string,AccelPlan>} */
	var accelPlans = {};
	for (di = 0; di < onDOFs.length; di++) {
		dofName = onDOFs[di];
		if (this.robotInfo.getDOFInfo(dofName).isMetric()) {
			//non-metric cannot have a velocity
			valueFrom = fromPose.get(dofName, 0);
			velocityFrom = fromPose.get(dofName, 1);
			if (velocityFrom === null) {
				velocityFrom = 0;
			}
			valueTo = toPose.get(dofName, 0);

			if (duration > 0.0000000001) {
				//unstable to have fixed time very short plans, arbitrary accel.  (also, unnecessary)
				accelPlans[dofName] = this.planner.computeWithFixedTime(velocityFrom, 0, valueTo - valueFrom, duration);
			} else {
				accelPlans[dofName] = null;
			}
		}
	}

	for (di = 0; di < onDOFs.length; di++) {
		dofName = onDOFs[di];
		valueFrom = fromPose.get(dofName, 0);
		valueTo = toPose.get(dofName, 0);
		var dataNew = new TimestampedBuffer();
		dataNew.append(0, valueFrom);

		var plan = accelPlans[dofName];
		if (plan) {
			var t = tickInterval;
			while (t < duration) {
				var planSample = valueFrom + plan.displacementAtTime(t);
				dataNew.append(t, planSample);
				t = t + tickInterval;
			}
		}

		dataNew.append(duration, valueTo);
		transition.addTrack(new MotionTrack(dofName, dataNew, duration));
	}

	return transition;
};

/**
 * @return {AccelerationTransitionBuilder}
 * @override
 */
AccelerationTransitionBuilder.prototype.clone = function () {
	var t = new AccelerationTransitionBuilder(this.robotInfo, this.defaultMaxVelocity, this.defaultMaxAccel);

	t.minTransitionTime = this.minTransitionTime;

	var i;
	var dofs = Object.keys(this.maxVelocityByDOF);
	for (i = 0; i < dofs.length; i++) {
		t.maxVelocityByDOF[dofs[i]] = this.maxVelocityByDOF[dofs[i]];
	}

	dofs = Object.keys(this.maxAccelByDOF);
	for (i = 0; i < dofs.length; i++) {
		t.maxAccelByDOF[dofs[i]] = this.maxAccelByDOF[dofs[i]];
	}

	return t;
};

module.exports = AccelerationTransitionBuilder;
//# sourceMappingURL=../map/animation-animate/AccelerationTransitionBuilder.js.map
