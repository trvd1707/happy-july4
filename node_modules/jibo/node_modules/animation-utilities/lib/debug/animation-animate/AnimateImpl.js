/**
 * @author mattb
 */

"use strict";

var AnimationLoader = require("../ifr-motion/loaders/AnimationLoader");
var Motion = require("../ifr-motion/base/Motion");
var AnnotatedMotion = require("../ifr-motion/base/AnnotatedMotion");
var Pose = require("../ifr-motion/base/Pose");
var LinearTransitionBuilder = require("./LinearTransitionBuilderImpl");
var AccelerationTransitionBuilder = require("./AccelerationTransitionBuilder");
var SingleLookatBuilder = require("./SingleLookatBuilder");
var SimpleMotionGenerator = require("./timeline/SimpleMotionGenerator");
var LoopedMotionGenerator = require("./timeline/LoopedMotionGenerator");
var slog = require("../ifr-core/SLog");
var RendererOutput = require("../animation-visualize/RendererOutput");
var DOFSet = require("../geometry-info/DOFSet");
var THREE = require("three");

/**
 * @type {Object.<string, AnimationLoadResult>}
 * @private
 */

var animationCache = {};
var animationLoader = new AnimationLoader();

/**
 *
 * @param {AnimationUtilities} animationUtilities - The associated animation utilities.
 * @param {string} uri - Location of animation file to load.
 * @param {AnimationBuilderCreatedCallback} cb - Callback; receives newly-created AnimationBuilder instance or null if creation/load failed.
 * @param {boolean} forceReload - If true, reloads from disk, even if cached (new value will be cached). Defaults to false.
 * @param {string} [layer] - Optional; layer to play to.
 * @private
 */
var createAnimationBuilder = function createAnimationBuilder(animationUtilities, uri, cb, forceReload, layer) {

	var self = animationUtilities;

	animate.trajectory.getAnimation(uri, function (motion) {
		var builder = null;
		if (motion) {
			builder = new AnimationBuilder(self.timeline, motion, self.defaultTransition === null ? null : self.defaultTransition.clone(), self.robotInfo, layer);
		}
		if (cb) {
			cb(builder);
		}
	}, forceReload);
};

/**
 * @description
 * Animation APIs
 *
 * All units of measure in SI (meters).
 *
 * ```
 * var animate = require("jibo").animate;
 * ```
 *
 * Loading and playback of scripted animations:
 * ```
 * var animPath = "some/path/dance.keys";  // path to animation file
 * var basePath = "some/path";             // base path for texture resolution
 *
 * animate.createAnimationBuilderFromKeysPath(animPath, basePath, (builder) => {
 *     // add listener
 *     builder.on(animate.AnimationEventType.STOPPED, (eventType, instance, payload) => {
 *         console.log("Animation stopped; was interrupted = " + payload.interrupted);
 *     });
 *
 *     // trigger an instance of the animation
 *     builder.play();
 * });
 *
 * ```
 *
 * Procedural lookat/orient behaviors:
 * ```
 * var target = new animate.THREE.Vector3(1.0, 0.0, 1.0);  // target position to look at
 *
 * var builder = animate.createLookatBuilder();
 * builder.startLookat(target);
 *
 * ```
 *
 * Utility methods, for example:
 * ```
 * animate.blink();  // blink the eye!
 * animate.setLEDColor([0.0, 0.0, 1.0]);  // set the LED color to blue
 * ```
 *
 * @exports jibo/animate
 */
var AnimationUtilities = function AnimationUtilities() {};

/**
 * @private
 * @param {MotionTimeline} timeline
 * @param {RobotInfo} robotInfo
 */
AnimationUtilities.prototype.init = function (timeline, robotInfo) {
	var self = this;

	/** @type {MotionTimeline} */
	/** @private */
	this.timeline = timeline;

	/** @type {RobotInfo} */
	/** @private */
	this.robotInfo = robotInfo;

	/** @type {TransitionBuilder} */
	/** @private */
	this.defaultTransition = this.createAccelerationTransitionBuilder(3, 5);

	//setup default defaultTransition to be fast on eye dofs, medium on body dofs, fast on LED
	this.defaultTransition.setLimits(robotInfo.getBodyDOFNames(), 3, 5);
	this.defaultTransition.setLimits(robotInfo.getEyeDOFNames(), 20, 40);
	this.defaultTransition.setLimits(robotInfo.getDOFSet("LED").getDOFs(), 10, 20);

	this.blinkBuilder = null;
	this.blinkInProgress = false;
	createAnimationBuilder(this, robotInfo.getConfig().getRobotURL() + "jibo_blink.anim", function (bb) {
		bb.setTransitionIn(null);
		bb.on(animate.AnimationEventType.STOPPED, function () {
			self.blinkInProgress = false;
		});
		bb.on(animate.AnimationEventType.CANCELLED, function () {
			self.blinkInProgress = false;
		});
		self.blinkBuilder = bb;
	}, false, "blink");

	/**
  * Commonly-used DOF groups for use with [AnimationBuilder.setDOFs]{@link AnimationBuilder#setDOFs}
  * or [LookatBuilder.setDOFs]{@link LookatBuilder#setDOFs}.
  * @enum {DOFSet}
  * @memberof module:jibo/animate
  */
	var dofs = {
		/**
   * Complete set of robot DOFs.
   */
		ALL: robotInfo.getDOFSet("ALL"),
		/**
   * Base motor only.
   */
		BASE: robotInfo.getDOFSet("BASE"),
		/**
   * All body motors.
   */
		BODY: robotInfo.getDOFSet("BODY"),
		/**
   * All eye DOFs (transform, color, texture).
   */
		EYE: robotInfo.getDOFSet("EYE"),
		/**
   * Light ring LED color.
   */
		LED: robotInfo.getDOFSet("LED"),
		/**
   * All overlay DOFs (transform, color, texture).
   */
		OVERLAY: robotInfo.getDOFSet("OVERLAY"),
		/**
   * All screen DOFs (eye, overlay, background).
   */
		SCREEN: robotInfo.getDOFSet("SCREEN"),
		/**
   * Eye translation + rotation.
   */
		EYE_ROOT: robotInfo.getDOFSet("EYE_ROOT"),
		/**
   * Eye scale/deformation.
   */
		EYE_DEFORM: robotInfo.getDOFSet("EYE_DEFORM"),
		/**
   * Eye color + texture.
   */
		EYE_RENDER: robotInfo.getDOFSet("EYE_RENDER"),
		/**
   * Eye translation only.
   */
		EYE_TRANSLATE: robotInfo.getDOFSet("EYE_TRANSLATE"),
		/**
   * Eye rotation only.
   */
		EYE_ROTATE: robotInfo.getDOFSet("EYE_ROTATE"),
		/**
   * Eye color only.
   */
		EYE_COLOR: robotInfo.getDOFSet("EYE_COLOR"),
		/**
   * Eye texture only.
   */
		EYE_TEXTURE: robotInfo.getDOFSet("EYE_TEXTURE"),
		/**
   * Overlay translation + rotation.
   */
		OVERLAY_ROOT: robotInfo.getDOFSet("OVERLAY_ROOT"),
		/**
   * Overlay scale/deformation.
   */
		OVERLAY_DEFORM: robotInfo.getDOFSet("OVERLAY_DEFORM"),
		/**
   * Overlay color + texture.
   */
		OVERLAY_RENDER: robotInfo.getDOFSet("OVERLAY_RENDER"),
		/**
   * Overlay translation only.
   */
		OVERLAY_TRANSLATE: robotInfo.getDOFSet("OVERLAY_TRANSLATE"),
		/**
   * Overlay rotation only.
   */
		OVERLAY_ROTATE: robotInfo.getDOFSet("OVERLAY_ROTATE"),
		/**
   * Overlay color only.
   */
		OVERLAY_COLOR: robotInfo.getDOFSet("OVERLAY_COLOR"),
		/**
   * Overlay texture only.
   */
		OVERLAY_TEXTURE: robotInfo.getDOFSet("OVERLAY_TEXTURE"),
		/**
   * Screen background color + texture.
   */
		SCREEN_BG_RENDER: robotInfo.getDOFSet("SCREEN_BG_RENDER"),
		/**
   * Screen background color only.
   */
		SCREEN_BG_COLOR: robotInfo.getDOFSet("SCREEN_BG_COLOR"),
		/**
   * Screen background texture only.
   */
		SCREEN_BG_TEXTURE: robotInfo.getDOFSet("SCREEN_BG_TEXTURE")
	};
	this.dofs = dofs;
};

/**
 * Gets the robot configuration info used by the animate module,
 * including DOF names, default values, and other geometric info.
 *
 * @return {RobotInfo}
 */
AnimationUtilities.prototype.getRobotInfo = function () {
	return this.robotInfo;
};

/**
 * Gets the high-precision clock used by the animate module.
 *
 * @return {Clock}
 */
AnimationUtilities.prototype.getClock = function () {
	return this.timeline.getClock();
};

/**
 * @callback module:jibo/animate~AnimationBuilderCreatedCallback
 * @param {AnimationBuilder} animationBuilder - The AnimationBuilder or null on failure
 */

/**
 * Creates an animation builder from a .anim file at the specified uri. The animation will be loaded first if
 * necessary. This builder can be used for configuring animation parameters and inserting
 * an instance into the timeline.
 *
 * @param {string} uri - Path to the .anim file.
 * @param {module:jibo/animate~AnimationBuilderCreatedCallback} cb - Callback; receives newly-created {@link AnimationBuilder}, or null if creation/load failed.
 * @param {boolean} forceReload - If true, reloads from disk even if cached (new value will be cached). Defaults to false.
 */
AnimationUtilities.prototype.createAnimationBuilder = function (uri, cb, forceReload) {

	createAnimationBuilder(this, uri, cb, forceReload);
};

/**
 * Creates an animation builder from a pre-loaded (or pre-assembled) animation data structure.
 * This builder can be used for configuring animation parameters and inserting
 * an instance into the timeline.
 * The animation data object must match the structure specified for on-disk (.anim) animation files.
 *
 * @param {Object} animationData - The animation data object.
 * @param {string} [parentDirectoryURI] - Optional; if present, texture paths will be resolved relative to the specified directory.
 * @param {string} [cacheKey] - Optional; if present, results will be cached using the specified key.
 * @return {AnimationBuilder} - The newly-created AnimationBuilder instance, or null if creation failed.
 */

AnimationUtilities.prototype.createAnimationBuilderFromData = function (animationData, parentDirectoryURI, cacheKey) {

	var motion = animate.trajectory.parseAnimation(animationData, parentDirectoryURI, cacheKey);
	if (motion) {
		return new AnimationBuilder(this.timeline, motion, this.defaultTransition === null ? null : this.defaultTransition.clone(), this.robotInfo);
	} else {
		return null;
	}
};

/**
 * Creates a builder for initiating lookat actions. This builder can be used for configuring a lookat
 * behaviors and inserting an instance of that lookat into the timeline.
 * @return {LookatBuilder}
 */
AnimationUtilities.prototype.createLookatBuilder = function () {
	return new SingleLookatBuilder(this.timeline, this.robotInfo, this.defaultTransition === null ? null : this.defaultTransition.clone());
};

/**
 * Animates Jibo's eye to blink once.
 * @param [interrupt] {boolean} Set to true to interrupt an ongoing blink. Set to false (default) to ignore blink calls during an ongoing blink.
 */
AnimationUtilities.prototype.blink = function (interrupt) {
	if (this.blinkBuilder != null) {
		if (this.blinkInProgress === false || interrupt === true) {
			this.blinkBuilder.play();
			this.blinkInProgress = true;
		}
	} else {
		slog.warn("Blink requested but blink builder not yet loaded");
	}
};

/**
 * Stop all degrees of freedom motion on time-line
 * @private
 */
AnimationUtilities.prototype.stopAll = function () {
	//TODO
};

/**
 * Convenience call that sets opacity of eye and overlay to 0% or 100%.
 * @param {boolean} visible Set to true to make the eye visible (default). Set to false to make the eye invisible.
 */
AnimationUtilities.prototype.setEyeVisible = function (visible) {
	var eyeTextureDOF = this.robotInfo.getDOFSet("EYE_TEXTURE").getDOFs()[0];
	var overlayTextureDOF = this.robotInfo.getDOFSet("OVERLAY_TEXTURE").getDOFs()[0];
	var defaultValues = this.robotInfo.getDefaultDOFValues();
	var opaqueTexture = defaultValues[eyeTextureDOF];
	var clearTexture = defaultValues[overlayTextureDOF];

	var eyePose = new Pose("eye visibility pose", [eyeTextureDOF, overlayTextureDOF]);
	if (visible) {
		eyePose.set(eyeTextureDOF, opaqueTexture, 0);
		eyePose.set(overlayTextureDOF, clearTexture, 0);
	} else {
		eyePose.set(eyeTextureDOF, clearTexture, 0);
		eyePose.set(overlayTextureDOF, clearTexture, 0);
	}

	var eyeMotion = Motion.createFromPose("eye visibility motion", eyePose, 0.5);
	var startTime = this.timeline.getClock().currentTime();
	this.timeline.add(new SimpleMotionGenerator(eyeMotion, startTime, this.robotInfo), "default");
};

/**
 * Convenience call that scales Jibo's eye to provided value, preserving proportions.
 * @param {number} scale Number to scale Jibo's eye size by.
 */
AnimationUtilities.prototype.setEyeScale = function (scale) {
	var eyeDeformers = this.robotInfo.getDOFSet("EYE_DEFORM").plus("OVERLAY_DEFORM").getDOFs();
	var defaultPose = this.robotInfo.getKinematicInfo().getDefaultPose();
	var eyePose = new Pose("eye pose", eyeDeformers);
	for (var i = 0; i < eyeDeformers.length; i++) {
		eyePose.set(eyeDeformers[i], defaultPose.get(eyeDeformers[i], 0) * scale, 0);
	}
	var eyeMotion = Motion.createFromPose("eye scale motion", eyePose, 0.5);
	var startTime = this.timeline.getClock().currentTime();
	this.timeline.add(new SimpleMotionGenerator(eyeMotion, startTime, this.robotInfo), "default");
};

/**
 * Convenience call that scales Jibo's eye by the specified x and y scale components.
 * @param {number} xScale - Desired x-axis scale.
 * @param {number} yScale - Desired y-axis scale.
 */
AnimationUtilities.prototype.setEyeScaleXY = function (xScale, yScale) {
	var eyeDeformers = this.robotInfo.getDOFSet("EYE_DEFORM").plus("OVERLAY_DEFORM").getDOFs();
	var defaultPose = this.robotInfo.getKinematicInfo().getDefaultPose();
	var eyePose = new Pose("eye pose", eyeDeformers);
	for (var i = 0; i < eyeDeformers.length; i++) {
		if (eyeDeformers[i].indexOf("_t_2") > -1) {
			eyePose.set(eyeDeformers[i], defaultPose.get(eyeDeformers[i], 0) * yScale, 0);
		} else {
			eyePose.set(eyeDeformers[i], defaultPose.get(eyeDeformers[i], 0) * xScale, 0);
		}
	}
	var eyeMotion = Motion.createFromPose("eye scale motion", eyePose, 0.5);
	var startTime = this.timeline.getClock().currentTime();
	this.timeline.add(new SimpleMotionGenerator(eyeMotion, startTime, this.robotInfo), "default");
};

/**
 * Convenience call that sets eye position to given x, y.
 * @param {number} x Desired x position of the eye in pixels.
 * @param {number} y Desired y position of the eye in pixels.
 */
AnimationUtilities.prototype.setEyePosition = function (x, y) {
	var eyeXYDOFs = this.robotInfo.getDOFSet("EYE_TRANSLATE").getDOFs();
	var overlayXYDOFs = this.robotInfo.getDOFSet("OVERLAY_TRANSLATE").getDOFs();
	var eyePose = new Pose("eye pose", eyeXYDOFs.concat(overlayXYDOFs));
	eyePose.set(eyeXYDOFs[0], x, 0);
	eyePose.set(eyeXYDOFs[1], y, 0);
	eyePose.set(overlayXYDOFs[0], x, 0);
	eyePose.set(overlayXYDOFs[1], y, 0);
	var eyeMotion = Motion.createFromPose("eye position motion", eyePose, 0.5);
	var startTime = this.timeline.getClock().currentTime();
	this.timeline.add(new SimpleMotionGenerator(eyeMotion, startTime, this.robotInfo), "default");
};

/**
 * Convenience call that sets the LED light ring color.  Pass in either
 * a THREE.Color, or an array of three numbers (r,g,b) from 0 to 1.
 *
 * @param {THREE.Color|number[]} color Color to set the LED light ring to.
 */
AnimationUtilities.prototype.setLEDColor = function (color) {
	/** @type {number[]} */
	var rgbValues = null;
	if (Array.isArray(color)) {
		rgbValues = color;
	} else {
		rgbValues = color.toArray();
	}
	var dofNames = this.robotInfo.getDOFSet("LED").getDOFs();
	var colorPose = new Pose("LED pose", dofNames);
	for (var i = 0; i < 3; i++) {
		colorPose.set(dofNames[i], rgbValues[i], 0);
	}
	var colorMotion = Motion.createFromPose("LED motion", colorPose, 0.5);
	//TODO: reactionTime
	//var delay = this.timeline.getReactionTime(animate.MODALITY_NAME, colorMotion);
	var delay = 0;
	var startTime = this.timeline.getClock().currentTime().add(delay);
	this.timeline.add(new SimpleMotionGenerator(colorMotion, startTime, this.robotInfo), "default");
};

/**
 * Restores the robot to its default pose, respecting current base orientation.
 *
 * Optional arguments allow specification of which DOFs to include in the centering behavior and
 * whether the centering behavior should restore the robot to its global "home" orientation. By default, the
 * centering behavior will include all DOFs and will preserve the robot's current local orientation.
 *
 * @param {DOFSet} [whichDOFs] - Optional; set of DOFs to restore to default position. Defaults to all DOFs.
 * @param {boolean} [centerGlobally] - Optional; if true, also restores the robot to its global "home" orientation. Defaults to false.
 * @param {Function} [completionCallback] - Optional completion callback, called when centering behavior completes or is interrupted.
 */
AnimationUtilities.prototype.centerRobot = function (whichDOFs, centerGlobally, completionCallback) {
	if (whichDOFs === undefined || whichDOFs === null) whichDOFs = this.dofs.ALL;
	if (centerGlobally === undefined || centerGlobally === null) centerGlobally = false;

	var centerMotion = Motion.createFromPose("center motion", this.robotInfo.getKinematicInfo().getDefaultPose(), 1 / 30, whichDOFs.getDOFs());
	var animBuilder = new AnimationBuilder(this.timeline, new AnnotatedMotion(centerMotion), this.defaultTransition.clone(), this.robotInfo);
	var builderCount = 1;

	var resetBase = centerGlobally && whichDOFs.hasDOF(this.dofs.BASE.getDOFs()[0]);
	var lookatBuilder = null;
	if (resetBase) {
		lookatBuilder = this.createLookatBuilder();
		lookatBuilder.setDOFs(this.dofs.BASE);
		builderCount++;
	}

	if (completionCallback) {
		var builderFinished = function builderFinished() {
			builderCount--;
			if (builderCount === 0) {
				completionCallback();
			}
		};
		animBuilder.on(animate.AnimationEventType.CANCELLED, builderFinished);
		animBuilder.on(animate.AnimationEventType.STOPPED, builderFinished);
		if (lookatBuilder) {
			lookatBuilder.on(animate.LookatEventType.CANCELLED, builderFinished);
			lookatBuilder.on(animate.LookatEventType.STOPPED, builderFinished);
		}
	}

	animBuilder.play();
	if (lookatBuilder) {
		lookatBuilder.startLookat(new THREE.Vector3(1.0, 0.0, 0.0));
	}
};

/**
 * Sets the TransitionBuilder that the animate module will use by default to generate procedural transitions
 * between animations or static poses that require intermediate motion.
 *
 * @param {TransitionBuilder} transition - The TransitionBuilder to use as the new default.
 */
AnimationUtilities.prototype.setDefaultTransition = function (transition) {
	this.defaultTransition = transition;
};

/**
 * Gets the default TransitionBuilder used by the animate module for procedural transitions.
 *
 * @return {TransitionBuilder}
 */
AnimationUtilities.prototype.getDefaultTransition = function () {
	return this.defaultTransition;
};

/**
 * Creates a new transition builder that uses simple linear blending to generate transition motions.
 *
 * @return {LinearTransitionBuilder} - A new, configurable linear transition builder./
 */
AnimationUtilities.prototype.createLinearTransitionBuilder = function () {
	return animate.trajectory.createLinearTransitionBuilder(this.robotInfo);
};

/**
 * Creates a new transition builder that can generate transition motions using
 * configurable acceleration and velocity limits.
 *
 * @param {number} defaultMaxVelocity - Max velocity to use by default.
 * @param {number} defaultMaxAcceleration - Max acceleration to use by default.
 * @return {AccelerationTransitionBuilder} - A new, configurable acceleration transition builder.
 */
AnimationUtilities.prototype.createAccelerationTransitionBuilder = function (defaultMaxVelocity, defaultMaxAcceleration) {
	return animate.trajectory.createAccelerationTransitionBuilder(this.robotInfo, defaultMaxVelocity, defaultMaxAcceleration);
};

/**
 * Gets all RobotRenderers associated with the provided timeline.
 * @param {MotionTimeline} timeline
 * @return {RobotRenderer[]} renderers
 * @private
 */
function getRenderers(timeline) {
	/** @type {RobotRenderer[]} */
	var renderers = [];

	var outputs = timeline.getOutputs();
	for (var i = 0; i < outputs.length; i++) {
		if (outputs[i] instanceof RendererOutput) {
			renderers = renderers.concat(outputs[i].getRenderers());
		}
	}
	return renderers;
}

/**
 * Installs this render plugin. If a plugin with the same name is already installed, that
 * plugin will be uninstalled first.
 * @param {RenderPlugin} renderPlugin - Plugin to install.
 */
AnimationUtilities.prototype.installRenderPlugin = function (renderPlugin) {
	/** @type {RobotRenderer[]} */
	var renderers = getRenderers(this.timeline);
	for (var i = 0; i < renderers.length; i++) {
		renderers[i].installRenderPlugin(renderPlugin);
	}
};

/**
 * Removes named RenderPlugin. [uninstall()]{@link RenderPlugin#uninstall} will be called on the plugin.
 *
 * @param {string} renderPluginName RenderPlugin to remove.
 */
AnimationUtilities.prototype.removeRenderPlugin = function (renderPluginName) {
	/** @type {RobotRenderer[]} */
	var renderers = getRenderers(this.timeline);
	for (var i = 0; i < renderers.length; i++) {
		renderers[i].removeRenderPlugin(renderPluginName);
	}
};

/**
 * Gets the names of all installed RenderPlugins.
 *
 * @returns {string[]}
 */
AnimationUtilities.prototype.getInstalledRenderPluginNames = function () {
	/** @type {string[]} */
	var pluginNames = [];

	/** @type {RobotRenderer[]} */
	var renderers = getRenderers(this.timeline);
	for (var i = 0; i < renderers.length; i++) {
		var partialNames = renderers[i].getInstalledRenderPluginNames();
		for (var j = 0; j < partialNames.length; j++) {
			//don't duplicate names
			if (pluginNames.indexOf(partialNames[j]) < 0) {
				pluginNames.push(partialNames[j]);
			}
		}
	}

	return pluginNames;
};

/**
 * Protected constructor for internal use only.
 *
 * An AnimationInstance is a handle for an ongoing instance of a specific, configured animation.
 * AnimationInstances are returned by AnimationBuilder's [play]{@link AnimationBuilder#play} method.
 *
 * @param {AnimationBuilder} builder - Protected constructor parameter.
 * @param {MotionGenerator} transitionClip - Protected constructor parameter.
 * @param {MotionGenerator} animationClip - Protected constructor parameter.
 * @param {string} layer - Protected constructor parameter.
 * @protected
 * @constructor
 * @global
 */
var AnimationInstance = function AnimationInstance(builder, transitionClip, animationClip, layer) {
	/** @type {AnimationBuilder} */
	/** @private */
	this.builder = builder;
	/** @type {MotionGenerator} */
	/** @private */
	this.transitionClip = transitionClip;
	/** @type {MotionGenerator} */
	/** @private */
	this.animationClip = animationClip;
	/** @type {string} */
	/** @private */
	this.layer = layer;
};

/**
 * Stops this animation instance.
 * @memberof AnimationInstance
 */
AnimationInstance.prototype.stop = function () {

	var timeline = this.builder.timeline;
	//find the soonest time we have not yet committed to
	//TODO: this is sometimes overly conservative:
	// in some edge cases dofs still in the clips may not be using their whole commitment window
	var reactionTime = 0;
	//TODO: reactionTime
	//if(this.transitionClip!==null && !this.transitionClip.hasExited()){
	//	reactionTime = timeline.getReactionTime(animate.MODALITY_NAME, this.transitionClip.getMotion());
	//}
	//
	//if(!this.animationClip.hasExited()){
	//	reactionTime = Math.max(reactionTime, timeline.getReactionTime(animate.MODALITY_NAME, this.animationClip.getMotion()));
	//}

	//this is the earliest we could stop for the related dofs (aside from conservative consideration above)
	/** @type {Time} */
	var stopTime = timeline.getClock().currentTime().add(reactionTime);

	//also, if all clips are fully committed, we will not stop
	if (stopTime.isGreater(this.animationClip.getEndTime())) {
		//stopTime is after clip is already over; cannot stop.  do nothing.
		//slog it?
		if (this.animationClip.hasExited()) {
			slog.warn("Ignoring stop on " + this.animationClip.getName() + " as it is already over");
		} else {
			slog.warn("Ignoring stop on " + this.animationClip.getName() + " as it is already committed");
		}
		return;
	}

	//however we will not stop before any of the clips start!
	if (this.transitionClip === null) {
		//there is no transition, our first stop opportunity is at the start of the main clip
		if (this.animationClip.getStartTime().isGreater(stopTime)) {
			stopTime = this.animationClip.getStartTime();
			slog.info("Stopping called on transitionless animation " + this.animationClip.getName() + " before anim started, moving stopTime forward");
		}
	} else {
		if (this.transitionClip.getStartTime().isGreater(stopTime)) {
			stopTime = this.transitionClip.getStartTime();
			slog.info("Stopping called on animation " + this.animationClip.getName() + " before its transition started, moving stopTime forward");
		}
	}

	/** @type {MotionGenerator} */
	var useClip = null;

	//now find out which dofs are being used on stop time
	if (this.transitionClip !== null && this.transitionClip.getEndTime().isGreater(stopTime)) {
		//we have a transition clip, and our stop time is before the end of it, so we should
		//use that clip for the stop pose
		useClip = this.transitionClip;
	} else {
		//we don't have a transition clip, or our stop time is after the end of it, so use anim
		useClip = this.animationClip;
	}

	/** @type {string[]} */
	var dofsToStop = [];

	/** @type {string[]} */
	var possibleDOFs = useClip.getDOFs();

	var deltaToStopForClip = stopTime.subtract(useClip.getStartTime());

	for (var i = 0; i < possibleDOFs.length; i++) {
		var durationForDOF = useClip.getDurationForDOF(possibleDOFs[i]);
		if (durationForDOF !== null && durationForDOF > deltaToStopForClip) {
			dofsToStop.push(possibleDOFs[i]);
		}
	}

	//TODO: using zero-duration motion for now, might want to add explicit timeline stop() method

	/** @type {Pose} */
	var stopPose = new Pose("stop pose", dofsToStop);
	for (var d = 0; d < dofsToStop.length; d++) {
		stopPose.set(dofsToStop[d], [0]);
	}

	/** @type {Motion} */
	var stopMotion = Motion.createFromPose(useClip.getName() + "_stop", stopPose, 0);
	var stopClip = new SimpleMotionGenerator(stopMotion, stopTime, this.builder.robotInfo);
	timeline.add(stopClip, this.layer);
};

/**
 * Get the start time for the animation's 'in' transition, or the start time for
 * the animation itself, if no 'in' transition is specified.
 *
 * @return {Time}
 * @memberof AnimationInstance
 */
AnimationInstance.prototype.getTransitionStartTime = function () {
	if (this.transitionClip) {
		return this.transitionClip.getStartTime();
	} else {
		return this.animationClip.getStartTime();
	}
};

/**
 * Gets the estimated start time for the animation, following its
 * 'in' transition, if applicable.
 *
 * @return {Time}
 * @memberof AnimationInstance
 */
AnimationInstance.prototype.getAnimationStartTime = function () {
	return this.animationClip.getStartTime();
};

/**
 * Gets the estimated end time for the animation.
 *
 * @return {Time}
 * @memberof AnimationInstance
 */
AnimationInstance.prototype.getAnimationEndTime = function () {
	return this.animationClip.getEndTime();
};

/**
 * Gets the AnimationBuilder that generated this instance through "play".
 * @return {AnimationBuilder}
 * @memberof AnimationInstance
 */
AnimationInstance.prototype.getBuilder = function () {
	return this.builder;
};

/**
 * Protected constructor for internal use only.
 *
 * An AnimationBuilder is used to configure parameters and register event
 * listeners for a specific chunk of animation data. Instances of the configured
 * animation can be triggered via the [play]{@link AnimationBuilder#play} method.
 *
 * AnimationBuilders are typically created via the animate module's
 * [createAnimationBuilderFromKeysPath]{@link module:jibo/animate#createAnimationBuilderFromKeysPath} method.
 *
 * ```
 * var animate = require("jibo").animate;
 *
 * var animPath = "some/path/dance.keys";  // path to animation file
 * var basePath = "some/path";             // base path for texture resolution
 *
 * animate.createAnimationBuilderFromKeysPath(animPath, basePath, (builder) => {
 *     // add listener
 *     builder.on(animate.AnimationEventType.STOPPED, (eventType, instance, payload) => {
 *         console.log("Animation stopped; was interrupted = " + payload.interrupted);
 *     });
 *
 *     // trigger an instance of the animation
 *     builder.play();
 * });
 *
 * ```
 *
 * @param {MotionTimeline} timeline - Protected constructor parameter.
 * @param {AnnotatedMotion} motion - Protected constructor parameter.
 * @param {TransitionBuilder} transition - Protected constructor parameter.
 * @param {RobotInfo} robotInfo - Protected constructor parameter.
 * @param {string} [layer] - Protected constructor parameter.
 * @constructor
 * @protected
 * @global
 */
var AnimationBuilder = function AnimationBuilder(timeline, motion, transition, robotInfo, layer) {
	if (layer == null) {
		//null or undefined
		layer = "default";
	}
	/** @private */
	this.layer = layer;

	/** @type {MotionTimeline} */
	/** @private */
	this.timeline = timeline;
	/** @type {AnnotatedMotion} */
	/** @private */
	this.motion = motion;
	/** @type {string[]} */
	/** @private */
	this.dofNames = Object.keys(motion.getMotion().getTracks());
	/** @type {Object<AnimationEventType,AnimationEventCallback[]>} */
	/** @private */
	this.eventHandlers = {};
	/** @type {number} */
	/** @private */
	this.speed = 1;
	/** @type {number} */
	/** @private */
	this.numLoops = 1;
	/** @type {number} */
	/** @private */
	this.inPoint = 0;
	/** @type {number} */
	/** @private */
	this.outPoint = motion.getDuration();
	/** @type {TransitionBuilder} */
	/** @private */
	this.transition = transition;

	/** @type {boolean} */
	/** @private */
	this.stopOrient = true;

	/** @type {string[]} */
	/** @private */
	this.layerDOFs = timeline.getDOFsForLayer(layer);

	/** @type {RobotInfo} */
	/** @private */
	this.robotInfo = robotInfo;

	//init to all dofs
	this.setDOFs(null);
};

//map between timeline events and animation events
AnimationBuilder.prototype._createStartedHandler = function (animationInstance) {
	var h = this.eventHandlers[animate.AnimationEventType.STARTED];
	if (h) {
		var startHandlers = h.slice(0);
		return function () {
			for (var i = 0; i < startHandlers.length; i++) {
				startHandlers[i](animate.AnimationEventType.STARTED, animationInstance, {});
			}
		};
	} else {
		return null;
	}
};

//map between timeline events and animation events
AnimationBuilder.prototype._createStoppedHandler = function (animationInstance) {
	var h = this.eventHandlers[animate.AnimationEventType.STOPPED];
	if (h) {
		var stopHandlers = h.slice(0);
		return function (interrupted) {
			for (var i = 0; i < stopHandlers.length; i++) {
				stopHandlers[i](animate.AnimationEventType.STOPPED, animationInstance, { interrupted: interrupted });
			}
		};
	} else {
		return null;
	}
};

//map between timeline events and animation events
AnimationBuilder.prototype._createRemovedHandler = function (animationInstance) {
	var hStopped = this.eventHandlers[animate.AnimationEventType.STOPPED];
	var hCancelled = this.eventHandlers[animate.AnimationEventType.CANCELLED];
	if (hStopped || hCancelled) {
		var stopHandlers = null;
		var cancelHandlers = null;
		if (hStopped) {
			stopHandlers = hStopped.slice(0);
		}
		if (hCancelled) {
			cancelHandlers = hCancelled.slice(0);
		}
		return function (started, stopped) {
			var i;
			if (stopHandlers) {
				if (started && !stopped) {
					//if a clip is removed after start and before stop, we'll send a stop (interrupted) to the listeners
					for (i = 0; i < stopHandlers.length; i++) {
						stopHandlers[i](animate.AnimationEventType.STOPPED, animationInstance, { interrupted: true });
					}
				}
			}
			if (cancelHandlers) {
				if (!started) {
					//if it never started, then we'll send a cancel.
					for (i = 0; i < cancelHandlers.length; i++) {
						cancelHandlers[i](animate.AnimationEventType.CANCELLED, animationInstance, {});
					}
				}
			}
		};
	} else {
		return null;
	}
};

//map between timeline events and animation events
AnimationBuilder.prototype._createEventHandler = function (animationInstance) {
	var eventHandlers = null;
	if (this.eventHandlers[animate.AnimationEventType.EVENT]) {
		eventHandlers = this.eventHandlers[animate.AnimationEventType.EVENT].slice(0);
	}

	/** @type {Object<string,AnimationEventCallback[]>} */
	var customHandlers = {};
	var eventKeys = Object.keys(this.eventHandlers);
	for (var k = 0; k < eventKeys.length; k++) {
		var eventKey = eventKeys[k];
		if (eventKey !== animate.AnimationEventType.STARTED && eventKey !== animate.AnimationEventType.STOPPED && eventKey !== animate.AnimationEventType.CANCELLED && eventKey !== animate.AnimationEventType.EVENT) {
			if (this.eventHandlers[eventKey]) {
				customHandlers[eventKey] = this.eventHandlers[eventKey].slice(0);
			}
		}
	}

	if (eventHandlers || Object.keys(customHandlers).length > 0) {
		return function (motionEvent) {
			var i;
			if (eventHandlers) {
				for (i = 0; i < eventHandlers.length; i++) {
					eventHandlers[i](animate.AnimationEventType.EVENT, animationInstance, { eventName: motionEvent.getEventName(), payload: motionEvent.getPayload() });
				}
			}
			var eventName = motionEvent.getEventName();
			if (customHandlers[eventName]) {
				for (i = 0; i < customHandlers[eventName].length; i++) {
					customHandlers[eventName][i](eventName, animationInstance, motionEvent.getPayload());
				}
			}
		};
	} else {
		return null;
	}
};

/**
 * Triggers an instance of the animation to start playing, using the configuration represented
 * in this AnimationBuilder.
 *
 * @return {AnimationInstance}
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.play = function () {
	var startTime = this.timeline.getClock().currentTime();

	//limit to proper dofs
	var motion = new Motion(this.motion.getMotion().getName());
	for (var i = 0; i < this.dofNames.length; i++) {
		//todo: only do this if they don't match
		var track = this.motion.getMotion().getTracks()[this.dofNames[i]];
		if (track) {
			motion.addTrack(track);
		}
	}
	var motionInstance = new AnnotatedMotion(motion, this.motion.getEvents());

	//set speed if necessary
	if (this.speed !== 1) {
		motionInstance.setSpeed(this.speed);
	}

	var transitionDelay = 0;
	var transitionClip = null;
	if (this.transition) {
		var currentPose;
		var targetMotion;
		if (this.layer === "default") {
			// on the default layer, transition from: the current "absolute" pose (combination of default and lookat layers)
			//currentPose = this.timeline.getCurrentState(["default", "lookat"]).getPose();

			// transition to the target "absolute" pose: the first pose of the target motion combined with the current lookat
			//var motionStartPose = motionInstance.getMotion().getPoseAtTime(0, this.robotInfo.getKinematicInfo().getInterpolatorSet());
			//var currentLookatState = this.timeline.getCurrentState(["lookat"]);
			//var motionStartState = new LayerState(currentLookatState.getTime(), motionStartPose);
			//var targetState = this.timeline.getLayerCombiner().combineLayers(["default", "lookat"], [motionStartState, currentLookatState]);
			//targetMotion = Motion.createFromPose("target motion", targetState.getPose(), 0.5);

			currentPose = this.timeline.getCurrentState([this.layer]).getPose();
			targetMotion = motionInstance.getMotion();

			if (this.stopOrient) {
				var currentLookPose = this.timeline.getCurrentState(["lookat"]).getPose();
				var targetLookMotion = Motion.createFromPose("stop look", currentLookPose, 1);
				var lookTransition = this.transition.generateTransition(currentLookPose, targetLookMotion, 0, currentLookPose.getDOFNames());
				this.timeline.add(new SimpleMotionGenerator(lookTransition, startTime, this.robotInfo), "lookat");
			}
		} else {
			// on other layers, just transition from the current state of the layer to the start of the target motion
			currentPose = this.timeline.getCurrentState([this.layer]).getPose();
			targetMotion = motionInstance.getMotion();
		}

		var transitionMotion = this.transition.generateTransition(currentPose, targetMotion, 0, this.dofNames);

		transitionClip = new SimpleMotionGenerator(transitionMotion, startTime, this.robotInfo);
		transitionClip = this.timeline.add(transitionClip, this.layer);

		if (transitionClip !== null) {
			transitionDelay = transitionClip.getDuration();
		}
	}

	var animationInstance = new AnimationInstance(this, null, null, this.layer);

	var animationClip = null;
	if (this.numLoops === 1) {
		animationClip = new SimpleMotionGenerator(motionInstance.getMotion(), startTime.add(transitionDelay), this.robotInfo);
		animationClip.setEvents(motionInstance.getEvents());
	} else {
		var motionList = [motionInstance.getMotion()];
		var motionEventsList = [motionInstance.getEvents()];
		if (this.transition) {
			var finalPose = motionInstance.getMotion().getPoseAtTime(motionInstance.getMotion().getDuration(), this.robotInfo.getKinematicInfo().getInterpolatorSet());
			var loopTransition = this.transition.generateTransition(finalPose, motionInstance.getMotion(), 0, this.dofNames);
			motionList.push(loopTransition);
			motionEventsList.push([]);
		}
		animationClip = new LoopedMotionGenerator(motionList, this.numLoops, startTime.add(transitionDelay), this.robotInfo);
		animationClip.setEvents(motionEventsList);
	}
	animationClip.setHandlers(this._createStartedHandler(animationInstance), this._createStoppedHandler(animationInstance), this._createRemovedHandler(animationInstance), this._createEventHandler(animationInstance));
	animationClip = this.timeline.add(animationClip, this.layer);

	animationInstance.transitionClip = transitionClip;
	animationInstance.animationClip = animationClip;

	return animationInstance;
};

/**
 * Function signature for animation builder event listeners, for use with AnimationBuilder's [on]{@link AnimationBuilder#on} method.
 * @callback AnimationBuilder~AnimationEventCallback
 * @param {module:jibo/animate.AnimationEventType} eventName - The event type.
 * @param {AnimationInstance} animationInstance - Instance that generated this event.
 * @param {Object} payload - Event-specific payload.
 */

/**
 * Registers an event listener.
 * @param {module:jibo/animate.AnimationEventType} eventName - The event type to listen for.
 * @param {AnimationBuilder~AnimationEventCallback} callback - The listener function.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.on = function (eventName, callback) {
	/** @type {AnimationEventCallback[]} */
	var handlersForType = this.eventHandlers[eventName];
	if (!handlersForType) {
		handlersForType = [];
		this.eventHandlers[eventName] = handlersForType;
	}
	if (handlersForType.indexOf(callback) === -1) {
		handlersForType.push(callback);
	}
};

/**
 * Un-registers an event listener.
 * @param {module:jibo/animate.AnimationEventType} eventName - The event type.
 * @param {AnimationBuilder~AnimationEventCallback} callback - The listener function.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.off = function (eventName, callback) {
	/** @type {AnimationEventCallback[]} */
	var handlersForType = this.eventHandlers[eventName];
	if (handlersForType) {
		var index = handlersForType.indexOf(callback);
		if (index !== -1) {
			handlersForType.splice(index, 1);
		}
	}
};

/**
 * Sets the speed of the animation.
 *
 * @param {number} speed - Animation speed. 1 for normal speed, 2 for twice as fast, 0.5 for half speed, etc.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.setSpeed = function (speed) {
	this.speed = speed;
};

/**
 * Sets the number of times to loop the animation before stopping.
 * Specify 0 to loop forever.
 * @param {number} numLoops - Number of times to loop the animation; 0 to loop forever.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.setNumLoops = function (numLoops) {
	if (numLoops < 0) {
		throw new Error("numLoops value is negative: " + numLoops);
	}
	this.numLoops = numLoops;
};

/**
 * Sets the DOFs to be used by this builder. The DOFs used are the intersection of
 * the DOFs passed as the argument here, the DOFs present in the underlying motion, and
 * the DOFs used by the layer to which this builder is bound.
 *
 * Commonly-used DOF groups are defined in [animate.dofs]{@link module:jibo/animate.dofs}.
 *
 * @param {DOFSet|string[]} dofNames - Names of DOFs to use; null to use all DOFs.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.setDOFs = function (dofNames) {
	if (dofNames == null) {
		//null means max out the dofs
		dofNames = Object.keys(this.motion.getMotion().getTracks());
	} else if (dofNames instanceof DOFSet) {
		dofNames = dofNames.getDOFs();
	}

	this.dofNames = []; //add intersection of dofNames, dofs in this motion, and dofs in our layerDOFs
	for (var i = 0; i < dofNames.length; i++) {
		if (this.motion.getMotion().getTracks().hasOwnProperty(dofNames[i]) && //it's in the motion
		this.layerDOFs.indexOf(dofNames[i]) > -1) {
			//it's also in the layer
			this.dofNames.push(dofNames[i]);
		}
	}
};

/**
 * Gets the DOFs that will be used by this builder.
 *
 * @return {string[]}
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.getDOFs = function () {
	return this.dofNames;
};

/**
 * Set sub-clip to play in animation.  Times are in original time scale (rather than altered timescale resulting from setSpeed)
 * @param {number} inPoint - play from this time in seconds instead of start of animation.  will start from beginning if null/undefined
 * @param {number} outPoint - if present, play to this time in seconds instead of end of animation.  will play to end if null/undefined
 * @memberof AnimationBuilder
 * @private
 */
AnimationBuilder.prototype.setPlayBounds = function (inPoint, outPoint) {
	if (inPoint !== null && inPoint !== undefined) {
		this.inPoint = inPoint;
	} else {
		this.inPoint = 0;
	}

	if (outPoint !== null && outPoint !== undefined) {
		this.outPoint = outPoint;
	} else {
		this.outPoint = this.getSourceAnimationDuration();
	}
};

/**
 * Gets the duration, in seconds, of the source animation for this builder (unaffected by settings such as speed, etc).
 * @return {number}
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.getSourceAnimationDuration = function () {
	return this.motion.getSourceMotionDuration();
};

/**
 * Gets the duration, in seconds, of the animation that will be produced by this builder given current settings (speed, etc).
 * @return {number}
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.getConfiguredAnimationDuration = function () {
	var clipDuration = this.outPoint - this.inPoint;
	return clipDuration / this.speed;
};

/**
 * Sets the transition builder that will be used to generate a smooth
 * transition into the start of the animation.
 *
 * @param {TransitionBuilder} transition - Transition builder to use for the animation's 'in' transition.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.setTransitionIn = function (transition) {
	this.transition = transition;
};

/**
 * Gets the transition builder currently specified for the animation's 'in' transition.
 *
 * @return {TransitionBuilder}
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.getTransitionIn = function () {
	return this.transition;
};

/**
 * Sets the animation's base-blending policy.
 *
 * This policy has an effect only if the animation is configured to control the robot's base DOF.
 *
 * @param {boolean} stopOrient If true, the animation will seize exclusive control of
 * the robot's base DOF, stopping any in-progress orient behavior on that DOF. If false, the animation
 * will blend additively with any ongoing orient/lookt behavior on the base DOF.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.setStopOrient = function (stopOrient) {
	this.stopOrient = stopOrient;
};

/**
 * Sets the blending layer for the animation [warning: advanced usage only!]
 *
 * @param {string} layerName The name of the blending layer.
 * @memberof AnimationBuilder
 */
AnimationBuilder.prototype.setLayer = function (layerName) {
	if (this.timeline.getDOFsForLayer(layerName) === null) {
		slog.error("AnimationBuilder: ignoring setLayer with unknown layer name: " + layerName);
	} else {
		this.layer = layerName;
		this.layerDOFs = this.timeline.getDOFsForLayer(layerName);
		// trim our dofs to just the ones that are present in the layer
		this.setDOFs(this.dofNames.slice(0));
	}
};

/**
 * Protected constructor for internal use only.
 *
 * A LookatInstance is a handle for an ongoing instance of a particular
 * procedural lookat/orient behavior. LookatInstances are returned by
 * LookatBuilder's [startLookat]{@link LookatBuilder#startLookat} method.
 *
 * @class
 * @global
 * @protected
 */
var LookatInstance = {};

/**
 * @global
 */
LookatInstance.prototype = {

	/* interface definition:        */
	/* eslint-disable no-unused-vars */

	/**
  * Stops this lookat behavior.
  */
	stop: function stop() {},

	/**
  * Modifies the target of this lookat behavior. The behavior will be
  * redirected toward the specified target position, unless the behavior has
  * already been stopped or interrupted.
  *
  * @param {THREE.Vector3|number[]} target - The target position (in world-space) towards which the behavior will be redirected.
  */
	updateTarget: function updateTarget(target) {},

	/**
  * Gets the current target of the lookat behavior.
  *
  * @return {THREE.Vector3} current target
  */
	getTarget: function getTarget() {},

	/**
  * Gets the LookatBuilder that generated this instance through "startLookat".
  * @return {LookatBuilder}
  */
	getBuilder: function getBuilder() {}

	/* end interface definition:        */
	/* eslint-enable no-unused-vars */

};

/**
 * Protected constructor for internal use only.
 *
 * A LookatBuilder is used to configure parameters and register event
 * listeners for a procedural lookat/orient behavior.  Instances of the configured
 * behavior can be triggered via the [startLookat]{@link LookatBuilder#startLookat} method.
 *
 * LookatBuilders are created via the animate module's
 * [createLookatBuilder]{@link module:jibo/animate#createLookatBuilder} method.
 *
 * ```
 * var animate = require("jibo").animate;
 *
 * var target = new animate.THREE.Vector3(1.0, 0.0, 1.0);  // target position to look at
 *
 * var builder = animate.createLookatBuilder();
 * builder.startLookat(target);
 *
 * ```
 *
 * @class
 * @global
 * @protected
 */
var LookatBuilder = {};

/**
 * @public
 * @global
 */
LookatBuilder.prototype = {

	/* interface definition:        */
	/* eslint-disable no-unused-vars */

	/**
  * Triggers an instance of a lookat/orient behavior, using the configuration represented
  * in this LookatBuilder. The behavior will be directed toward the specified initial target position.
  *
  * @param {THREE.Vector3|number[]} target - The target position (in world-space) towards which the behavior will be directed.
  * @return {LookatInstance}
  */
	startLookat: function startLookat(target) {},

	/**
  * Function signature for lookat builder event listeners, for use with LookatBuilder's [on]{@link LookatBuilder#on} method.
  * @callback LookatBuilder~LookatEventCallback
  * @param {module:jibo/animate.LookatEventType} eventName - The event type.
  * @param {LookatInstance} lookatInstance - Lookat instance that generated this event.
  */

	/**
  * Registers an event listener.
  * @param {module:jibo/animate.LookatEventType} eventName - The event type to listen for.
  * @param {LookatBuilder~LookatEventCallback} callback - The listener function.
  * @memberof LookatBuilder#
  */
	on: function on(eventName, callback) {},

	/**
  * Un-registers an event listener.
  * @param {module:jibo/animate.LookatEventType} eventName - The event type.
  * @param {LookatBuilder~LookatEventCallback} callback - The listener function.
  */
	off: function off(eventName, callback) {},

	/**
  * Sets the DOFs to be used in the lookat/orient behavior.
  *
  * Commonly-used DOF groups are defined in [animate.dofs]{@link module:jibo/animate.dofs}.
  *
  * @param {DOFSet|string[]} dofNames - Names of DOFs to use; null to use all DOFs.
  */
	setDOFs: function setDOFs(dofNames) {},

	/**
  * Gets the DOFs currently specified for this builder.
  *
  * @return {string[]}
  */
	getDOFs: function getDOFs() {},

	/**
  * Sets the lookat behavior's base-blending policy.
  *
  * This policy only has an effect if the behavior is configured to control the robot's base DOF.
  *
  * @param {boolean} orientFully If `true`, the behavior will seize exclusive control of
  * the robot's base DOF. If `false`, the behavior will blend additively with any ongoing animation or postural
  * offset on the base DOF.
  */
	setOrientFully: function setOrientFully(orientFully) {},

	/**
  * Turns continuous mode for the lookat behavior on or off.
  *
  * @param {boolean} isContinuous If `false`, the lookat behavior will stop when the target
  * is reached. If `true`, the lookat behavior will continue indefinitely, allowing the target to be modified
  * at any time via [updateTarget]{@link LookatInstance#updateTarget}.
  */
	setContinuousMode: function setContinuousMode(isContinuous) {}

	/* end interface definition:        */
	/* eslint-enable no-unused-vars */

};

var animate = {

	MODALITY_NAME: "MOTION",

	/**
  * Create an instance of the Animation Utilities API.
  * If both MotionTimeline and RobotInfo are provided, the instance will be fully initialized and ready for use.
  * Otherwise, the init() method must be used to complete initialization.
  *
  * @param {MotionTimeline} [timeline]
  * @param {RobotInfo} [robotInfo]
  * @return {AnimationUtilities}
  */
	createAnimationUtilities: function createAnimationUtilities(timeline, robotInfo) {
		var animationUtilities = new AnimationUtilities();
		if (timeline && robotInfo) {
			animationUtilities.init(timeline, robotInfo);
		}
		return animationUtilities;
	}

};

animate.trajectory = {

	/**
  * @private
  * @callback AnimationLoadedCallback
  * @param {AnnotatedMotion} motion - motion that was loaded
  */

	/**
  * @param {string} uri
  * @param {AnimationLoadedCallback} callback
  * @param {boolean} forceReload - optional, defaults to not forcing reload
  */
	getAnimation: function getAnimation(uri, callback, forceReload) {
		var result;
		if (!forceReload) {
			result = animationCache[uri];
		}

		if (result) {
			if (callback) {
				callback(new AnnotatedMotion(result.motion, result.events));
			}
		} else {
			animationLoader.load(uri, function () {
				var animResult = animationLoader.getResult();
				if (animResult.success) {
					animationCache[uri] = animResult;
					if (callback) {
						callback(new AnnotatedMotion(animResult.motion, animResult.events));
					}
				} else {
					slog.error("animation load failed, " + animResult.message + " with URL:\"" + uri + "\"");
					if (callback) {
						callback(null);
					}
				}
			});
		}
	},

	/**
  * Parse a pre-loaded (or pre-assembled) animation data structure.
  * The data object must match the structure specified for on-disk animation files.
  *
  * @param {Object} animationData - the animation data object
  * @param {string} [parentDirectoryURI] - optional; if present, texture paths will be resolved relative to the specified directory
  * @param {string} [cacheKey] - optional; if present, results will be cached using the specified key
  *
  * @return {AnnotatedMotion} - the resulting motion instance, or null if parse failed
  */
	parseAnimation: function parseAnimation(animationData, parentDirectoryURI, cacheKey) {
		var result = null;
		if (cacheKey) {
			result = animationCache[cacheKey];
		}

		if (result) {
			return new AnnotatedMotion(result.motion, result.events);
		} else {
			var loader = new AnimationLoader();
			if (parentDirectoryURI) {
				var lastChar = parentDirectoryURI.slice(-1);
				if (!(lastChar === "/" || lastChar === "\\")) {
					parentDirectoryURI = parentDirectoryURI + "/";
				}
				loader.resolvePaths = true;
			} else {
				loader.resolvePaths = false;
			}

			loader.parseData(animationData, parentDirectoryURI);
			var animResult = loader.getResult();
			if (animResult.success) {
				if (cacheKey) {
					animationCache[cacheKey] = animResult;
				}
				return new AnnotatedMotion(animResult.motion, animResult.events);
			} else {
				slog.error("animation parse failed: " + animResult.message);
				return null;
			}
		}
	},

	/**
  * @param {RobotInfo} robotInfo
  * @return {LinearTransitionBuilder}
  */
	createLinearTransitionBuilder: function createLinearTransitionBuilder(robotInfo) {
		return new LinearTransitionBuilder(robotInfo);
	},

	/**
  * @param {RobotInfo} robotInfo
  * @param {number} defaultMaxVelocity
  * @param {number} defaultMaxAcceleration
  * @return {AccelerationTransitionBuilder}
  */
	createAccelerationTransitionBuilder: function createAccelerationTransitionBuilder(robotInfo, defaultMaxVelocity, defaultMaxAcceleration) {
		return new AccelerationTransitionBuilder(robotInfo, defaultMaxVelocity, defaultMaxAcceleration);
	}
};

/**
 * Enum Values for animation builder event types, for use with AnimationBuilder's [on]{@link AnimationBuilder#on} method.
 * @enum {string}
 * @memberof module:jibo/animate
 */
var AnimationEventType = {
	/**
  * Animation started.
  */
	STARTED: "STARTED",
	/**
  * Animation stopped or interrupted; check event payload's 'interrupted' property (boolean).
  */
	STOPPED: "STOPPED", //check interrupted boolean description property
	/**
  * Animation cancelled before starting.
  */
	CANCELLED: "CANCELLED", //will not start
	/**
  * Custom animation event fired.
  */
	EVENT: "EVENT" //custom event
};

animate.AnimationEventType = AnimationEventType;

/**
 * Enum Values for lookat builder event types, for use with LookatBuilder's [on]{@link LookatBuilder#on} method.
 * @enum {string}
 * @memberof module:jibo/animate
 */
var LookatEventType = {
	/**
  * Lookat started.
  */
	STARTED: "STARTED",
	/**
  * Lookat target reached.
  */
	TARGET_REACHED: "TARGET_REACHED", //reported when look has reached target
	/**
  * Lookat target superseded.
  */
	TARGET_SUPERSEDED: "TARGET_SUPERSEDED", //reported when look given new target before reaching previous
	/**
  * Lookat stopped or interrupted; check event payload's 'interrupted' property (boolean).
  */
	STOPPED: "STOPPED",
	/**
  * Lookat cancelled before starting.
  */
	CANCELLED: "CANCELLED" //will not start
};

animate.LookatEventType = LookatEventType;

module.exports = animate;
//# sourceMappingURL=../map/animation-animate/AnimateImpl.js.map
