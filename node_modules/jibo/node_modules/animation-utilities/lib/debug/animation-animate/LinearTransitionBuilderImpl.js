/**
 * @author jg
 */

"use strict";

var Motion = require("../ifr-motion/base/Motion");
var MotionValidator = require("../ifr-motion/base/MotionValidator");
var MotionTrack = require("../ifr-motion/base/MotionTrack");
var TimestampedBuffer = require("../ifr-motion/base/TimestampedBuffer");
var TransitionBuilder = require("./TransitionBuilder");

/**
 * Protected constructor for internal use only.
 *
 * LinearTransitionBuilders generate transition motions via simple linear blending.
 *
 * LinearTransitionBuilders can be created via the animation module's
 * [createLinearTransitionBuilder]{@link module:jibo/animate#createLinearTransitionBuilder} method.
 *
 * @param {RobotInfo} robotInfo - Protected constructor parameter.
 * @constructor
 * @extends TransitionBuilder
 * @protected
 */
var LinearTransitionBuilder = function LinearTransitionBuilder(robotInfo) {
	TransitionBuilder.call(this);
	/** @type {number} */
	/** @private */
	this._transitionTime = 1;

	/** @type {number} */
	/** @private */
	this._defaultMaxVelocity = null;

	/** @type {Object<string,number>} */
	/** @private */
	this._maxVelocityByDOF = null;

	/** @type {RobotInfo} */
	/** @private */
	this._robotInfo = robotInfo;
};

LinearTransitionBuilder.prototype = Object.create(TransitionBuilder.prototype);
LinearTransitionBuilder.prototype.constructor = LinearTransitionBuilder;

/**
 * Sets this transition to use a fixed duration transition regardless of joint positions.
 *
 * Overrides previous settings from setTransitionTime or setMaxVelocity.
 *
 * @param {number} time - Fixed transition time.
 */
LinearTransitionBuilder.prototype.setTransitionTime = function (time) {
	this._transitionTime = time;
	this._defaultMaxVelocity = null;
	this._maxVelocityByDOF = null;
};

/**
 * Sets this transition to compute time based on the distance to travel and max velocity
 * of the joints.
 *
 * Overrides previous settings from setTransitionTime or setMaxVelocity.
 *
 * @param {number} defaultMaxVelocity - Use this velocity for all joints not in the map.
 * @param {Object<string,number>} maxVelocityByDOFMap - Override default for joints present in the map.
 */
LinearTransitionBuilder.prototype.setMaxVelocity = function (defaultMaxVelocity, maxVelocityByDOFMap) {
	this._defaultMaxVelocity = defaultMaxVelocity;
	this._maxVelocityByDOF = maxVelocityByDOFMap;
	this._transitionTime = null;
};

/**
 *
 * @param {Pose} fromPose
 * @param {Motion} toMotion
 * @param {number} timeOffsetInTo
 * @param {string[]} onDOFs
 *
 * @return {Motion}
 * @override
 */
LinearTransitionBuilder.prototype.generateTransition = function (fromPose, toMotion, timeOffsetInTo, onDOFs) {
	var dofName, valueFrom, valueTo, di;

	//check validity
	for (di = 0; di < onDOFs.length; di++) {
		dofName = onDOFs[di];
		if (!this._robotInfo.getDOFInfo(dofName)) {
			throw new Error("Error transitioning, no dofInfo found for " + dofName);
		}
		//if(!toMotion.getTracks()[dofName]){
		//	throw new Error("Error transitioning, no TO value for "+dofName);
		//}
		var fromVar = fromPose.get(dofName, 0);
		if (fromVar == null || Array.isArray(fromVar) && fromVar.length < 1) {
			//null or undefined (eqnull)
			throw new Error("Error transitioning, no FROM value for " + dofName);
		}
	}
	MotionValidator.valuesExist(toMotion, onDOFs);

	var interpolatorSet = this._robotInfo.getKinematicInfo().getInterpolatorSet();

	var transition = new Motion("Transition:" + toMotion.getName());
	var duration = 0;

	var toPose = toMotion.getPoseAtTime(timeOffsetInTo, interpolatorSet);

	var dga = this._robotInfo.getKinematicInfo().getDOFGlobalAlignment();
	dga.refineToGloballyClosestTargetPose(fromPose, toPose, onDOFs);

	if (this._transitionTime !== null) {
		//fixed time is selected
		duration = this._transitionTime;
	} else {
		//var slowestJoint;
		//var slowestJointDistance;
		//velocity mode is selected, generate time based on distance to travel and selected velocity
		for (di = 0; di < onDOFs.length; di++) {
			dofName = onDOFs[di];
			if (this._robotInfo.getDOFInfo(dofName).isMetric()) {
				//non-metric cannot have a velocity
				valueFrom = fromPose.get(dofName, 0);
				valueTo = toPose.get(dofName, 0);
				var velocity = this._defaultMaxVelocity;
				if (this._maxVelocityByDOF && this._maxVelocityByDOF[dofName]) {
					//this dof has a custom velocity selected
					velocity = this._maxVelocityByDOF[dofName];
				}
				var distance = Math.abs(valueTo - valueFrom);
				var myTime = distance / velocity;
				if (myTime > duration) {
					duration = myTime;
					//slowestJoint = dofName;
					//slowestJointDistance = distance;
				}
			}
		}
		//console.log("LinearTransitionBuilder: DOF:"+slowestJoint+" drove a transition time of "+duration+" for distance "+slowestJointDistance);
	}
	for (di = 0; di < onDOFs.length; di++) {
		dofName = onDOFs[di];
		valueFrom = fromPose.get(dofName);
		valueTo = toPose.get(dofName, 0);
		var dataNew = new TimestampedBuffer();
		dataNew.append(0, valueFrom);
		dataNew.append(duration, valueTo);
		transition.addTrack(new MotionTrack(dofName, dataNew, duration));
	}
	return transition;
};

/**
 * @return {LinearTransitionBuilder}
 * @override
 */
LinearTransitionBuilder.prototype.clone = function () {
	var t = new LinearTransitionBuilder(this._robotInfo);

	//shallow copy all primary fields.
	var keys = Object.keys(this);
	for (var i = 0; i < keys.length; i++) {
		t[keys[i]] = this[keys[i]];
	}
	return t;
};

module.exports = LinearTransitionBuilder;
//# sourceMappingURL=../map/animation-animate/LinearTransitionBuilderImpl.js.map
