/**
 * @author jg
 */

"use strict";

var MotionLookat = require("../ifr-motion/lookat/MotionLookat");
var LookatNode = require("../ifr-motion/lookat/LookatNode");
var LookatMotionNode = require("../ifr-motion/lookat/LookatMotionNode");
var RotationalLookatDOF = require("../ifr-motion/lookat/RotationalLookatDOF");
var RotationalPlaneAlignmentLookatDOF = require("../ifr-motion/lookat/RotationalPlaneAlignmentLookatDOF");
var PlaneDisplacementLookatDOF = require("../ifr-motion/lookat/PlaneDisplacementLookatDOF");
var Pose = require("../ifr-motion/base/Pose");
var Motion = require("../ifr-motion/base/Motion");
var THREE = require("three");
var SimpleMotionGenerator = require("./timeline/SimpleMotionGenerator");
var slog = require("../ifr-core/SLog");
var LookatMultiLayerStatusManager = require("./timeline/LookatMultiLayerStatusManager");
var DOFSet = require("../geometry-info/DOFSet");
var LookatNodeTrackPolicy = require("../ifr-motion/lookat/trackpolicy/LookatNodeTrackPolicy");
var TrackPolicyTriggerAlways = require("../ifr-motion/lookat/trackpolicy/TrackPolicyTriggerAlways");
var TrackPolicyTriggerDiscomfort = require("../ifr-motion/lookat/trackpolicy/TrackPolicyTriggerDiscomfort");
var TrackPolicyTriggerMovementTerminated = require("../ifr-motion/lookat/trackpolicy/TrackPolicyTriggerMovementTerminated");

var channel = "LOOKAT";

/**
 * @callback LookatEventCallback
 * @param {string} eventName
 * @param {LookatInstance} lookatInstance - lookat instance that generated this event
 * @private
 */

/**
 * Enum Values for lookat builder event types.
 * @enum {string}
 * @private
 */
var LookatEventType = { //TODO: reference these (from where?) instead of recreating them here?
	STARTED: "STARTED",
	TARGET_REACHED: "TARGET_REACHED", //reported when look has reached target
	TARGET_SUPERSEDED: "TARGET_SUPERSEDED", //reported when look given new target before reaching previous

	/**
  * reported when look stops; check interrupted boolean description property
  * (interrupted is true if look stopped without reaching target)
  */
	STOPPED: "STOPPED",
	CANCELLED: "CANCELLED" //will not start
};

/**
 * @param {number} acceleration
 * @param {number} velocity
 * @param {number} [TPTDLimitInner]
 * @param {number} [TPTDLimitOuter]
 * @param {number} [TPTDAccumInner]
 * @param {number} [TPTDAccumOuter]
 * @param {boolean} [TPTDMoveImmediatelyPastOuter]
 * @param {number} [TPTMTDeadZone]
 * @param {number} [TPTMTDeadTime]
 * @constructor
 */
var LookatNodeRuntimeConfig = function LookatNodeRuntimeConfig(velocity, acceleration, TPTDLimitInner, TPTDLimitOuter, TPTDAccumInner, TPTDAccumOuter, TPTDMoveImmediatelyPastOuter, TPTMTDeadZone, TPTMTDeadTime) {
	/** @type {number} */
	this.velocity = velocity;
	/** @type {number} */
	this.acceleration = acceleration;
	/** @type {number} */
	this.TPTDLimitInner = TPTDLimitInner;
	/** @type {number} */
	this.TPTDLimitOuter = TPTDLimitOuter;
	/** @type {number} */
	this.TPTDAccumInner = TPTDAccumInner;
	/** @type {number} */
	this.TPTDAccumOuter = TPTDAccumOuter;
	/** @type {boolean} */
	this.TPTDMoveImmediatelyPastOuter = TPTDMoveImmediatelyPastOuter;

	/** @type {number} */
	this.TPTMTDeadZone = TPTMTDeadZone;
	/** @type {number} */
	this.TPTMTDeadTime = TPTMTDeadTime;
};

/**
 * @param {number} min
 * @param {number} max
 * @constructor
 */
var LookatDOFRuntimeConfig = function LookatDOFRuntimeConfig(min, max) {
	/** @type {number} */
	this.min = min;
	/** @type {number} */
	this.max = max;
};

/**
 *
 * @param {MotionTimeline} timeline
 * @param {RobotInfo} robotInfo
 * @param {TransitionBuilder} transition
 * @constructor
 * @private
 */
var SingleLookatBuilder = function SingleLookatBuilder(timeline, robotInfo, transition) {
	// eslint-disable-line no-unused-vars

	var self = this;

	/** @type {Object.<string,LookatNodeRuntimeConfig>} */
	var lookatNodeRuntimeConfigs = {
		//BaseLookatNode:new LookatNodeRuntimeConfig(null, 3, 0.1, 0.9, 0.2, 3, true, 0.1, 0.05),
		BaseLookatNode: new LookatNodeRuntimeConfig(null, 3),
		TorsoLookatNode: new LookatNodeRuntimeConfig(null, 3),
		TopLookatNode: new LookatNodeRuntimeConfig(null, 3),
		Eye: new LookatNodeRuntimeConfig(null, 1)
	};

	/** @type {Object.<string,LookatDOFRuntimeConfig>} */
	var lookatDOFRuntimeConfigs = {
		bottomSection_r: new LookatDOFRuntimeConfig(null, null),
		middleSection_r: new LookatDOFRuntimeConfig(null, null),
		topSection_r: new LookatDOFRuntimeConfig(null, null),
		eyeSubRootBn_t: new LookatDOFRuntimeConfig(-0.0364357400, 0.0364357400),
		eyeSubRootBn_t_2: new LookatDOFRuntimeConfig(-0.0080087240, 0.0080087240)
	};

	/**
  *
  * @param {LookatNodeRuntimeConfig} config
  */
	var getTrackPolicy = function getTrackPolicy(config) {
		if (config.TPTDLimitInner != null) {
			//assume all present if any present
			return new LookatNodeTrackPolicy([new TrackPolicyTriggerDiscomfort(config.TPTDLimitInner, config.TPTDLimitOuter, config.TPTDAccumInner, config.TPTDAccumOuter, config.TPTDMoveImmediatelyPastOuter), new TrackPolicyTriggerMovementTerminated(config.TPTMTDeadZone, config.TPTMTDeadTime)]);
		} else {
			return new LookatNodeTrackPolicy([new TrackPolicyTriggerAlways()]);
		}
	};

	/**
  * @return {MotionLookat}
  */
	var initLookat = function initLookat() {
		/** @type {KinematicGroup} */
		var kinematicGroupProto = robotInfo.getKinematicInfo().getFullKinematicGroup();

		return new MotionLookat([new LookatMotionNode(new LookatNode("BaseLookatNode", [new RotationalLookatDOF("BaseLookatDOF", "bottomSection_r", new THREE.Vector3(0, 0, -1))]), robotInfo.getKinematicInfo().getDOFGlobalAlignment(), lookatNodeRuntimeConfigs["BaseLookatNode"].acceleration, LookatMotionNode.LookStabilizationMode.POINT_AUTO, getTrackPolicy(lookatNodeRuntimeConfigs["BaseLookatNode"])), new LookatMotionNode(new LookatNode("TorsoLookatNode", [new RotationalPlaneAlignmentLookatDOF("TorsoLookatDOF", "middleSection_r", new THREE.Vector3(9.509979E-9, 0.9271838, 0.37460676), 0.18703285, 0.29670632)]), robotInfo.getKinematicInfo().getDOFGlobalAlignment(), lookatNodeRuntimeConfigs["TorsoLookatNode"].acceleration, LookatMotionNode.LookStabilizationMode.POINT_AUTO, new getTrackPolicy(lookatNodeRuntimeConfigs["TorsoLookatNode"])), new LookatMotionNode(new LookatNode("TopLookatNode", [new RotationalLookatDOF("TopLookatDOF", "topSection_r", new THREE.Vector3(0, 0, -1))]), robotInfo.getKinematicInfo().getDOFGlobalAlignment(), lookatNodeRuntimeConfigs["TopLookatNode"].acceleration, LookatMotionNode.LookStabilizationMode.POINT_AUTO, getTrackPolicy(lookatNodeRuntimeConfigs["TopLookatNode"])), new LookatMotionNode(new LookatNode("Eye", [new PlaneDisplacementLookatDOF("EyeLeftRight", "eyeSubRootBn_t", "eyeRootBn", new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 1, 0), 20 / 100, lookatDOFRuntimeConfigs["eyeSubRootBn_t"].min, lookatDOFRuntimeConfigs["eyeSubRootBn_t"].max), new PlaneDisplacementLookatDOF("EyeUpDown", "eyeSubRootBn_t_2", "eyeRootBn", new THREE.Vector3(0, 0, 1), new THREE.Vector3(-1, 0, 0), 10 / 100, lookatDOFRuntimeConfigs["eyeSubRootBn_t_2"].min, lookatDOFRuntimeConfigs["eyeSubRootBn_t_2"].max)]), robotInfo.getKinematicInfo().getDOFGlobalAlignment(), lookatNodeRuntimeConfigs["Eye"].acceleration, LookatMotionNode.LookStabilizationMode.POINT_TARGET, getTrackPolicy(lookatNodeRuntimeConfigs["Eye"]))], kinematicGroupProto);
	};

	var shouldOrientFully = true;
	var continuous = false;

	/** @type {Object<LookatEventType,LookatEventCallback[]>} */
	var eventHandlers = {};

	/** @type {MotionLookat} */
	var lookat = initLookat();

	/** @type {Pose} */
	var lookPose = new Pose("LookPose", lookat.getDOFs());

	/**
  * @param {THREE.Vector3} target
  * @param {MotionLookat} lookat
  * @constructor
  * @private
  */
	var LookatInstance = function LookatInstance(target, lookat, multiTargetStatus) {
		target = target.clone(); //make sure we have a cached copy
		/** @type {LookatMotionGenerator} */
		var mainLayerClip = null;
		/** @type {LookatMotionGenerator} */
		var lookatLayerClip = null;
		/** @type {LookatMultiLayerStatusManager} */
		var statusManager = multiTargetStatus;

		this.getTarget = function () {
			return target;
		};

		/**
   * @param {THREE.Vector3|number[]} newTarget
   */
		this.updateTarget = function (newTarget) {
			if (Array.isArray(newTarget)) {
				target.set(newTarget[0], newTarget[1], newTarget[2]);
			} else {
				target.copy(newTarget);
			}
			statusManager.setTarget(target);
		};

		this.getBuilder = function () {
			return self;
		};

		this.setClip = function (useMainClip, useLookatClip) {
			mainLayerClip = useMainClip;
			lookatLayerClip = useLookatClip;
		};

		this.stop = function () {
			if (mainLayerClip) {
				stopClip(mainLayerClip, "default");
			}
			if (lookatLayerClip) {
				stopClip(lookatLayerClip, "lookat");
			}
		};

		/**
   * @param {MotionGenerator} clip
   * @param {string} layer
   */
		var stopClip = function stopClip(clip, layer) {
			//find the soonest time we have not yet committed to
			//TODO: this is sometimes overly conservative:
			// in some edge cases dofs still in the clips may not be using their whole commitment window
			var reactionTime = 0;
			//TODO: reactionTime
			//if(!clip.hasExited()){
			//	reactionTime = timeline.getReactionTime("MOTION", clip.getMotion());
			//}

			//this is the earliest we could stop for the related dofs (aside from conservative consideration above)
			/** @type {Time} */
			var stopTime = timeline.getClock().currentTime().add(reactionTime);

			//also, if all clips are fully committed, we will not stop
			if (stopTime.isGreater(clip.getEndTime())) {
				//stopTime is after clip is already over; cannot stop.  do nothing.
				if (clip.hasExited()) {
					slog.info("Ignoring stop on SingleLookat as it is already over");
				} else {
					slog.info("Ignoring stop on SingleLookat as it is already committed");
				}
				return;
			}

			//however we will not stop before any of the clips start!
			if (clip.getStartTime().isGreater(stopTime)) {
				stopTime = clip.getStartTime();
				slog.info("Stopping called on lookat before it started, moving stopTime forward");
			}

			/** @type {string[]} */
			var dofsToStop = [];

			/** @type {string[]} */
			var possibleDOFs = clip.getDOFs();

			var deltaToStopForClip = stopTime.subtract(clip.getStartTime());

			for (var i = 0; i < possibleDOFs.length; i++) {
				var durationForDOF = clip.getDurationForDOF(possibleDOFs[i]);
				if (durationForDOF !== null && durationForDOF > deltaToStopForClip) {
					dofsToStop.push(possibleDOFs[i]);
				}
			}

			//TODO: using zero-duration motion for now, might want to add explicit timeline stop() method

			/** @type {Pose} */
			var stopPose = new Pose("stop pose", dofsToStop);
			for (var d = 0; d < dofsToStop.length; d++) {
				stopPose.set(dofsToStop[d], [0]);
			}

			/** @type {Motion} */
			var stopMotion = Motion.createFromPose(clip.getName() + "_stop", stopPose, 0);
			var stopClip = new SimpleMotionGenerator(stopMotion, stopTime, robotInfo);
			timeline.add(stopClip, layer);
		};
	};

	/**
  * @param {THREE.Vector3|number[]} target
  * @return {LookatInstance}
  */
	this.startLookat = function (targetArg) {
		/** @type {THREE.Vector3} */
		var target = null;
		if (Array.isArray(targetArg)) {
			target = new THREE.Vector3(targetArg[0], targetArg[1], targetArg[2]);
		} else {
			target = targetArg;
		}

		//var delay = (delayLookatStart !== undefined) ? delayLookatStart : 0;
		//var reactionTime = timeline.getReactionTime(animate.MODALITY_NAME, m);
		//var reactionTime = timeline.getReactionTime("MOTION", m);
		//delay = Math.max(delay, reactionTime);
		var startTime = timeline.getClock().currentTime();

		lookat = initLookat();

		var lookatLayerPose = timeline.getCurrentState(["lookat"]).getPose();
		var defaultLayerDOFs = [];
		var lookatLayerDOFs = [];
		var allLookDOFs = lookPose.getDOFNames();
		for (var i = 0; i < allLookDOFs.length; i++) {
			if (lookatLayerPose.get(allLookDOFs[i]) !== null) {
				lookatLayerDOFs.push(allLookDOFs[i]);
			} else {
				defaultLayerDOFs.push(allLookDOFs[i]);
			}
		}

		var currentLayerState = timeline.getCurrentState(["default", "lookat"]);
		/** @type{Pose} */
		//var currentPose = timeline.getStateAtTime(animate.MODALITY_NAME, startTime);
		// transition from: the current "absolute" pose (combination of default and lookat layers)
		var currentPose = currentLayerState.getPose();
		/** @type{Time} */
		var currentPoseTime = currentLayerState.getTime();

		/** @type {MotionGenerator} */
		var timelineClip = null;
		///** @type {BaseMotionGenerator} */
		//var lookatStaticLayerClip;

		/** @type {LookatMultiLayerStatusManager} */
		var layersStatusManager = new LookatMultiLayerStatusManager(lookat, startTime, target, continuous);

		var preRender = false;

		if (preRender) {
			lookat.reset();
			//var startTime = Clock.currentTime();
			var time = startTime;
			var poses = [];
			var times = [];
			var remainingDistance = Number.MAX_VALUE;

			while (remainingDistance > 0.001) {
				slog(channel, "Creating lookat pose at time " + time.subtract(startTime) + " with remaining:" + remainingDistance);
				lookat.generatePose(currentPose, lookPose, target, time);
				remainingDistance = lookat.getDistanceRemaining();
				var p = new Pose("Pose " + time, lookPose.getDOFNames());
				p.setPose(lookPose);
				poses.push(p);
				times.push(time.subtract(startTime));
				currentPose.setPose(lookPose);
				time = time.add(1 / 30.0);
			}

			var lookRenderedMotion = Motion.createFromPoses("ToLook", poses, times, time.subtract(startTime));

			timelineClip = new SimpleMotionGenerator(lookRenderedMotion, startTime, robotInfo);

			//if (lookatLayerDOFs.length > 0) {
			//	var preRenderedLookatStaticLayerMotion = Motion.createFromPose("lookat target static", poses[poses.length - 1], lookRenderedMotion.getDuration(), lookatLayerDOFs);
			//	lookatStaticLayerClip = new SimpleMotionGenerator(preRenderedLookatStaticLayerMotion, startTime, robotInfo);
			//}
		} else {
				/////initialize the lookat with the current state///////
				lookat.reset();
				if (shouldOrientFully) {
					lookat.generatePose(currentPose, lookPose, target, currentPoseTime);
				} else {
					for (i = 0; i < lookatLayerDOFs.length; i++) {
						lookat.generatePoseIncremental(lookatLayerPose, lookPose, target, currentPoseTime, lookatLayerDOFs[i]);
					}
					for (i = 0; i < defaultLayerDOFs.length; i++) {
						lookat.generatePoseIncremental(currentPose, lookPose, target, currentPoseTime, defaultLayerDOFs[i]);
					}
				}
				/////////////////      done init        ////////////////

				timelineClip = layersStatusManager.createGenerator(defaultLayerDOFs);

				//if (lookatLayerDOFs.length > 0) {
				//	lookat.getOptimalPose(currentPose, lookPose, target);
				//	var activeLookatStaticLayerMotion = Motion.createFromPose("lookat target static", lookPose, Number.MAX_VALUE, lookatLayerDOFs);
				//	lookatStaticLayerClip = new SimpleMotionGenerator(activeLookatStaticLayerMotion, startTime, robotInfo);
				//}
			}

		/** @type {LookatInstance} */
		var lookatInstance = new LookatInstance(target, lookat, layersStatusManager);

		layersStatusManager.setHandlers(createStartedHandler(lookatInstance), createStoppedHandler(lookatInstance), createRemovedHandler(lookatInstance), createTargetReachedHandler(lookatInstance), createTargetSupersededHandler(lookatInstance));

		// add the full lookat transition to the default layer
		timelineClip = timeline.add(timelineClip, "default");

		var lookLayerGenerator = null;
		if (lookatLayerDOFs.length > 0) {
			// add the static target lookat pose to the lookat layer, for future additive blending
			//timeline.add(lookatStaticLayerClip, "lookat");

			if (shouldOrientFully) {
				var zeroMotion = Motion.createFromPose("zero motion", robotInfo.getKinematicInfo().getDefaultPose().getCopy(), 1.0, lookatLayerDOFs);
				timeline.add(new SimpleMotionGenerator(zeroMotion, startTime, robotInfo, lookatLayerDOFs), "default");
			}

			lookLayerGenerator = layersStatusManager.createGenerator(lookatLayerDOFs);
			timeline.add(lookLayerGenerator, "lookat");
		}

		lookatInstance.setClip(timelineClip, lookLayerGenerator);

		return lookatInstance;
	};

	/**
  * Register an event listener
  * @param {LookatEventType} eventName
  * @param {LookatEventCallback} callback
  */
	this.on = function (eventName, callback) {
		/** @type {LookatEventCallback[]} */
		var handlersForType = eventHandlers[eventName];
		if (!handlersForType) {
			handlersForType = [];
			eventHandlers[eventName] = handlersForType;
		}
		if (handlersForType.indexOf(callback) === -1) {
			handlersForType.push(callback);
		}
	};

	/**
  * Un-register an event listener
  * @param {LookatEventType} eventName
  * @param {LookatEventCallback} callback
  */
	this.off = function (eventName, callback) {
		/** @type {LookatEventCallback[]} */
		var handlersForType = eventHandlers[eventName];
		if (handlersForType) {
			var index = handlersForType.indexOf(callback);
			if (index !== -1) {
				handlersForType.splice(index, 1);
			}
		}
	};

	/**
  * Set the DOFs to be used in the look-at/orient behavior.
  *
  * Commonly-used dof groups are defined in [animate.dofs]{@link module:jibo/animate.dofs}.
  *
  * @param {DOFSet|string[]} dofNames - names of dofs to use, null for all dofs.
  */
	this.setDOFs = function (dofNames) {
		if (!dofNames) {
			dofNames = lookat.getDOFs();
		} else if (dofNames instanceof DOFSet) {
			dofNames = dofNames.getDOFs();
		}
		var validDOFs = lookat.getDOFs();
		var newDOFs = [];
		for (var i = 0; i < dofNames.length; i++) {
			if (validDOFs.indexOf(dofNames[i]) > -1) {
				newDOFs.push(dofNames[i]);
			}
		}
		lookPose = new Pose("LookPose", newDOFs);
	};

	/**
  * @return {string[]}
  */
	this.getDOFs = function () {
		return lookPose.getDOFNames().slice(0);
	};

	/**
  * @param {boolean} orientFully
  */
	this.setOrientFully = function (orientFully) {
		shouldOrientFully = orientFully;
	};

	/**
  * @param {boolean} isContinuous
  */
	this.setContinuousMode = function (isContinuous) {
		continuous = isContinuous;
	};

	/**
  * @param {TransitionBuilder} transition
  */
	this.setTransitionIn = function (newTransition) {
		//TODO: cache for instances?
		transition = newTransition;
	};

	/**
  * Get the config for a single lookat node.  Returned object is not a copy (subsequent modifications will affect this builder)
  * @param {string} nodeName
  * @return {LookatNodeRuntimeConfig}
  */
	this.getLookatNodeConfig = function (nodeName) {
		if (!lookatNodeRuntimeConfigs.hasOwnProperty(nodeName)) {
			throw new Error("Cannot get config for unknown node: " + nodeName + " (valid nodes:" + Object.keys(lookatNodeRuntimeConfigs) + ")");
		} else {
			return lookatNodeRuntimeConfigs[nodeName];
		}
	};

	/**
  * Set the config for a single lookat node.  Object is not a copied (subsequent modifications will affect this builder)
  * @param {string} nodeName
  * @param {LookatDOFRuntimeConfig} config
  */
	this.setLookatNodeConfig = function (nodeName, config) {
		if (!lookatNodeRuntimeConfigs.hasOwnProperty(nodeName)) {
			throw new Error("Cannot set config for unknown node: " + nodeName + " (valid nodes:" + Object.keys(lookatNodeRuntimeConfigs) + ")");
		} else {
			lookatNodeRuntimeConfigs[nodeName] = config;
		}
	};

	/**
  * Get the config for a single lookat dof.  Returned object is not a copy (subsequent modifications will affect this builder)
  * @param {string} dofName
  * @return {LookatDOFRuntimeConfig}
  */
	this.getLookatDOFConfig = function (dofName) {
		if (!lookatDOFRuntimeConfigs.hasOwnProperty(dofName)) {
			throw new Error("Cannot get config for unknown DOF: " + dofName + " (valid DOFS:" + Object.keys(lookatDOFRuntimeConfigs) + ")");
		} else {
			return lookatDOFRuntimeConfigs[dofName];
		}
	};

	/**
  * Set the config for a single lookat dof.  Object is not a copied (subsequent modifications will affect this builder)
  * @param {string} dofName
  * @param {LookatDOFRuntimeConfig} config
  */
	this.setLookatDOFConfig = function (dofName, config) {
		if (!lookatDOFRuntimeConfigs.hasOwnProperty(dofName)) {
			throw new Error("Cannot set config for unknown DOF: " + dofName + " (valid DOFS:" + Object.keys(lookatDOFRuntimeConfigs) + ")");
		} else {
			lookatDOFRuntimeConfigs[dofName] = config;
		}
	};

	//var createImmediateSuccessHandler = function(lookatInstance){
	//	var hStarted = eventHandlers[LookatEventType.STARTED];
	//	var hStopped = eventHandlers[LookatEventType.STOPPED];
	//	var hTargetReached = eventHandlers[LookatEventType.TARGET_REACHED];
	//	if(hStarted || hStopped || hTargetReached){
	//		var startHandlers = null;
	//		var targetReachedHandlers = null;
	//		var stopHandlers = null;
	//		var i;
	//		if(hStarted) {
	//			startHandlers = hStarted.slice(0);
	//		}
	//		if(hStopped) {
	//			stopHandlers = hStopped.slice(0);
	//		}
	//		if(hTargetReached) {
	//			targetReachedHandlers = hTargetReached.slice(0);
	//		}
	//
	//		return function() {
	//			if(startHandlers){
	//				for(i = 0; i < startHandlers.length; i++){
	//					startHandlers[i](LookatEventType.STARTED, lookatInstance, {});
	//				}
	//			}
	//			if(targetReachedHandlers){
	//				for(i = 0; i < targetReachedHandlers.length; i++){
	//					targetReachedHandlers[i](LookatEventType.TARGET_REACHED, lookatInstance, {});
	//				}
	//			}
	//			if(stopHandlers){
	//				for(i = 0; i < stopHandlers.length; i++){
	//					stopHandlers[i](LookatEventType.STOPPED, lookatInstance, {});
	//				}
	//			}
	//		};
	//	}
	//};

	//map between timeline events and lookat events
	var createStartedHandler = function createStartedHandler(lookatInstance) {
		var h = eventHandlers[LookatEventType.STARTED];
		if (h) {
			var startHandlers = h.slice(0);
			return function () {
				for (var i = 0; i < startHandlers.length; i++) {
					startHandlers[i](LookatEventType.STARTED, lookatInstance, {});
				}
			};
		} else {
			return null;
		}
	};

	var createTargetReachedHandler = function createTargetReachedHandler(lookatInstance) {
		var h = eventHandlers[LookatEventType.TARGET_REACHED];
		if (h) {
			var reachedHandlers = h.slice(0);
			return function (target) {
				for (var i = 0; i < reachedHandlers.length; i++) {
					reachedHandlers[i](LookatEventType.TARGET_REACHED, lookatInstance, { target: target });
				}
			};
		} else {
			return null;
		}
	};

	var createTargetSupersededHandler = function createTargetSupersededHandler(lookatInstance) {
		var h = eventHandlers[LookatEventType.TARGET_SUPERSEDED];
		if (h) {
			var supersededHandlers = h.slice(0);
			return function (target) {
				for (var i = 0; i < supersededHandlers.length; i++) {
					supersededHandlers[i](LookatEventType.TARGET_SUPERSEDED, lookatInstance, { target: target });
				}
			};
		} else {
			return null;
		}
	};

	//map between timeline events and lookat events
	var createStoppedHandler = function createStoppedHandler(lookatInstance) {
		var hStopped = eventHandlers[LookatEventType.STOPPED];
		if (hStopped) {
			var stopHandlers = null;
			if (hStopped) {
				stopHandlers = hStopped.slice(0);
			}
			return function (interrupted) {
				//for single shot lookat, we're interrupted if we didn't complete, just as an animation
				if (stopHandlers) {
					for (var i = 0; i < stopHandlers.length; i++) {
						stopHandlers[i](LookatEventType.STOPPED, lookatInstance, { interrupted: interrupted });
					}
				}
			};
		} else {
			return null;
		}
	};

	//map between timeline events and lookat events
	var createRemovedHandler = function createRemovedHandler(lookatInstance) {
		var hStopped = eventHandlers[LookatEventType.STOPPED];
		var hCancelled = eventHandlers[LookatEventType.CANCELLED];
		if (hStopped || hCancelled) {
			var stopHandlers = null;
			var cancelHandlers = null;
			if (hStopped) {
				stopHandlers = hStopped.slice(0);
			}
			if (hCancelled) {
				cancelHandlers = hCancelled.slice(0);
			}
			return function (started, stopped) {
				var i;
				if (stopHandlers) {
					if (started && !stopped) {
						//if a clip is removed after start and before stop, we'll send a stop (interrupted) to the listeners
						for (i = 0; i < stopHandlers.length; i++) {
							stopHandlers[i](LookatEventType.STOPPED, lookatInstance, { interrupted: true });
						}
					}
				}
				if (cancelHandlers) {
					if (!started) {
						//if it never started, then we'll send a cancel.
						for (i = 0; i < stopHandlers.length; i++) {
							cancelHandlers[i](LookatEventType.CANCELLED, lookatInstance, {});
						}
					}
				}
			};
		} else {
			return null;
		}
	};
};

module.exports = SingleLookatBuilder;
//# sourceMappingURL=../map/animation-animate/SingleLookatBuilder.js.map
