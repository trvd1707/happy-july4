/**
 * @author jg
 */

"use strict";

var MotionTrack = require("../../ifr-motion/base/MotionTrack");
var TimestampedBuffer = require("../../ifr-motion/base/TimestampedBuffer");
var Motion = require("../../ifr-motion/base/Motion");
var MotionTimelineLayerRenderer = require("./MotionTimelineLayerRenderer");
/**
 *
 * @param {SampleCombiner} sampleCombiner
 * @param {InterpolatorSet} interpolatorSet
 * @constructor
 * @extends MotionTimelineLayerRenderer
 */
var MotionTimelineSampledLayerRenderer = function MotionTimelineSampledLayerRenderer(sampleCombiner, interpolatorSet) {
	MotionTimelineLayerRenderer.call(this);
	/** @type {SampleCombiner} */
	this._sampleCombiner = sampleCombiner;
	/** @type {InterpolatorSet} */
	this._interpolatorSet = interpolatorSet;
};

MotionTimelineSampledLayerRenderer.prototype = Object.create(MotionTimelineLayerRenderer.prototype);
MotionTimelineSampledLayerRenderer.prototype.constructor = MotionTimelineSampledLayerRenderer;

/**
 * //TODO: clip anchored at startTime but outside data not clipped
 *
 * @param {MotionTimelineClip[]} layerData
 * @param {string} dofName
 * @param {Time} startTime
 * @param {Time} endTime
 * @param {number[]} leftVal
 * @param {BaseInterpolator} interpolator
 *
 * @return {TimestampedBuffer}
 */
var renderLayerForDOF = function renderLayerForDOF(layerData, dofName, startTime, endTime, leftVal, interpolator) {

	var previousVal = leftVal;
	var buffer = new TimestampedBuffer();

	for (var ci = 0; ci < layerData.length; ci++) {
		var clip = layerData[ci];
		if (clip.getDurationForDOF(dofName) === null) {
			continue;
		}
		var durationForDOF = clip.getDurationForDOF(dofName);
		var track = clip.getMotion().getTracks()[dofName];
		var trackData = track.getMotionData();
		var offsetForThisClip = clip.getStartTime().subtract(startTime);

		if (durationForDOF !== null) {
			var si = 0;

			//TODO: should we add a t=0 and t=durationForDOF sample?

			var usingStartTime = 0;
			{
				//add a sample at the start
				var sampleAtStart;
				if (trackData.getTimestamp(0) === usingStartTime) {
					//TODO: need to find the index (not zero necessarily) when we have start insets
					sampleAtStart = trackData.getData(0);
				} else {
					sampleAtStart = track.getDataAtTime(usingStartTime, interpolator);
				}
				buffer.append(offsetForThisClip, previousVal); //clamp previous to avoid unintended linear interpolation
				buffer.append(offsetForThisClip, sampleAtStart);
				previousVal = sampleAtStart;
			}

			while (si < trackData.size() && trackData.getTimestamp(si) <= durationForDOF) {
				var sampleTime = trackData.getTimestamp(si);

				if (sampleTime > usingStartTime) {
					//don't re-add the sample we added above as the start
					var sampleValue = trackData.getData(si);

					var ts = offsetForThisClip + sampleTime;

					//round to nearest microseconds.  clips that have an "identical" end to the next one's start
					//may have floating point error otherwise and be in the wrong order
					ts = Math.round(ts * 1000000) / 1000000;
					//if(si === 0){
					//	//add the left-side lead in value
					//	buffer.append(ts, previousVal);
					//}

					buffer.append(ts, sampleValue);
					previousVal = sampleValue;
				}
				si++;
			}

			{
				//and add a sample at the end if we didn't happen to hit it exactly
				var finalSampleTS = offsetForThisClip + durationForDOF;
				finalSampleTS = Math.round(finalSampleTS * 1000000) / 1000000;
				if (buffer.getTimestamp(buffer.size() - 1) < finalSampleTS) {
					var finalSample = track.getDataAtTime(durationForDOF, interpolator);
					buffer.append(finalSampleTS, finalSample);
					previousVal = finalSample;
				}
			}
		}
	}

	if (buffer.size() === 0) {
		buffer.append(0, previousVal);
	}

	return buffer;
};

/**
 *
 * @param {MotionTimelineClip[]} layerClips
 * @param {Pose} defaultPose
 * @param {Time} startTime
 * @param {Time} endTime
 * @param {Motion} motionSoFar
 * @return {Motion}
 * @override
 */
MotionTimelineSampledLayerRenderer.prototype.render = function (layerClips, defaultPose, startTime, endTime, motionSoFar) {

	var motion = new Motion("render");

	for (var di = 0; di < defaultPose.getDOFNames().length; di++) {
		var dofName = defaultPose.getDOFNames()[di];
		var leftVal = defaultPose.get(dofName);
		var interpolator = this._interpolatorSet.getInterpolator(dofName);
		var buffer = renderLayerForDOF(layerClips, dofName, startTime, endTime, leftVal, interpolator);
		var newMotionTrack = new MotionTrack(dofName, buffer, buffer.getEndTime());
		if (motionSoFar && motionSoFar.getTracks().hasOwnProperty(dofName)) {
			var trackSoFar = motionSoFar.getTracks()[dofName];
			var t1i = 0;
			var t2i = 0;
			var t1 = trackSoFar.getMotionData().getTimestamp(t1i);
			var t2 = buffer.getTimestamp(t2i);
			var combined = new TimestampedBuffer();
			while (t1 !== null || t2 !== null) {
				var t;
				if (t1 !== null && t2 !== null && t1 === t2) {
					t = t1;
					t1i++;
					t2i++;
				} else if (t2 === null || t1 !== null && t1 < t2) {
					t = t1;
					t1i++;
				} else if (t1 === null || t2 < t1) {
					t = t2;
					t2i++;
				} else {
					throw new Error("cannot happen");
				}
				if (t1i < trackSoFar.getMotionData().size()) {
					t1 = trackSoFar.getMotionData().getTimestamp(t1i);
				} else {
					t1 = null;
				}
				if (t2i < buffer.size()) {
					t2 = buffer.getTimestamp(t2i);
				} else {
					t2 = null;
				}
				combined.append(t, this._sampleCombiner.combineSamples(dofName, trackSoFar.getDataAtTime(t, interpolator), newMotionTrack.getDataAtTime(t, interpolator)));
			}
			motion.addTrack(new MotionTrack(dofName, combined, combined.getEndTime()));
		} else {
			motion.addTrack(newMotionTrack); //TODO: end time?
		}
	}

	if (motionSoFar !== null) {
		//pass through any tracks not addressed here
		var motionSoFarTrackNames = Object.keys(motionSoFar.getTracks());
		for (var ri = 0; ri < motionSoFarTrackNames.length; ri++) {
			if (!motion.getTracks().hasOwnProperty(motionSoFarTrackNames[ri])) {
				motion.addTrack(motionSoFar.getTracks()[motionSoFarTrackNames[ri]]);
			}
		}
	}

	return motion;
};

module.exports = MotionTimelineSampledLayerRenderer;
//# sourceMappingURL=../../map/animation-animate/timeline/MotionTimelineSampledLayerRenderer.js.map
