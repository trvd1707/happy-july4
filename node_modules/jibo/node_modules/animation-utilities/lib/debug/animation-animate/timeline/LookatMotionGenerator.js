/**
 * @author jg
 */

"use strict";

var BaseMotionGenerator = require("./BaseMotionGenerator");
var Pose = require("../../ifr-motion/base/Pose");
var slog = require("../../ifr-core/SLog");

var channel = "LOOKAT";

/**
 * @param {MotionLookat} motionLookat
 * @param {Time} startTime
 * @param {THREE.Vector3} target
 * @param {string[]} [onDOFs=null] - use only these dofs (all dofs of motionLookat used if omitted/null)
 * @param {LookatMultiLayerStatusManager} multiLayerLookatStatus - handle statekeeping here to allow for multiple generators per lookat
 * @constructor
 * @extends BaseMotionGenerator
 */
var LookatMotionGenerator = function LookatMotionGenerator(motionLookat, startTime, target, onDOFs, multiLayerLookatStatus) {
	var useDOFs;
	var fullLookatDOFs = motionLookat.getDOFs();
	if (onDOFs != null) {
		//null or undefined (eqnull)
		useDOFs = [];
		for (var i = 0; i < onDOFs.length; i++) {
			if (fullLookatDOFs.indexOf(onDOFs[i]) >= 0) {
				useDOFs.push(onDOFs[i]);
			} else {
				slog(channel, "Rejecting dof " + onDOFs[i] + " from lookat set as it is covered by no lookat nodes");
			}
		}
	} else {
		useDOFs = fullLookatDOFs;
	}

	BaseMotionGenerator.call(this, "SingleLookGenerator", startTime, useDOFs, Number.MAX_VALUE);

	/** @type {MotionLookat} */
	this._motionLookat = motionLookat; //TODO: we assume that motion lookat is reset and primed with current state

	/** @type {THREE.Vector3} */
	this._target = target.clone();

	/** @type {Pose} */
	this._generatedPose = new Pose("LMG generated pose", fullLookatDOFs);

	/**
  * pose frozen after particular dofs roll off the end
  * @type {Pose} */
	this._frozenPose = new Pose("LMG frozen pose", useDOFs);

	this._motionLookat.getPose(this._frozenPose);

	/** @type {LookatMultiLayerStatusManager} */
	this._multiLayerLookatStatus = multiLayerLookatStatus;
};

LookatMotionGenerator.prototype = Object.create(BaseMotionGenerator.prototype);
LookatMotionGenerator.prototype.constructor = LookatMotionGenerator;

/**
 *
 * @param {THREE.Vector3} target
 */
LookatMotionGenerator.prototype.setTarget = function (target) {
	this._target.copy(target);
};

/**
 *
 * @param {Time} currentTime
 * @override
 */
LookatMotionGenerator.prototype.notifyUpdateFinished = function (currentTime) {
	var shouldEndNow = this._multiLayerLookatStatus.handleUpdateFinishedForGenerator(this, currentTime);

	if (shouldEndNow) {
		this._targetDuration = currentTime.subtract(this._startTime);
		this.cropEnd(currentTime);
	}

	BaseMotionGenerator.prototype.notifyUpdateFinished.call(this, currentTime);
};

/**
 * @param {string} dofName
 * @param {LayerState} partialRender
 * @returns {number[]}
 * @override
 */
LookatMotionGenerator.prototype.getDOFState = function (dofName, partialRender) {
	/** @type {number} */
	var relativeCurrentTime = this._currentTime.subtract(this.getStartTime());
	/** @type {number} */
	var relativeEndTime = this.getDurationForDOF(dofName);

	var val = null;

	if (relativeEndTime !== null) {

		if (relativeCurrentTime < relativeEndTime) {
			this._motionLookat.generatePoseIncremental(partialRender.getPose(), this._generatedPose, this._target, this._currentTime, dofName);
			val = this._generatedPose.get(dofName);
			if (val !== null) {
				this._frozenPose.set(dofName, val);
			}
		} else {
			val = this._frozenPose.get(dofName);
		}
	}

	return val != null ? val.slice(0) : null;
};

module.exports = LookatMotionGenerator;
//# sourceMappingURL=../../map/animation-animate/timeline/LookatMotionGenerator.js.map
