/**
 * @author jg
 */

"use strict";

var slog = require("../../ifr-core/SLog");
var LookatMotionGenerator = require("./LookatMotionGenerator");

var channel = "LOOKAT";

/**
 * @param {LookatMotionGenerator} generator
 * @constructor
 */
var LayerStatus = function LayerStatus(generator) {
	this.generator = generator;
	this.layerHasStarted = false;
	this.layerHasStopped = false;
	this.layerHasRemoved = false;
};

/**
 *
 * @param {MotionLookat} lookat
 * @param {Time} startTime
 * @param {THREE.Vector3} target
 * @param {boolean} continuous
 * @constructor
 */
var LookatMultiLayerStatusManager = function LookatMultiLayerStatusManager(lookat, startTime, target, continuous) {

	/** @type {Map<LookatMotionGenerator,LayerStatus>} */
	this._layerStatuses = new Map();

	this._clipStartedHandler = null;
	this._clipStoppedHandler = null;
	this._clipRemovedHandler = null;
	this._targetReachedHandler = null;
	this._targetSupersededHandler = null;

	/** @type {THREE.Vector3} */
	this._waitingToNotifyOnTarget = null;

	/** @type {MotionLookat} */
	this._lookat = lookat;
	/** @type {Time} */
	this._startTime = startTime;
	/** @type {THREE.Vector3} */
	this._target = null;
	/** @type {boolean} */
	this._continuous = continuous;

	/** @type {boolean} */
	this._haveSentStart = false;

	this.setTarget(target);
};

/**
 * Create generator to render nodes on a particular layer with the provided dofs.
 *
 * @param {string[] }dofNames
 * @return {LookatMotionGenerator}
 */
LookatMultiLayerStatusManager.prototype.createGenerator = function (dofNames) {
	var gen = new LookatMotionGenerator(this._lookat, this._startTime, this._target, dofNames, this);
	this._layerStatuses.set(gen, new LayerStatus(gen));
	//set that generator's events to come back to us for filtering/passing on to eventual listeners
	gen.setHandlers(this.handleStarted.bind(this, gen), this.handleStopped.bind(this, gen), this.handleRemoved.bind(this, gen), null);
	return gen;
};

LookatMultiLayerStatusManager.prototype.setHandlers = function (clipStartedHandler, clipStoppedHandler, clipRemovedHandler, targetReachedHandler, targetSupersededHandler) {
	this._clipStartedHandler = clipStartedHandler;
	this._clipStoppedHandler = clipStoppedHandler;
	this._clipRemovedHandler = clipRemovedHandler;
	this._targetReachedHandler = targetReachedHandler;
	this._targetSupersededHandler = targetSupersededHandler;
};

/**
 *
 * @param {THREE.Vector3} newTarget
 */
LookatMultiLayerStatusManager.prototype.setTarget = function (newTarget) {
	var iter = this._layerStatuses.keys(); //removing for of for optimizer
	var nextVal;
	while (!(nextVal = iter.next()).done) {
		nextVal.value.setTarget(newTarget);
		//this._layerStatuses.get(gen)._targetReached = false;
	}
	if (this._waitingToNotifyOnTarget != null && this._targetSupersededHandler != null) {
		this._targetSupersededHandler(this._waitingToNotifyOnTarget);
	}
	this._waitingToNotifyOnTarget = newTarget.clone();
	this._target = this._waitingToNotifyOnTarget;
};

/**
 *
 * @param {LookatMotionGenerator} generator
 * @param {Time} currentTime
 * @return {boolean} true if generator should truncate to current time (end now naturally)
 */
LookatMultiLayerStatusManager.prototype.handleUpdateFinishedForGenerator = function (generator, currentTime) {
	/** @type {string[]} */
	var activeDOFs = this.getActiveDOFs(currentTime);
	/** @type {boolean} */
	var reachedTarget = activeDOFs.length > 0 && this._lookat.getDistanceRemaining(activeDOFs) < 0.001;

	if (reachedTarget && this._waitingToNotifyOnTarget != null) {
		//reachedTarget is actually a global state, across all layers.
		//so, we can safely notify now, don't need all layers to report this status
		if (this._targetReachedHandler != null) {
			this._targetReachedHandler(this._waitingToNotifyOnTarget);
		}
		this._waitingToNotifyOnTarget = null;
	}

	if (reachedTarget && !this._continuous) {
		return true;
	} else {
		return false;
	}
};

/**
 * Get the active dofs, across all generators.
 * @param {Time} time
 * @return {string[]} dofs active across all generators
 */
LookatMultiLayerStatusManager.prototype.getActiveDOFs = function (time) {
	/** @type{Set<string>} */
	var s = new Set();
	var iter = this._layerStatuses.keys(); //removing for of for optimizer
	var nextVal;
	while (!(nextVal = iter.next()).done) {
		var dofsInGen = nextVal.value.getActiveDOFs(time);
		for (var i = 0; i < dofsInGen.length; i++) {
			s.add(dofsInGen[i]);
		}
	}

	var dofs = [];
	var dofIter = s.keys();
	var nextDOF;
	while (!(nextDOF = dofIter.next()).done) {
		dofs.push(nextDOF.value);
	}
	return dofs;
};

/**
 * Called by each generator when they start.  We will pass through 1 started when
 * at least one has started and all have been either started or removed.
 */
LookatMultiLayerStatusManager.prototype.handleStarted = function (generator) {
	var genStatus = this._layerStatuses.get(generator);
	genStatus.layerHasStarted = true;
	if (this._clipStartedHandler) {
		var allStartedOrRemoved = true;
		for (var genStatusI of this._layerStatuses.values()) {
			if (!(genStatusI.layerHasStarted || genStatusI.layerHasRemoved)) {
				allStartedOrRemoved = false;
			}
		}
		if (allStartedOrRemoved) {
			this._clipStartedHandler();
			this._haveSentStart = true;
		}
	}
};

/**
 * Called by each generator when/if they stopped
 *
 * Each clip will be either removed exactly once and stopped at most once.  We will
 * pass through a single stop if it comes in on the last active (not stopped or removed) layer.
 *
 * @param {LookatMotionGenerator} generator - the generator sending this event
 * @param {boolean} interrupted
 */
LookatMultiLayerStatusManager.prototype.handleStopped = function (generator, interrupted) {
	var genStatus = this._layerStatuses.get(generator);
	if (genStatus.layerHasStopped) {
		slog(channel, "LookatMultiLayerStatManager: getting stop event for stopped layer " + generator);
	}
	genStatus.layerHasStopped = true;
	if (this._clipStoppedHandler) {
		var allFinished = true;
		for (var genStatusI of this._layerStatuses.values()) {
			if (!(genStatusI.layerHasStopped || genStatusI.layerHasRemoved)) {
				allFinished = false;
			}
		}
		if (allFinished) {
			this._clipStoppedHandler(interrupted);
		}
	}
};

/**
 * Called by each generator when/if they are removed.
 *
 * Each clip will be either removed exactly once and stopped at most once.  We will
 * pass through a single "remove" when all have been removed.
 *
 * @param {LookatMotionGenerator} generator - the generator sending this event
 * @param {boolean} started
 * @param {boolean} stopped
 */
LookatMultiLayerStatusManager.prototype.handleRemoved = function (generator, started, stopped) {
	var genStatus = this._layerStatuses.get(generator);
	genStatus.layerHasRemoved = true;
	var genStatusI = null;

	//check if we need to start, which could happen if one layer already started then a second layer
	//removes without starting
	if (!this._haveSentStart && this._clipStartedHandler) {
		//should send start if there will be no more starts and we have started at least once
		//all clips removed or started
		var noMoreStartsRemain = true;
		for (genStatusI of this._layerStatuses.values()) {
			if (!(genStatusI.layerHasRemoved || genStatusI.layerHasStarted)) {
				noMoreStartsRemain = false;
			}
		}
		if (noMoreStartsRemain) {
			this._clipRemovedHandler();
			this._haveSentStart = true;
		}
	}

	if (this._clipRemovedHandler) {
		var allRemoved = true;
		for (genStatusI of this._layerStatuses.values()) {
			if (!genStatusI.layerHasRemoved) {
				allRemoved = false;
			}
		}
		if (allRemoved) {
			this._clipRemovedHandler(started, stopped);
		}
	}
};

module.exports = LookatMultiLayerStatusManager;
//# sourceMappingURL=../../map/animation-animate/timeline/LookatMultiLayerStatusManager.js.map
