/**
 * @author mattb
 */

"use strict";

var MotionValidator = require("../../ifr-motion/base/MotionValidator");
var BaseMotionGenerator = require("./BaseMotionGenerator");
var TimelineEventDispatcher = require("./TimelineEventDispatcher");

/**
 * @param {Motion[]} motionList
 * @param {number} numLoops - number of times to loop through the motion list, 0 to loop forever
 * @param {Time} startTime
 * @param {RobotInfo} robotInfo
 * @param {string[]} [dofNames]
 * @constructor
 * @extends BaseMotionGenerator
 */
var LoopedMotionGenerator = function LoopedMotionGenerator(motionList, numLoops, startTime, robotInfo, dofNames) {
	if (!motionList) {
		throw new Error("tried to construct LoopedMotionGenerator with empty motion list");
	}
	if (numLoops < 0) {
		throw new Error("numLoops value is negative: " + numLoops);
	}

	if (!dofNames) {
		dofNames = Object.keys(motionList[0].getTracks());
	}

	// check that all of the motions in the list have all of the dofs
	var m, i, tracks;
	for (m = 0; m < motionList.length; m++) {
		tracks = motionList[m].getTracks();
		for (i = 0; i < dofNames.length; i++) {
			if (!tracks.hasOwnProperty(dofNames[i])) {
				throw new Error("LoopedMotionGenerator: motion " + m + " doesn't have a track for required DOF: " + dofNames[i]);
			}
		}
	}

	/** @type {number[]} */
	this._durationList = [];

	// calculate motion durations
	for (m = 0; m < motionList.length; m++) {
		var motionDuration = 0;
		for (i = 0; i < dofNames.length; i++) {
			var trackDuration = motionList[m].getTracks()[dofNames[i]].getLength();
			if (trackDuration > motionDuration) {
				motionDuration = trackDuration;
			}
		}
		this._durationList.push(motionDuration);
	}

	/** @type {number} */
	this._loopDuration = 0;
	for (m = 0; m < motionList.length; m++) {
		this._loopDuration = this._loopDuration + this._durationList[m];
	}

	var duration = 0;
	if (numLoops === 0) {
		// loop forever
		duration = Number.MAX_VALUE;
	} else {
		duration = this._loopDuration * numLoops;
	}

	BaseMotionGenerator.call(this, motionList[0].getName(), startTime, dofNames, duration);

	for (m = 0; m < motionList.length; m++) {
		MotionValidator.valuesExist(motionList[m]);
	}

	/** @type {Motion[]} */
	this._motionList = motionList;
	/** @type {number} */
	this._numLoops = numLoops;

	/** @type {number[]} */
	this._customEventTimes = [];
	/** @type {number} */
	this._eventLoopIndex = 0;
	/** @type {number} */
	this._eventIndex = 0;

	/** @type {InterpolatorSet} */
	this._interpolatorSet = robotInfo.getKinematicInfo().getInterpolatorSet();
};

LoopedMotionGenerator.prototype = Object.create(BaseMotionGenerator.prototype);
LoopedMotionGenerator.prototype.constructor = LoopedMotionGenerator;

/**
 * @param {MotionEvent[][]} motionEventsList
 * @override
 */
LoopedMotionGenerator.prototype.setEvents = function (motionEventsList) {
	if (motionEventsList.length !== this._motionList.length) {
		throw new Error("motionEventsList length " + motionEventsList.length + " doesn't match motionList length " + this._motionList.length);
	}

	var timeOffset = 0;
	for (var m = 0; m < this._motionList.length; m++) {
		var motionEvents = motionEventsList[m];
		for (var evi = 0; evi < motionEvents.length; evi++) {
			this._customEvents.push(motionEvents[evi]);
			this._customEventTimes.push(timeOffset + motionEvents[evi].getTimestamp());
		}
		timeOffset = timeOffset + this._durationList[m];
	}
};

/**
 * @param {string} dofName
 * @param {LayerState} partialRender
 * @returns {number[]}
 * @override
 */
LoopedMotionGenerator.prototype.getDOFState = function (dofName, partialRender) // eslint-disable-line no-unused-vars
{
	var relativeCurrentTime = this._currentTime.subtract(this.getStartTime());
	var relativeEndTime = this.getDurationForDOF(dofName);
	if (relativeEndTime !== null) {
		var sampleTime = Math.min(relativeCurrentTime, relativeEndTime);
		sampleTime = Math.max(sampleTime, 0);

		var loopIndex = Math.floor(sampleTime / this._loopDuration);
		if (this._numLoops !== 0) {
			loopIndex = Math.min(loopIndex, this._numLoops - 1);
		}

		var loopTime = sampleTime - this._loopDuration * loopIndex;

		var motionIndex = 0;
		var motionTime = loopTime;
		while (motionIndex < this._motionList.length - 1 && motionTime > this._durationList[motionIndex]) {
			motionTime = motionTime - this._durationList[motionIndex];
			motionIndex++;
		}

		var sample = this._motionList[motionIndex].getTracks()[dofName].getDataAtTime(motionTime, this._interpolatorSet.getInterpolator(dofName));

		return sample;
	} else {
		return null;
	}
};

/**
 * @override
 */
LoopedMotionGenerator.prototype.queueCustomEvents = function () {
	if (this.hasEntered() && !this.hasExited() && this._clipEventHandler) {
		var relativeCurrentTime = this._currentTime.subtract(this.getStartTime());
		var relativeEndTime = this.getDuration();

		var sampleTime = Math.min(relativeCurrentTime, relativeEndTime);
		sampleTime = Math.max(sampleTime, 0);

		var loopIndex = Math.floor(sampleTime / this._loopDuration);
		if (this._numLoops !== 0) {
			loopIndex = Math.min(loopIndex, this._numLoops - 1);
		}

		var loopTime = sampleTime - this._loopDuration * loopIndex;

		// iterate up through any loops we've completed
		while (this._eventLoopIndex < loopIndex) {
			while (this._eventIndex < this._customEvents.length) {
				TimelineEventDispatcher.queueEvent(this._clipEventHandler, [this._customEvents[this._eventIndex]]);
				this._eventIndex++;
			}

			this._eventLoopIndex++;
			this._eventIndex = 0;
		}

		// iterate up through loopTime for the current loop
		while (this._eventIndex < this._customEvents.length && this._customEventTimes[this._eventIndex] <= loopTime) {
			TimelineEventDispatcher.queueEvent(this._clipEventHandler, [this._customEvents[this._eventIndex]]);
			this._eventIndex++;
		}
	}
};

module.exports = LoopedMotionGenerator;
//# sourceMappingURL=../../map/animation-animate/timeline/LoopedMotionGenerator.js.map
