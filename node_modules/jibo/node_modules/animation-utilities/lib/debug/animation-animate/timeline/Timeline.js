/**
 * @author mattb
 */

"use strict";

var TimelineEventDispatcher = require("./TimelineEventDispatcher");

/**
 * Called when a clip's end is passed over by the current time.
 *
 * @callback ClipStartedHandler
 */

/**
 * Called when a clip's end is passed over by the current time.
 *
 * @callback ClipStoppedHandler
 * @param {boolean} interrupted - true if clip ended prematurely (its actual duration is less than than its underlying Motion)
 */

/**
 * Called when a clip is removed from the timeline.
 *
 * @callback ClipRemovedHandler
 * @param {boolean} didStart - true if the clip did start through timeline advancing
 * @param {boolean} didStop - true if the clip did stop through timeline advancing
 */

/**
 * Called when a custom clip event is passed over by the current time.
 *
 * @callback ClipEventHandler
 * @param {*} payload - custom event payload
 */

/**
 * @param {Clock} clock
 * @constructor
 */
var Timeline = function Timeline(clock) {
  /** @type {Clock} */
  this.clock = clock;
  /** @type {Object.<string, TimelineDelegate>} */
  this.delegates = {};
  /** @type {Time} */
  this.lastCullTime = null;
};

/**
 *
 * @param {string} modality
 * @param {TimelineDelegate} delegate
 */
Timeline.prototype.installModalityDelegate = function (modality, delegate) {
  this.delegates[modality] = delegate;
};

/**
 * @return {string[]}
 */
Timeline.prototype.getModalities = function () {
  return Object.keys(this.delegates);
};

/**
 * @param {string}modality
 *
 * @return {TimelineDelegate}
 */
Timeline.prototype.getModalityDelegate = function (modality) {
  return this.delegates[modality];
};

/**
 * @return {Clock}
 */
Timeline.prototype.getClock = function () {
  return this.clock;
};

/**
 *
 * @param {string} modality
 * @param {string} name
 * @param {Time} startTime
 * @param {*} payload
 * @param {string} layer
 * @param {ClipStartedHandler} clipStartedHandler
 * @param {ClipStoppedHandler} clipStoppedHandler
 * @param {ClipRemovedHandler} clipRemovedHandler
 * @param {ClipEventHandler} clipEventHandler
 *
 * @return {TimelineClip}
 */
Timeline.prototype.add = function (modality, name, startTime, payload, layer, clipStartedHandler, clipStoppedHandler, clipRemovedHandler, clipEventHandler) {
  return this.delegates[modality].add(name, startTime, payload, layer, clipStartedHandler, clipStoppedHandler, clipRemovedHandler, clipEventHandler);
};

/**
 *
 * @param {string} modality
 * @param {Time} startTime
 * @param {Time} endTime
 *
 * @return {TimelineClip[]}
 */
Timeline.prototype.getClipsInInterval = function (modality, startTime, endTime) {
  return this.delegates[modality].getClipsInInterval(startTime, endTime);
};

/**
 *
 * @param {string} modality
 * @param {Time} time
 *
 * @return {*}
 */
Timeline.prototype.getStateAtTime = function (modality, time) {
  return this.delegates[modality].getStateAtTime(time);
};

/**
 *
 * @param {string} modality
 * @param {*} payload
 *
 * @return {number}
 */
Timeline.prototype.getReactionTime = function (modality, payload) {
  return this.delegates[modality].getReactionTime(payload);
};

/**
 * Must be called frequently.  Dispatches events and
 * culls old data.
 */
Timeline.prototype.update = function () {
  var modalities = this.getModalities();
  var i;
  for (i = 0; i < modalities.length; i++) {
    this.delegates[modalities[i]].update();
  }

  var currentTime = this.clock.currentTime();

  if (!this.lastCullTime) {
    this.lastCullTime = currentTime;
  }

  if (currentTime.subtract(this.lastCullTime) > 5) {
    for (i = 0; i < modalities.length; i++) {
      this.delegates[modalities[i]].cullUpToTime(currentTime.add(-2));
    }
    this.lastCullTime = currentTime;
  }

  TimelineEventDispatcher.dispatchQueuedEvents();
};

module.exports = Timeline;
//# sourceMappingURL=../../map/animation-animate/timeline/Timeline.js.map
