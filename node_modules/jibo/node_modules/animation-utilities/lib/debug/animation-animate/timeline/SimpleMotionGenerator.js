/**
 * @author mattb
 */

"use strict";

var MotionValidator = require("../../ifr-motion/base/MotionValidator");
var BaseMotionGenerator = require("./BaseMotionGenerator");

/**
 * @param {Motion} motion
 * @param {Time} startTime
 * @param {RobotInfo} robotInfo
 * @param {string[]} [dofNames]
 * @constructor
 * @extends BaseMotionGenerator
 */
var SimpleMotionGenerator = function SimpleMotionGenerator(motion, startTime, robotInfo, dofNames) {
	if (!dofNames) {
		dofNames = Object.keys(motion.getTracks());
	}

	var duration = 0;
	for (var i = 0; i < dofNames.length; i++) {
		var trackDuration = motion.getTracks()[dofNames[i]].getLength();
		if (trackDuration > duration) {
			duration = trackDuration;
		}
	}

	BaseMotionGenerator.call(this, motion.getName(), startTime, dofNames, duration);

	MotionValidator.valuesExist(motion);

	/** @type {Motion} */
	this._motion = motion;

	/** @type {InterpolatorSet} */
	this._interpolatorSet = robotInfo.getKinematicInfo().getInterpolatorSet();
};

SimpleMotionGenerator.prototype = Object.create(BaseMotionGenerator.prototype);
SimpleMotionGenerator.prototype.constructor = SimpleMotionGenerator;

/**
 * @param {string} dofName
 * @param {LayerState} partialRender
 * @returns {number[]}
 * @override
 */
SimpleMotionGenerator.prototype.getDOFState = function (dofName, partialRender) // eslint-disable-line no-unused-vars
{
	var relativeCurrentTime = this._currentTime.subtract(this.getStartTime());
	var relativeEndTime = this.getDurationForDOF(dofName);
	if (relativeEndTime !== null) {
		var sampleTime = Math.min(relativeCurrentTime, relativeEndTime);
		var sample = this._motion.getTracks()[dofName].getDataAtTime(sampleTime, this._interpolatorSet.getInterpolator(dofName));

		return sample;
	} else {
		return null;
	}
};

module.exports = SimpleMotionGenerator;
//# sourceMappingURL=../../map/animation-animate/timeline/SimpleMotionGenerator.js.map
