/**
 * @author jg, mattb
 */

"use strict";

var Pose = require("../../ifr-motion/base/Pose");
var DOFGlobalAlignment = require("../../ifr-motion/base/DOFGlobalAlignment");
var CyclicMath = require("../../ifr-motion/base/CyclicMath");
var slog = require("../../ifr-core/SLog");
var TimelineEventDispatcher = require("./TimelineEventDispatcher");
var LayerState = require("./LayerState");

/**
 * @param {string} name
 * @param {RobotInfo} robotInfo
 * @param {Clock} clock
 * @param {LayerCombiner} layerCombiner
 * @param {string} modalityName
 *
 * @constructor
 */
var MotionTimeline = function MotionTimeline(name, robotInfo, clock, layerCombiner, modalityName) {
	/** @type {string} */
	this._name = name;

	/** @type {Object<string,MotionGenerator[]>} */
	this._layers = {};

	/** @type {string[]} */
	this._layerNames = [];

	/** @type {RobotInfo} */
	this._robotInfo = robotInfo;

	/** @type {string[]} */
	this._dofNames = robotInfo.getDOFNames();

	/**
  * current state for each layer
  * @type {object.<string,LayerState>}*/
	this._layerStates = {};
	/**
  * previous state for each layer
  * @type {object.<string,LayerState>}*/
	this._previousLayerStates = {};

	/**
  * full combined system state
  * @type {LayerState} */
	this._systemState = new LayerState(clock.currentTime(), robotInfo.getKinematicInfo().getDefaultPose().getCopy());
	/**
  * previous combined system state
  * @type {LayerState}*/
	this._previousSystemState = this._systemState.getCopy();

	/** @type {Array.<*>} */
	this._outputs = [];

	/** @type {Clock} */
	this._clock = clock;

	/** @type {LayerCombiner} */
	this._layerCombiner = layerCombiner;

	/** @type {string} */
	this._modalityName = modalityName;

	/** @type {DOFGlobalAlignment} */
	this._dofAlignment = new DOFGlobalAlignment(this._robotInfo.getKinematicInfo().getFullKinematicGroup(), null);

	/** @type {string[]} */
	this._sortedDOFNames = this._dofNames.slice(0);
	this._sortedDOFNames = this._dofAlignment.sortDOFsByDepth(this._sortedDOFNames);

	/** @type {Object<string, Object<string, string>>} */
	this._dofMapByLayer = {};

	/** @type {number} */
	this._minimumUpdateDelay = 0.01;
};

/**
 * @param {string} modality
 *
 * @return {MotionTimeline}
 */
MotionTimeline.prototype.getModalityDelegate = function (modality) {
	if (modality === this._modalityName) {
		return this;
	} else {
		return null;
	}
};

/**
 * @return {Clock}
 */
MotionTimeline.prototype.getClock = function () {
	return this._clock;
};

/**
 * @return {string}
 */
MotionTimeline.prototype.getName = function () {
	return this._name;
};

/**
 * @param {string} layerName
 * @param {string[]} [dofs]
 */
MotionTimeline.prototype.createLayer = function (layerName, dofs) {
	if (!this._layers.hasOwnProperty(layerName)) {
		if (dofs == null) {
			//null or undefined (eqnull)
			dofs = this._dofNames;
		}

		this._layers[layerName] = [];
		this._layerNames.push(layerName);

		var initialPose = this._robotInfo.getKinematicInfo().getDefaultPose();
		var pose = new Pose(layerName + "_pose", dofs.slice(0));
		pose.setPose(initialPose);

		this._layerStates[layerName] = new LayerState(this._clock.currentTime(), pose);
		this._previousLayerStates[layerName] = this._layerStates[layerName].getCopy();

		this._dofMapByLayer[layerName] = {};
		for (var i = 0; i < dofs.length; i++) {
			var dofName = dofs[i];
			this._dofMapByLayer[layerName][dofName] = dofName;
		}
	} else {
		slog.error("Not creating Timeline layer " + layerName + " since we already have one!");
	}
};

/**
 * @return {Array.<string>}
 */
MotionTimeline.prototype.getLayerNames = function () {
	return this._layerNames.slice(0);
};

/**
 * @return {LayerCombiner}
 */
MotionTimeline.prototype.getLayerCombiner = function () {
	return this._layerCombiner;
};

/**
 * get the current combined state for the timeline.
 * the state will combine all layers by default, or optionally just a
 * specified subset of layers.
 * @param {string[]} [layerNames] - the subset of layers to combine (defaults to all layers)
 * @return {LayerState}
 */
MotionTimeline.prototype.getCurrentState = function (layerNames) {
	if (!layerNames) {
		return this._systemState;
	}

	/** @type {LayerState[]} */
	var layerStates = [];
	var i;
	for (i = 0; i < layerNames.length; i++) {
		if (this._layerStates.hasOwnProperty(layerNames[i])) {
			layerStates.push(this._layerStates[layerNames[i]]);
		} else {
			slog.error("MotionTimeline: requested state for unknown layer: " + layerNames[i]);
			return null;
		}
	}

	var currentState = this._layerCombiner.combineLayers(layerNames, layerStates);

	// calculate velocity
	if (currentState !== null) {
		/** @type {Object.<string, LayerState>} */
		var previousLayers = null;
		if (currentState.getTime().subtract(this._previousLayerStates[layerNames[0]].getTime()) >= this._minimumUpdateDelay) {
			previousLayers = this._previousLayerStates;
		}

		if (previousLayers !== null) {
			/** @type {LayerState[]} */
			var previousLayerStates = [];
			for (i = 0; i < layerNames.length; i++) {
				if (previousLayers.hasOwnProperty(layerNames[i])) {
					previousLayerStates.push(previousLayers[layerNames[i]]);
				} else {
					previousLayerStates = null;
					break;
				}
			}

			if (previousLayerStates !== null) {
				var previousState = this._layerCombiner.combineLayers(layerNames, previousLayerStates);
				if (previousState !== null) {
					this.computeVelocity(previousState, currentState);
				}
			}
		}
	}

	return currentState;
};

/**
 * @param {MotionGenerator} motionGenerator
 * @param {string} layerName
 * @return {MotionGenerator} - the motion generator, or null if add failed
 */
MotionTimeline.prototype.add = function (motionGenerator, layerName) {
	if (!this._layers.hasOwnProperty(layerName)) {
		slog.error("MotionTimeline: skipping add on unknown layer: " + layerName);
		return null;
	}

	var startTime = motionGenerator.getStartTime();
	var dofNames = motionGenerator.getDOFs();

	var insertAt = 0;
	var intoLayer = this._layers[layerName];
	var i = 0;

	while (i < intoLayer.length) {
		//iterate over clips in this layer.  find the spot where we should be inserted
		//crop existing clips if necessary, and delete them if the crop makes them empty

		var clip = intoLayer[i];
		if (clip.getEndTime().isGreater(startTime)) {
			//clip may need to be truncated where it overlaps with newClip
			clip.cropEnd(startTime, dofNames);
		}
		if (clip.getDuration() > 0) {
			i++;
		} else {
			intoLayer.splice(i, 1); //remove the clip
			clip.notifyRemoved();
		}

		if (startTime.isGreaterOrEqual(clip.getStartTime())) {
			insertAt = i; //we can be after "clip".  insertAt will advance until we cannot be after the "clip"
		}
	}

	if (motionGenerator.getDuration() > 0) {
		intoLayer.splice(insertAt, 0, motionGenerator);
	} else {
		//console.log("Immediately removing new clip "+newClip.getName()+" since it has zero duration");
		motionGenerator.notifyRemoved();
		motionGenerator = null;
	}

	return motionGenerator;
};

/**
 * Remove any clips that end on or before cullToTime.
 *
 * @param {Time} cullToTime
 */
MotionTimeline.prototype.cullUpToTime = function (cullToTime) {
	var layerNames = Object.keys(this._layers);

	for (var li = 0; li < layerNames.length; li++) {
		var layer = this._layers[layerNames[li]];
		var ci = 0;
		while (ci < layer.length && cullToTime.isGreater(layer[ci].getStartTime())) {
			var clip = layer[ci];
			if (cullToTime.isGreaterOrEqual(clip.getEndTime())) {
				layer.splice(ci, 1); //remove from layer, don't need to increase index
				clip.notifyRemoved();
			} else {
				ci++;
			}
		}
	}
};

/**
 * @param {Time} currentTime
 */
MotionTimeline.prototype.render = function (currentTime) {
	var layerIndex, dofIndex, clipIndex;
	var layerName, dofName;
	var layer, clip;
	/** @type {number[]} */
	var newDOFState;
	/** @type {MotionGenerator} */
	var generatorForDOF;
	/** @type {Time} */
	var endTimeForDOF;

	// swap the current and previous states
	var tempState = this._previousSystemState;
	this._previousSystemState = this._systemState;
	this._systemState = tempState;
	this._systemState.setTime(currentTime);
	for (layerIndex = 0; layerIndex < this._layerNames.length; layerIndex++) {
		layerName = this._layerNames[layerIndex];
		tempState = this._previousLayerStates[layerName];
		this._previousLayerStates[layerName] = this._layerStates[layerName];
		this._layerStates[layerName] = tempState;
		this._layerStates[layerName].setTime(currentTime);
	}

	// render dof-by-dof in skeleton-sorted order

	for (dofIndex = 0; dofIndex < this._sortedDOFNames.length; dofIndex++) {
		dofName = this._sortedDOFNames[dofIndex];

		for (layerIndex = 0; layerIndex < this._layerNames.length; layerIndex++) {
			layerName = this._layerNames[layerIndex];

			if (this._dofMapByLayer[layerName].hasOwnProperty(dofName)) {
				layer = this._layers[layerName];

				/** @type {MotionGenerator} */
				generatorForDOF = null;

				clipIndex = 0;
				while (clipIndex < layer.length && currentTime.isGreaterOrEqual(layer[clipIndex].getStartTime())) {
					clip = layer[clipIndex];
					endTimeForDOF = clip.getEndTimeForDOF(dofName);
					if (endTimeForDOF !== null && endTimeForDOF.isGreater(this._previousLayerStates[layerName].getTime())) {
						generatorForDOF = clip;
					}
					clipIndex++;
				}

				/** @type {number[]} */
				newDOFState = null;
				if (generatorForDOF) {
					newDOFState = generatorForDOF.getDOFState(dofName, this._systemState);
				} else {
					// use the state from the previous tick
					newDOFState = this._previousLayerStates[layerName].getDOFState(dofName);
				}
				//if(this._robotInfo.getDOFInfo(dofName).isMetric() && (isNaN(newDOFState[0]) || (newDOFState.length>1 && isNaN[1]))){
				//	slog.error("Generator "+((generatorForDOF!=null)?generatorForDOF.getName():"null(using cached value")+" on layer "+layerName+" generating NaN for "+dofName+" ("+newDOFState.toString()+")");
				//}

				this._layerStates[layerName].setDOFState(dofName, newDOFState);

				// update partial render state
				if (layerIndex === 0) {
					this._systemState.setDOFState(dofName, newDOFState);
				} else {
					this._layerCombiner.incrementState(this._systemState, layerName, this._layerStates[layerName], dofName);
				}
			}
		}
	}

	// compute the velocity for the current state
	this.computeVelocity(this._previousSystemState, this._systemState);
};

MotionTimeline.prototype.addOutput = function (output) {
	this._outputs.push(output);
};

MotionTimeline.prototype.removeOutput = function (output) {
	var outputIndex = this._outputs.indexOf(output);
	if (outputIndex > -1) {
		this._outputs.splice(outputIndex, 1);
	}
};

/**
 * @return {Object[]}
 */
MotionTimeline.prototype.getOutputs = function () {
	return this._outputs;
};

/**
 * compute velocity between two layer states, storing the result in the second state
 * @param {LayerState} previousLayerState
 * @param {LayerState} currentLayerState
 */
MotionTimeline.prototype.computeVelocity = function (previousLayerState, currentLayerState) {
	var elapsedTime = currentLayerState.getTime().subtract(previousLayerState.getTime());
	var previousPose = previousLayerState.getPose();
	var currentPose = currentLayerState.getPose();
	var dofNames = currentLayerState.getDOFNames();

	for (var dofIndex = 0; dofIndex < dofNames.length; dofIndex++) {
		var dofName = dofNames[dofIndex];
		var dofInfo = this._robotInfo.getDOFInfo(dofName);
		if (dofInfo.isMetric()) {
			var currentValue = currentPose.get(dofName, 0);
			var previousValue = previousPose.get(dofName, 0);
			if (dofInfo.isCyclic()) {
				currentValue = CyclicMath.closestEquivalentRotation(currentValue, previousValue);
			}
			var velocity = (currentValue - previousValue) / elapsedTime;
			//if(isNaN(velocity)){
			//	slog.error("MotionTimeline: got NaN velocity for "+dofName+" from "+previousValue+" to "+currentValue+" over time "+elapsedTime);
			//}
			currentLayerState.getPose().set(dofName, velocity, 1);
		}
	}
};

MotionTimeline.prototype.update = function () {
	/** @type {Time} */
	var currentTime = this._clock.currentTime();
	if (currentTime.subtract(this._systemState.getTime()) < this._minimumUpdateDelay) {
		// update too soon, return!
		return;
	}

	var layerNames = this._layerNames;
	var layerIndex, clipIndex;
	var layer;
	var clip;

	// notify update started
	for (layerIndex = 0; layerIndex < layerNames.length; layerIndex++) {
		layer = this._layers[layerNames[layerIndex]];
		for (clipIndex = 0; clipIndex < layer.length; clipIndex++) {
			clip = layer[clipIndex];
			clip.notifyUpdateStarted(currentTime);
		}
	}

	// render
	this.render(currentTime);

	// update outputs
	for (var outputIndex = 0; outputIndex < this._outputs.length; outputIndex++) {
		var out = this._outputs[outputIndex];
		out.handleOutput(currentTime, this._systemState.getPose());
	}

	// notify update finished
	for (layerIndex = 0; layerIndex < layerNames.length; layerIndex++) {
		layer = this._layers[layerNames[layerIndex]];
		for (clipIndex = 0; clipIndex < layer.length; clipIndex++) {
			clip = layer[clipIndex];
			clip.notifyUpdateFinished(currentTime);
		}
	}

	this.cullUpToTime(currentTime);

	TimelineEventDispatcher.dispatchQueuedEvents();
};

/**
 * @param {string} layerName
 * @return {string[]}
 */
MotionTimeline.prototype.getDOFsForLayer = function (layerName) {
	if (this._layerStates.hasOwnProperty(layerName)) {
		return this._layerStates[layerName].getDOFNames();
	} else {
		return null;
	}
};

module.exports = MotionTimeline;
//# sourceMappingURL=../../map/animation-animate/timeline/MotionTimeline.js.map
