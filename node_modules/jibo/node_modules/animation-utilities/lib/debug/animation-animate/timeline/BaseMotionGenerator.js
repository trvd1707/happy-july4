/**
 * @author jg
 */

"use strict";

var MotionGenerator = require("./MotionGenerator");
var TimelineEventDispatcher = require("./TimelineEventDispatcher");

/**
 *
 * @param name
 * @param startTime
 * @param dofNames
 * @param targetDuration
 * @constructor
 * @extends MotionGenerator
 */
var BaseMotionGenerator = function BaseMotionGenerator(name, startTime, dofNames, targetDuration) {
	MotionGenerator.call(this);

	/** @type {Time} */
	this._startTime = startTime;

	/** @type {string} */
	this._name = name;
	/** @type {MotionEvent[]} */
	this._customEvents = [];

	/** @type {number} */
	this._targetDuration = targetDuration;

	this._entered = false;
	this._exited = false;

	/** @type {ClipStartedHandler} */
	this._clipStartedHandler = null;
	/** @type {ClipStoppedHandler} */
	this._clipStoppedHandler = null;
	/** @type {ClipRemovedHandler} */
	this._clipRemovedHandler = null;
	/** @type {ClipEventHandler} */
	this._clipEventHandler = null;

	//setup mask, currently all joints active for entire time
	/** @type {Object<string, number>} */
	this._mask = {};

	for (var i = 0; i < dofNames.length; i++) {
		this._mask[dofNames[i]] = targetDuration;
	}

	/** @type {Time} */
	this._currentTime = null;
};

BaseMotionGenerator.prototype = Object.create(MotionGenerator.prototype);
BaseMotionGenerator.prototype.constructor = BaseMotionGenerator;

/**
 * @param {ClipStartedHandler} clipStartedHandler
 * @param {ClipStoppedHandler} clipStoppedHandler
 * @param {ClipRemovedHandler} clipRemovedHandler
 * @param {ClipEventHandler} clipEventHandler
 */
BaseMotionGenerator.prototype.setHandlers = function (clipStartedHandler, clipStoppedHandler, clipRemovedHandler, clipEventHandler) {
	this._clipStartedHandler = clipStartedHandler;
	this._clipStoppedHandler = clipStoppedHandler;
	this._clipRemovedHandler = clipRemovedHandler;
	this._clipEventHandler = clipEventHandler;
};

/**
 * @param {MotionEvent[]} motionEvents
 */
BaseMotionGenerator.prototype.setEvents = function (motionEvents) {
	for (var evi = 0; evi < motionEvents.length; evi++) {
		this._customEvents.push(motionEvents[evi]);
	}
};

/**
 * @returns {string}
 * @override
 */
BaseMotionGenerator.prototype.getName = function () {
	return this._name;
};

/**
 * @returns {Time}
 * @override
 */
BaseMotionGenerator.prototype.getStartTime = function () {
	return this._startTime;
};

/**
 * @returns {Time}
 * @override
 */
BaseMotionGenerator.prototype.getEndTime = function () {
	return this._startTime.add(this.getDuration());
};

/**
 * @returns {number}
 * @override
 */
BaseMotionGenerator.prototype.getDuration = function () {
	var longestDuration = 0;
	var maskKeys = Object.keys(this._mask);
	for (var mki = 0; mki < maskKeys.length; mki++) {
		var maskKey = maskKeys[mki];
		if (this._mask[maskKey] > longestDuration) {
			longestDuration = this._mask[maskKey];
		}
	}
	return longestDuration;
};

/**
 * @param {string} dofName
 * @returns {Time} returns end time for DOF or null if DOF fully not included
 * @override
 */
BaseMotionGenerator.prototype.getEndTimeForDOF = function (dofName) {
	if (this._mask.hasOwnProperty(dofName)) {
		return this.getStartTime().add(this._mask[dofName]);
	} else {
		return null;
	}
};

/**
 * @param {string} dofName
 * @returns {number} returns duration for DOF or null if DOF fully not included
 * @override
 */
BaseMotionGenerator.prototype.getDurationForDOF = function (dofName) {
	if (this._mask.hasOwnProperty(dofName)) {
		return this._mask[dofName];
	} else {
		return null;
	}
};

/**
 * Force this motion to end all its tracks at or before cropTime.  If a track
 * already ends before cropTime it is unchanged.  If a a track starts after
 * cropTime it is completely removed.
 *
 * @param {Time} cropTime - crop to end at this time if necessary
 * @param {string[]} [cropMask] - only crop dofs present in this mask (all dofs if omitted)
 * @override
 */
BaseMotionGenerator.prototype.cropEnd = function (cropTime, cropMask) {
	var cropMaskKeys;
	if (cropMask != null) {
		//null or undefined (eqnull)
		cropMaskKeys = cropMask;
	} else {
		cropMaskKeys = Object.keys(this._mask);
	}
	var croppedDuration = cropTime.subtract(this._startTime);
	var cmi;
	if (croppedDuration > 0) {
		for (cmi = 0; cmi < cropMaskKeys.length; cmi++) {
			var cropThisDOF = cropMaskKeys[cmi];
			if (this._mask.hasOwnProperty(cropThisDOF)) {
				if (this._mask[cropThisDOF] > croppedDuration) {
					this._mask[cropThisDOF] = croppedDuration;
				}
			}
		}
	} else {
		for (cmi = 0; cmi < cropMaskKeys.length; cmi++) {
			delete this._mask[cropMaskKeys[cmi]];
		}
	}
};

/**
 * get all DOFs that are involved in this motion (except for any that
 * have been removed completely via cropping)
 *
 * @returns {string[]}
 * @override
 */
BaseMotionGenerator.prototype.getDOFs = function () {
	return Object.keys(this._mask);
};

/**
 * Get all dofs that are currently active at the given time
 * @param {Time} time
 * @returns {string[]}
 */
BaseMotionGenerator.prototype.getActiveDOFs = function (time) {
	var activeDOFs = [];
	if (time.isGreaterOrEqual(this._startTime)) {
		var possibleDOFs = Object.keys(this._mask);
		for (var i = 0; i < possibleDOFs.length; i++) {
			if (this.getEndTimeForDOF(possibleDOFs[i]).isGreater(time)) {
				activeDOFs.push(possibleDOFs[i]);
			}
		}
	}
	return activeDOFs;
};

/**
 * @returns {boolean}
 * @override
 */
BaseMotionGenerator.prototype.hasEntered = function () {
	return this._entered;
};

/**
 * @returns {boolean}
 * @override
 */
BaseMotionGenerator.prototype.hasExited = function () {
	return this._exited;
};

/**
 *
 * @param {Time} currentTime
 * @override
 */
BaseMotionGenerator.prototype.notifyUpdateStarted = function (currentTime) {
	this._currentTime = currentTime;
};

/**
 *
 * @override
 */
BaseMotionGenerator.prototype.notifyUpdateFinished = function () {
	if (!this._entered && this._currentTime.isGreaterOrEqual(this.getStartTime())) {
		this._entered = true;
		//console.log("Event: Clip "+clip.getName()+" Started!!");
		if (this._clipStartedHandler) {
			TimelineEventDispatcher.queueEvent(this._clipStartedHandler, []);
		}
	}
	if (this._entered && !this._exited) {
		this.queueCustomEvents();
	}
	if (this._entered && !this._exited && this._currentTime.isGreaterOrEqual(this.getEndTime())) {
		this._exited = true;
		var interrupted = Math.abs(this.getDuration() - this._targetDuration) > 0.001;
		//console.log("Event: Clip "+clip.getName()+" Stopped!! (interrupted="+interrupted+")");
		if (this._clipStoppedHandler) {
			TimelineEventDispatcher.queueEvent(this._clipStoppedHandler, [interrupted]);
		}
	}
};

/**
 *
 * @override
 */
BaseMotionGenerator.prototype.notifyRemoved = function () {
	if (this._clipRemovedHandler) {
		TimelineEventDispatcher.queueEvent(this._clipRemovedHandler, [this._entered, this._exited]);
	}
};

BaseMotionGenerator.prototype.queueCustomEvents = function () {
	if (this.hasEntered() && !this.hasExited() && this._clipEventHandler) {
		var relativeCurrentTime = this._currentTime.subtract(this.getStartTime());
		var relativeEndTime = this.getDuration();

		while (this._customEvents.length > 0 && this._customEvents[0].getTimestamp() <= relativeCurrentTime && this._customEvents[0].getTimestamp() <= relativeEndTime) {
			TimelineEventDispatcher.queueEvent(this._clipEventHandler, [this._customEvents[0]]);
			this._customEvents.shift();
		}
	}
};

module.exports = BaseMotionGenerator;
//# sourceMappingURL=../../map/animation-animate/timeline/BaseMotionGenerator.js.map
