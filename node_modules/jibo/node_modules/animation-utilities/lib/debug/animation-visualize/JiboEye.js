/**
 * @author mattb
 */

"use strict";

var ArticulatedModelLoader = require("../ifr-geometry/loaders/ArticulatedModelLoader");
var KinematicsLoader = require("../ifr-motion/loaders/KinematicsLoader");
var TextureControl = require("../ifr-motion/dofs/TextureControl");
var THREE = require("three");

/**
 * @param {JiboConfig} jiboConfig
 * @private
 * @constructor
 */
var JiboEye = function JiboEye(jiboConfig) {
	/** @type {JiboConfig} */
	this._config = jiboConfig;

	/** @type {CachedImageLoader} */
	this._textureLoader = null;

	/** @type {THREE.Object3D} */
	this._modelRoot = null;
	/** @type {ModelControlGroup} */
	this._modelControlGroup = null;

	/** @type {!boolean} */
	this.loadSucceeded = false;
	/** @type {string} */
	this.loadMessage = "";
};

/**
 * @param {CachedImageLoader} textureLoader
 */
JiboEye.prototype.setTextureLoader = function (textureLoader) {
	this._textureLoader = textureLoader;
};

JiboEye.prototype.load = function (callback) {
	var self = this;

	var loader = new ArticulatedModelLoader();
	loader.load("eye model", self._config.getEyeGeometryURL(), self._config.getEyeSkeletonURL(), function () {
		var result = loader.getResult();
		if (result.success) {
			self._modelRoot = result.modelRoot;

			// prepare eye overlays
			var overlayZ = 0;
			var deltaZ = 0.01;
			for (var childIndex = 0; childIndex < self._modelRoot.children.length; childIndex++) {
				var child = self._modelRoot.children[childIndex];
				if (child instanceof THREE.SkinnedMesh) {
					child.material.transparent = true;
					child.frustumCulled = false;
					child.position.z = overlayZ;
					overlayZ += deltaZ;
				}
			}
			self._modelRoot.traverse(function (obj) {
				if (obj instanceof THREE.Mesh) {
					//screen background should also be transparent
					obj.material.transparent = true;
					obj.frustumCulled = false;
				}
			});

			var kinematicsLoader = new KinematicsLoader();
			/** @type {TextureControl.Factory} */
			var textureFactory = kinematicsLoader.getModelControlFactory(TextureControl.Factory.prototype._controlType);
			if (self._textureLoader) {
				textureFactory.setSharedImageLoader(self._textureLoader);
			}

			kinematicsLoader.load(self._config.getEyeKinematicsURL(), function () {
				var kinematicsResult = kinematicsLoader.getResult();
				if (kinematicsResult.success) {
					self._modelControlGroup = kinematicsResult.modelControlGroup;
					self._modelControlGroup.attachToModel(self._modelRoot);

					//config for default normal map for users not specifying a normal url
					for (var ci = 0; ci < self._modelControlGroup.getControlList().length; ci++) {
						if (self._modelControlGroup.getControlList()[ci].getControlType() === "TEXTURE") {
							self._modelControlGroup.getControlList()[ci].setDefaultNormalURL(self._config.getDefaultNormalMap());
						}
					}

					self.loadSucceeded = true;
				} else {
					self.loadSucceeded = false;
					self.loadMessage = "kinematics load failed with message: " + kinematicsResult.message + ", URL = " + kinematicsResult.url;
				}
				if (callback) {
					callback();
				}
			});
		} else {
			self.loadSucceeded = false;
			self.loadMessage = "" + result.message + ", model URL = " + result.modelUrl + ", skeleton URL = " + result.skeletonUrl;
			if (callback) {
				callback();
			}
		}
	});
};

/**
 * @return {THREE.Object3D}
 */
JiboEye.prototype.getModelRoot = function () {
	return this._modelRoot;
};

/**
 * @return {ModelControlGroup}
 */
JiboEye.prototype.getModelControlGroup = function () {
	return this._modelControlGroup;
};

/**
 * @param {SceneInfo} sceneInfo
 * @return {THREE.Camera}
 */
JiboEye.prototype.constructCamera = function (sceneInfo) {
	var camera = new THREE.OrthographicCamera(-sceneInfo.faceScreenWidth / 2, sceneInfo.faceScreenWidth / 2, sceneInfo.faceScreenHeight / 2, -sceneInfo.faceScreenHeight / 2, -20, 20);
	camera.position.set(0, 0, 5); //need to provide a position for lighting to work

	//could do as perspective, if having trouble with lighting:
	//var distance = 5;
	//var fov = 0.79;
	//var camera = new THREE.PerspectiveCamera(fov, sceneInfo.faceScreenWidth/sceneInfo.faceScreenHeight, distance-0.5, distance+0.5);
	//camera.position.set(0,0,distance);
	//camera.lookAt(new THREE.Vector3(0,0,0));
	//console.log("Camera matrixWorld = "+camera.matrixWorld.elements);

	camera.updateMatrixWorld(true);
	return camera;
};

/**
 * @return {THREE.Scene}
 */
JiboEye.prototype.constructScene = function () {
	var scene = new THREE.Scene();
	scene.add(this.getModelRoot());
	return scene;
};

module.exports = JiboEye;
//# sourceMappingURL=../map/animation-visualize/JiboEye.js.map
