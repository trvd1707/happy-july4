/**
 * @author mattb
 */

"use strict";

var animate = require("../animation-animate/AnimateImpl");
var MotionTimeline = require("../animation-animate/timeline/MotionTimeline");
var SimpleLayerCombiner = require("../animation-animate/timeline/SimpleLayerCombiner");
var ScaleSampleCombiner = require("../animation-animate/timeline/ScaleSampleCombiner");
var AddSampleCombiner = require("../animation-animate/timeline/AddSampleCombiner");
var MixedSampleCombiner = require("../animation-animate/timeline/MixedSampleCombiner");
var RendererOutput = require("../animation-visualize/RendererOutput");
var Clock = require("../ifr-core/Clock");
var TimerTools = require("../ifr-core/TimerTools");

/** @type {MotionTimeline[]} */
var timelineList = [];
/** @type {Array} */
var updateHandleList = [];

/**
 * @param {MotionTimeline} timeline
 * @param {number} updateIntervalMillis
 * @param {Object[]} updateList
 */
var createUpdateLoop = function createUpdateLoop(timeline, updateIntervalMillis, updateList) {
	var updateHandle = TimerTools.setInterval(function () {
		for (var i = 0; i < updateList.length; i++) {
			updateList[i].update();
		}
	}, updateIntervalMillis);
	timelineList.push(timeline);
	updateHandleList.push(updateHandle);
};

/**
 * @param {MotionTimeline} timeline
 */
var disposeUpdateLoop = function disposeUpdateLoop(timeline) {
	var timelineIndex = timelineList.indexOf(timeline);
	if (timelineIndex > -1) {
		TimerTools.clearInterval(updateHandleList[timelineIndex]);
		timelineList.splice(timelineIndex, 1);
		updateHandleList.splice(timelineIndex, 1);
	}
};

var TimelineBuilder = {

	/**
  * @param {RobotInfo} robotInfo - kinematics/config info
  * @param cb - callback to receive the newly-created Timeline instance
  * @param {number} [updateIntervalMillis] - timeline will auto-update with the given delay
  *
  * @return {MotionTimeline} the newly-created Timeline instance
  */
	createTimeline: function createTimeline(robotInfo, cb, updateIntervalMillis) {
		updateIntervalMillis = updateIntervalMillis !== undefined ? updateIntervalMillis : 20;

		// create motion timeline
		var layerCombiner = new SimpleLayerCombiner();
		var motionTimeline = new MotionTimeline("Motion Timeline", robotInfo, Clock, layerCombiner, animate.MODALITY_NAME);

		// configure default layer
		motionTimeline.createLayer("default");

		// configure lookat layer
		motionTimeline.createLayer("lookat", [robotInfo.getDOFSet("BODY").getDOFs()[0]]);
		layerCombiner.setSampleCombiner("lookat", new AddSampleCombiner());

		// configure additive posture layer
		motionTimeline.createLayer("posture", robotInfo.getDOFSet("BODY").plus("EYE_ROOT").plus("OVERLAY_ROOT").getDOFs());
		layerCombiner.setSampleCombiner("posture", new AddSampleCombiner());

		// configure additive beat layer
		var additiveDOFSet = robotInfo.getDOFSet("BODY").plus("EYE_ROOT").plus("OVERLAY_ROOT");
		var deformerDOFSet = robotInfo.getDOFSet("EYE_DEFORM").plus("OVERLAY_DEFORM");
		motionTimeline.createLayer("beat", additiveDOFSet.plus(deformerDOFSet).getDOFs());
		var beatCombiner = new MixedSampleCombiner();
		beatCombiner.addCombiner(additiveDOFSet.getDOFs(), new AddSampleCombiner());
		var scaleCombiner = new ScaleSampleCombiner(robotInfo.getKinematicInfo().getDefaultPose().getCopy(), null, deformerDOFSet.getDOFs());
		beatCombiner.addCombiner(deformerDOFSet.getDOFs(), scaleCombiner);
		layerCombiner.setSampleCombiner("beat", beatCombiner);

		// configure blink layer
		var blinkDOFs = robotInfo.getDOFSet("EYE_DEFORM").getDOFs();
		motionTimeline.createLayer("blink", blinkDOFs);
		var blinkCombiner = new ScaleSampleCombiner(robotInfo.getKinematicInfo().getDefaultPose().getCopy(), null, blinkDOFs);
		layerCombiner.setSampleCombiner("blink", blinkCombiner);

		// add renderer output
		var rendererOutput = new RendererOutput(Clock);
		rendererOutput.setKinematicInfo(robotInfo.getKinematicInfo());
		motionTimeline.addOutput(rendererOutput);

		// create the update loop
		var updateList = [motionTimeline, rendererOutput];
		createUpdateLoop(motionTimeline, updateIntervalMillis, updateList);

		if (cb) {
			cb(motionTimeline);
		}

		return motionTimeline;
	},

	/**
  * connect a WebGL renderer to the timeline
  * @param {MotionTimeline} timeline
  * @param {RobotRenderer} renderer
  */
	connectRenderer: function connectRenderer(timeline, renderer) {
		var outputs = timeline.getOutputs();
		for (var i = 0; i < outputs.length; i++) {
			if (outputs[i] instanceof RendererOutput) {
				outputs[i].addRenderer(renderer);
				break;
			}
		}
	},

	/**
  * disconnect a WebGL renderer from the timeline
  * @param {MotionTimeline} timeline
  * @param {RobotRenderer} renderer
  */
	disconnectRenderer: function disconnectRenderer(timeline, renderer) {
		var outputs = timeline.getOutputs();
		for (var i = 0; i < outputs.length; i++) {
			if (outputs[i] instanceof RendererOutput) {
				outputs[i].removeRenderer(renderer);
				break;
			}
		}
	},

	/**
  * dispose the timeline and stop all timeline-related computation.
  * optionally, dispose of all timeline outputs as well.
  * @param {MotionTimeline} timeline
  * @param {boolean} disposeOutputs - if true, dispose of all installed timeline outputs
  */
	disposeTimeline: function disposeTimeline(timeline, disposeOutputs) {
		disposeUpdateLoop(timeline);

		if (disposeOutputs === true) {
			var outputs = timeline.getOutputs();
			for (var i = 0; i < outputs.length; i++) {
				if (outputs[i].dispose !== undefined) {
					outputs[i].dispose();
				}
			}
		}
	}

};

module.exports = TimelineBuilder;
//# sourceMappingURL=../map/animation-macros/TimelineBuilder.js.map
