/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var PointADOF = require("./PointADOF");
var slog = require("../../ifr-core/SLog");

var channel = "LOOKAT";

var PointNodeReport = function PointNodeReport() {
	/**
  * 0 for unstable target, 1 for very stable
  * @type {?number} */
	this._targetStability = null;
	this._pointSucceeded = true;
};

/**
 *
 * @param {string} name
 * @param {LookatDOF[]} lookatDOFs - assumed to be in order root to leaf
 * @param {KinematicGroup} myKinematicGroup
 * @constructor
 */
var LookatNode = function LookatNode(name, lookatDOFs) {
	/** @type {string} */
	this._name = name;
	/** @type {LookatDOF[]} */
	this._lookatDOFs = lookatDOFs;
	/** @type {KinematicGroup} */
	this._kinematicGroup = null;
};

LookatNode.PointNodeReport = PointNodeReport;

/**
 * @param {KinematicGroup} kinematicGroup
 */
LookatNode.prototype.connectToGroup = function (kinematicGroup) {
	this._kinematicGroup = kinematicGroup;

	for (var i = 0; i < this._lookatDOFs.length; i++) {
		this._lookatDOFs[i].connectToGroup(this._kinematicGroup);
	}
};

/**
 *
 * @param {PointReport} newDOFReport
 * @param {PointNodeReport} nodeReportInplace
 */
function updateReport(newDOFReport, nodeReportInplace, pointSucceeded) {
	var angleValue = newDOFReport._angleToAxis / (Math.PI / 2);
	var distanceValue = Math.min(newDOFReport._distanceToTarget * 5, 1); //1 for >20cm, linear score down to 0 from there.
	if (nodeReportInplace._targetStability === null) {
		nodeReportInplace._targetStability = angleValue * distanceValue;
	} else {
		nodeReportInplace._targetStability *= angleValue * distanceValue;
	}
	if (!pointSucceeded) {
		nodeReportInplace._pointSucceeded = false;
	}
	//if(nodeReportInplace._targetStability > 1.001){
	//	console.log("stability = "+nodeReportInplace._targetStability+", "+newDOFReport._angleToAxis+", "+newDOFReport._distanceToTarget);
	//}
}

/**
 *
 * @param {Pose} currentPose
 * @param {Pose} inplaceOutput
 * @param {THREE.Vector3} target
 * @param {Pose} [defaultPose] - use this pose's values in place of values that cannot be currently computed. (currentPose used if ommitted)
 * @param {PointReport} [pointNodeReport] - inplace arg to return metadata about combined computation
 * @return {boolean} true if all nodes computed a value; false if one or more was uncomputable and had to utilize defaultPose.
 */
LookatNode.prototype.getPose = function (currentPose, inplaceOutput, target, defaultPose, pointNodeReport) {
	if (inplaceOutput !== currentPose) {
		//no need if they are the same instance..
		inplaceOutput.setPose(currentPose);
	}

	if (defaultPose == null) {
		//null or undefined (eqnull)
		defaultPose = currentPose;
	}

	var anyFailures = false;

	this._kinematicGroup.setFromPose(currentPose);
	this._kinematicGroup.getRoot().updateMatrixWorld(true);

	var pointDOFReport = null;

	for (var i = 0; i < this._lookatDOFs.length; i++) {
		if (pointNodeReport) {
			pointDOFReport = new PointADOF.PointReport();
		}

		var value = this._lookatDOFs[i].valToPointAtTarget(target, pointDOFReport);

		if (pointDOFReport) {
			updateReport(pointDOFReport, pointNodeReport, value != null);
		}

		if (value != null) {
			inplaceOutput.set(this._lookatDOFs[i].getControlledDOFName(), value, 0);
		} else {
			slog(channel, "LookatNode " + this._name + " using last value due to uncomputable value for target (" + target.x + ", " + target.y + ", " + target.z + ")");
			inplaceOutput.set(this._lookatDOFs[i].getControlledDOFName(), defaultPose.get(this._lookatDOFs[i].getControlledDOFName(), 0), 0);
			anyFailures = true;
		}
		if (i < this._lookatDOFs.length - 1) {
			//more updating to do
			this._kinematicGroup.setFromPose(inplaceOutput);
			this._kinematicGroup.getRoot().updateMatrixWorld(true);
		}
	}

	return !anyFailures;
};

/**
 * Get all the dofs that are modified by this node
 * @return {string[]}
 */
LookatNode.prototype.getDOFs = function () {
	var allDOFs = [];
	for (var i = 0; i < this._lookatDOFs.length; i++) {
		allDOFs.push(this._lookatDOFs[i].getControlledDOFName());
	}
	return allDOFs;
};

/**
 * Find the distance between 2 poses, only accounting for DOFs that are part of this LookatNode.
 * The difference is calculated as a ratio (of error over dof range) rather than absolute value.
 * This function is designed to give a metric lookat progress, e.g., pass in optimal and
 * filtered/current to see how far the lookat still has to go.
 *
 * @param {Pose} pose1
 * @param {Pose} pose2
 * @return {number} greatest ratio (distance/totalDistance) of any of our lookat DOFs between pose1 to pose2
 */
LookatNode.prototype.distanceAsRatio = function (pose1, pose2) {
	var maxRatio = 0;
	for (var i = 0; i < this._lookatDOFs.length; i++) {
		var lookatDOF = this._lookatDOFs[i];
		var dofName = lookatDOF.getControlledDOFName();
		var p1v = pose1.get(dofName, 0);
		var p2v = pose2.get(dofName, 0);
		var ratio = lookatDOF.errorRatio(p1v - p2v);
		if (ratio > maxRatio) {
			maxRatio = ratio;
		}
	}
	return maxRatio;
};

/**
 * @returns {string}
 */
LookatNode.prototype.getName = function () {
	return this._name;
};

/**
 *
 * @param {Pose} currentPose - use this current pose
 * @param {THREE.Vector3} inplaceVec
 * @return {THREE.Vector3} a suggestion for a target that is forward for this lookat (node is already looking at this point)
 */
LookatNode.prototype.suggestForwardTarget = function (currentPose, inplaceVec) {
	this._kinematicGroup.setFromPose(currentPose);
	this._kinematicGroup.getRoot().updateMatrixWorld(true);
	return this._lookatDOFs[0].suggestForwardTarget(inplaceVec);
};

module.exports = LookatNode;
//# sourceMappingURL=../../map/ifr-motion/lookat/LookatNode.js.map
