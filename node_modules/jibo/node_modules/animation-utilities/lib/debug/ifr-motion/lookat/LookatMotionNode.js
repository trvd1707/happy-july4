/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var OcularStabilizationTracker = require("./OcularStabilizationTracker");
var PoseOffsetFilter = require("./PoseOffsetFilter");
var Pose = require("../base/Pose");
var slog = require("../../ifr-core/SLog");
var THREE = require("three");
var LookatNode = require("./LookatNode");
var LookatNodeDistanceReport = require("./LookatNodeDistanceReport");
var LookatNodeTrackPolicy = require("./trackpolicy/LookatNodeTrackPolicy");
var TrackPolicyTriggerAlways = require("./trackpolicy/TrackPolicyTriggerAlways");

/**
 * Enum Values for look stabilization modes, for use with LookatMotionNode's constructor.
 * @enum {string}
 */
var LookStabilizationMode = {
	/**
  * Use point-at stabilization relative to current target.
  */
	POINT_TARGET: "POINT_TARGET",
	/**
  * Use point-st stabilization relative to node forward.
  */
	POINT_FORWARD: "POINT_FORWARD",
	/**
  * Use point-at from target when it scores stable, forward relative otherwise
  */
	POINT_AUTO: "POINT_AUTO"
};

/**
 *
 * @param {LookatNode} lookatNode - assumed to be in order root to leaf
 * @param {DOFGlobalAlignment} dofAligner
 * @param {number} accel - acceleration value for this node
 * @param {LookStabilizationMode} stabilizationMode - specify stabilization mode
 * @param {LookatNodeTrackPolicy} trackPolicy
 * @constructor
 */
var LookatMotionNode = function LookatMotionNode(lookatNode, dofAligner, accel, stabilizationMode, trackPolicy) {
	/** @type {LookatNode} */
	this._lookatNode = lookatNode;

	/** @type {OcularStabilizationTracker} */
	this._stabilization = new OcularStabilizationTracker(lookatNode, dofAligner);

	/** @type {PoseOffsetFilter} */
	this._filter = new PoseOffsetFilter(lookatNode.getDOFs());
	this._filter.setRejectDeltaThreshold(0.4);
	if (accel != null) {
		this._filter.setAcceleration(accel);
	}

	/** @type {Time} */
	this._lastUpdateTime = null;

	/** @type {Pose} */
	this._optimalPose = new Pose("LMN Optimal", lookatNode.getDOFs());

	/** @type {Pose} */
	this._tempPose = new Pose("LMN Temp", lookatNode.getDOFs());

	/** @type {THREE.Vector3} */
	this._stabilizationTarget = new THREE.Vector3();

	/** @type {Pose} */
	this._poseForStabilizationTarget = new Pose("Pose For ST", lookatNode.getDOFs());

	/** @type {Pose} */
	this._holdPose = new Pose("Hold Pose", lookatNode.getDOFs());

	/** @type {LookatNodeTrackPolicy} */
	this._lookatTrackPolicy = trackPolicy;
	if (this._lookatTrackPolicy == null) {
		//null or undefined (eqnull)
		this._lookatTrackPolicy = new LookatNodeTrackPolicy([new TrackPolicyTriggerAlways()]);
	}

	/** @type {DOFGlobalAlignment} */
	this._dofAligner = dofAligner;

	/**
  * stabilization mode
  * @type {LookStabilizationMode} */
	this._stabilizationMode = stabilizationMode;

	/**
  * @type {LookatNodeDistanceReport}
  * @private
  */
	this._lookatNodeDistanceReport = new LookatNodeDistanceReport();
};

LookatMotionNode.LookStabilizationMode = LookStabilizationMode;

/**
 * @param {KinematicGroup} kinematicGroup
 */
LookatMotionNode.prototype.connectToGroup = function (kinematicGroup) {
	this._lookatNode.connectToGroup(kinematicGroup);
};

/**
 * Update state to the current time and produce the new filtered pose.
 * If called twice at the same "time", second call will not recompute,
 * and will instead return the same pose.
 *
 * @param {Pose} currentPose - use parents' position from here to compute our values.  velocities and positions of currentPose (our node and parents) must be correct on first update after reset! (initialization update)
 * @param {Pose} inplaceOutput
 * @param {THREE.Vector3} target
 * @param {Time} time
 */
LookatMotionNode.prototype.update = function (currentPose, inplaceOutput, target, time) {

	if (this._lastUpdateTime !== null && time.equals(this._lastUpdateTime)) {
		this._filter.getValue(inplaceOutput);
		return;
	}

	var defaultPose;

	if (this._lastUpdateTime === null) {
		//not initialized, must make do
		defaultPose = currentPose;
	} else {
		//initialized, previous optimal will be a good default for uncomputable joints
		defaultPose = this._optimalPose;
	}

	var report = new LookatNode.PointNodeReport();

	this._lookatNode.getPose(currentPose, this._optimalPose, target, defaultPose, report);

	if (this._stabilizationMode === LookStabilizationMode.POINT_FORWARD || this._stabilizationMode === LookStabilizationMode.POINT_AUTO && (report._targetStability < 0.2 || !report._pointSucceeded)) {
		if (this._stabilizationMode === LookStabilizationMode.POINT_AUTO) {
			slog.info("Stabilization AUTO mode for " + this.getName() + " falling back to FORWARD with stability " + report._targetStability + ", pointSuccess=" + report._pointSucceeded);
		}
		this._lookatNode.suggestForwardTarget(currentPose, this._stabilizationTarget);
		this._lookatNode.getPose(currentPose, this._poseForStabilizationTarget, this._stabilizationTarget, defaultPose);
	} else {
		this._stabilizationTarget.copy(target);
		this._poseForStabilizationTarget.setPose(this._optimalPose);
	}

	//hold is hold, but already stabilized

	if (this._lastUpdateTime === null) {
		this._stabilization.reset();

		//init hold pose to the state at the start
		this._holdPose.setPose(currentPose);

		this._lookatTrackPolicy.reset();

		this._stabilization.computeStabilizationDelta(currentPose, this._poseForStabilizationTarget, this._stabilizationTarget); //initialize for next time
		this._tempPose.setPose(currentPose);

		this._stabilization.decomposeVelocity(currentPose, this._tempPose, this._stabilizationTarget, this._filter.getRejectDeltaThreshold());
		//tempPose has velocity removed that will later be added back in by the stabilization delta.
		this._filter.resetToPose(this._tempPose);
	} else {
		this._filter.getTarget(this._tempPose);
		this._dofAligner.refineToLocallyClosestTargetPose(this._tempPose, this._optimalPose);

		var delta = this._stabilization.computeStabilizationDelta(currentPose, this._poseForStabilizationTarget, this._stabilizationTarget);
		//var delta = new Pose("temp", currentPose.getDOFNames());
		this._filter.applyUnfilteredOffset(delta);
		Pose.add(this._holdPose, delta, false, this._holdPose);

		this._filter.getValue(this._tempPose); //grab current filter value to check our progress
		this._lookatNodeDistanceReport.compute(this._holdPose, this._optimalPose, this._tempPose);
		var trackMode = this._lookatTrackPolicy.computeMode(this._lookatNodeDistanceReport, time);
		if (trackMode === LookatNodeTrackPolicy.TrackMode.HOLD || trackMode === LookatNodeTrackPolicy.TrackMode.DELAY) {
			this._filter.setTarget(this._holdPose);
		} else {
			this._filter.setTarget(this._optimalPose);
		}

		this._filter.updateByTime(time.subtract(this._lastUpdateTime));
	}

	if (inplaceOutput != null) {
		//null or undefined (eqnull)
		this._filter.getValue(inplaceOutput);
	}

	this._lastUpdateTime = time;
};

/**
 * Produces the optimal lookat pose, regardless of current state/time.  Does not update state.
 *
 * @param {Pose} currentPose
 * @param {Pose} inplaceOutput
 * @param {THREE.Vector3} target
 */
LookatMotionNode.prototype.getOptimalPose = function (currentPose, inplaceOutput, target) {
	var defaultPose;

	if (this._lastUpdateTime === null) {
		//not initialized, must make do
		defaultPose = currentPose;
	} else {
		//initialized, previous optimal will be a good default for uncomputable joints
		defaultPose = this._optimalPose;
	}

	this._lookatNode.getPose(currentPose, inplaceOutput, target, defaultPose);
};

/**
 * Get the latest computed pose.  Does not advance (use update()).  Only
 * valid after initialized, typically by first call to update() after init or reset.
 *
 * @param {Pose} inplaceOutput
 */
LookatMotionNode.prototype.getPose = function (inplaceOutput) {
	if (this._lastUpdateTime === null) {
		slog.error("LookatMotionNode asked \"getPose()\" before initialization");
	}
	this._filter.getValue(inplaceOutput);
};

/**
 * Get the distance remaining from filtered to optimal.  Does not advance (use update())
 * This value is computed from the data calculated in the last update() call.
 * @return {number} distance of dof with largest remaining distance (as ratio of current distance of total range of LookatDOF)
 */
LookatMotionNode.prototype.getDistanceRemaining = function () {
	this._filter.getValue(this._tempPose);
	return this._lookatNode.distanceAsRatio(this._tempPose, this._optimalPose);
};

/**
 * Get all the dofs that are modified by this node
 * @return {string[]}
 */
LookatMotionNode.prototype.getDOFs = function () {
	return this._lookatNode.getDOFs();
};

LookatMotionNode.prototype.reset = function () {
	this._lastUpdateTime = null;
};

LookatMotionNode.prototype.getName = function () {
	return this._lookatNode.getName();
};

module.exports = LookatMotionNode;
//# sourceMappingURL=../../map/ifr-motion/lookat/LookatMotionNode.js.map
