/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var slog = require("../../ifr-core/SLog");
var Pose = require("../base/Pose");
var THREE = require("three");
var LookatNode = require("./LookatNode");

/**
 *
 * @param {LookatNode} lookatNode
 * @param {DOFGlobalAlignment} dofAligner
 * @constructor
 */
var OcularStabilizationTracker = function OcularStabilizationTracker(lookatNode, dofAligner) {
	/** @type {boolean} */
	var initialized = false;

	/** @type {THREE.Vector3} */
	var lastTargetWorldSpace = new THREE.Vector3();

	/** @type {string[]} */
	var dofNamesInUse = lookatNode.getDOFs();

	/** @type {Pose} */
	var lastOptimalPoseForLastTarget = new Pose(lookatNode.getName() + " Last Optimal", dofNamesInUse);

	/** @type {Pose} */
	var newOptimalPoseForLastTarget = new Pose(lookatNode.getName() + " Stepped Pose", dofNamesInUse);

	/** @type {Pose} */
	var deltaPoseFromLastTime = new Pose(lookatNode.getName() + " OST Delta", dofNamesInUse);

	/** @type {Pose} */
	var decompLastPoseOptimal = new Pose(lookatNode.getName() + " Temp Last Pose Optimal", dofNamesInUse);

	/** @type {Pose} */
	var decompLastPose = null; //init with correct nodes when first used.

	/**
  *
  * @param {Pose} currentPose
  * @param {Pose} optimalPoseForCurrentTarget
  * @param {THREE.Vector3} currentTarget
  * @returns {Pose}
  */
	this.computeStabilizationDelta = function (currentPose, optimalPoseForCurrentTarget, currentTarget) {

		if (initialized) {
			var report = new LookatNode.PointNodeReport();
			lookatNode.getPose(currentPose, newOptimalPoseForLastTarget, lastTargetWorldSpace, null, report);
			if (report._pointSucceeded) {
				if (dofAligner != null) {
					dofAligner.refineToLocallyClosestTargetPose(lastOptimalPoseForLastTarget, newOptimalPoseForLastTarget);
				}
				Pose.subtract(newOptimalPoseForLastTarget, lastOptimalPoseForLastTarget, true, deltaPoseFromLastTime);
			} else {
				//can't do anything with newOptimal; we'll report zero delta
				for (var r = 0; r < deltaPoseFromLastTime.getDOFNames(); r++) {
					deltaPoseFromLastTime.set(deltaPoseFromLastTime.getDOFNames()[r], 0, 0);
				}
			}
		} else {
			deltaPoseFromLastTime.clear();
			for (var f = 0; f < dofNamesInUse.length; f++) {
				deltaPoseFromLastTime.set(dofNamesInUse[f], 0, 0); //start off with zero delta
			}
		}

		lastTargetWorldSpace.copy(currentTarget);
		if (optimalPoseForCurrentTarget == null) {
			//if it is not provided, we must calculate it here.
			lookatNode.getPose(currentPose, lastOptimalPoseForLastTarget, currentTarget);
		} else {
			lastOptimalPoseForLastTarget.setPose(optimalPoseForCurrentTarget);
		}
		initialized = true;
		return deltaPoseFromLastTime;
	};

	/**
  * This function computes the portion of each node's velocity that is used to stabilize it against
  * parent motion (e.g., the portion that would be produced by computeStabilizationDelta).  It then subtracts
  * that portion off, and returns the remainder which represents the post-stabilized motion of the node.  These
  * velocities are computed for each dof used by this node, and provided through the inplacePostStabilizationPose
  * argument.
  *
  * @param {Pose} currentPose - current pose and velocities (can be same as inplacePostStabilizationPose)
  * @param {Pose} inplacePostStabilizationPose - inplace argument to receive computed velocities (other values unchanged)
  * @param {THREE.Vector3} target - stabilize with respect to this target
  * @param {number} [rejectionDeltaThreshold=0] - limit the delta component (represented as raw distance over 1/50s) related to stabilization to this value (0 means no limit)
  */
	this.decomposeVelocity = function (currentPose, inplacePostStabilizationPose, target, rejectionDeltaThreshold) {

		if (rejectionDeltaThreshold == null) {
			//null or undefined (eqnull)
			rejectionDeltaThreshold = 0;
		}

		if (decompLastPose === null) {
			decompLastPose = new Pose(lookatNode.getName() + " Decomp Last Pose");
		}

		Pose.advanceByTime(currentPose, true, decompLastPose, -1 / 50.0);

		lookatNode.getPose(currentPose, newOptimalPoseForLastTarget, target);
		lookatNode.getPose(decompLastPose, decompLastPoseOptimal, target);

		if (dofAligner != null) {
			dofAligner.refineToLocallyClosestTargetPose(decompLastPoseOptimal, newOptimalPoseForLastTarget);
		}

		Pose.subtract(newOptimalPoseForLastTarget, decompLastPoseOptimal, true, deltaPoseFromLastTime);

		var dofNames = deltaPoseFromLastTime.getDOFNames();
		for (var i = 0; i < dofNames.length; i++) {
			var dofName = dofNames[i];
			var originalVelocity = currentPose.get(dofName, 1);
			var deltaComponent = deltaPoseFromLastTime.get(dofName, 0);
			if (rejectionDeltaThreshold !== 0 && Math.abs(deltaComponent) > rejectionDeltaThreshold) {
				slog.error("Clamping OST application of unfiltered offset of " + deltaPoseFromLastTime + " to " + dofName + " as it is greater than " + rejectionDeltaThreshold);
				if (deltaComponent < 0) {
					deltaComponent = -rejectionDeltaThreshold;
				} else {
					deltaComponent = rejectionDeltaThreshold;
				}
			}

			var stabilizationVelocity = deltaComponent * 50;
			inplacePostStabilizationPose.set(dofName, originalVelocity - stabilizationVelocity, 1);
		}
	};

	/**
  * Reset between tracking sessions, so the first frame of a new track isn't treated
  * as part of the last tracking (with a large jump).  When computeStabilizationDelta is
  * called multiple times in a row with no intervening reset, it is assumed to be part of
  * a single stabilization session.
  */
	this.reset = function () {
		initialized = false;
	};
};

module.exports = OcularStabilizationTracker;
//# sourceMappingURL=../../map/ifr-motion/lookat/OcularStabilizationTracker.js.map
