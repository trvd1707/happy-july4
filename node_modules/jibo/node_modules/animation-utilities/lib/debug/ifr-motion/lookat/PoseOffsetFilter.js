/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var slog = require("../../ifr-core/SLog");
var AccelPlanner = require("../base/AccelPlanner");
var Pose = require("../base/Pose");

var channel = "LOOKAT";

/**
 *
 * @param {string[]} dofNames
 * @constructor
 */
var PoseOffsetFilter = function PoseOffsetFilter(dofNames) {

	/** @type {Pose} */
	var targetPose = new Pose("POF Target", dofNames);
	/** @type {Pose} */
	var filteredPose = new Pose("POF Filtered", dofNames);

	/** @type {AccelPlanner} */
	var accelPlanner = new AccelPlanner();

	/** @type {number} */
	var accLimit = 0.5;

	/** @type {number} */
	var rejectionDeltaThreshold = 0;

	var epsilon = 0.00001;

	/**
  * @param {number} seconds
  */
	this.updateByTime = function (seconds) {
		/** @type {number} */
		var i;
		/** @type {string} */
		var dofName;
		/** @type {number} */
		var currentPos, currentVel;
		/** @type {number} */
		var target;
		/** @type {AccelPlan} */
		var myPlan;

		var dofNames = filteredPose.getDOFNames();
		var transitionTime = 0;
		for (i = 0; i < dofNames.length; i++) {
			dofName = dofNames[i];
			currentPos = filteredPose.get(dofName, 0);
			currentVel = filteredPose.get(dofName, 1);
			target = targetPose.get(dofName, 0);

			myPlan = accelPlanner.computeWithFixedAccel(currentVel, 0, target - currentPos, accLimit);
			var thisDOFTime;
			if (myPlan && myPlan.isConsistent()) {
				thisDOFTime = myPlan.getTotalTime();
			} else {
				slog(channel, "PoseOffsetFilter(tt) for " + dofName + " got invalid plan, using backup time of 10! (currentVel:" + currentVel + ", target:" + target + ", currentPos:" + currentPos + ", acceLimit:" + accLimit + ")");
				thisDOFTime = 10; //should never happen, but still need to act...  choose large time.
			}
			if (thisDOFTime > transitionTime) {
				transitionTime = thisDOFTime;
			}
		}

		//console.log("Transition time:"+transitionTime);
		//transitionTime = 1;

		for (i = 0; i < dofNames.length; i++) {
			dofName = dofNames[i];
			currentPos = filteredPose.get(dofName, 0);
			currentVel = filteredPose.get(dofName, 1);
			target = targetPose.get(dofName, 0);

			if (transitionTime > epsilon) {
				myPlan = accelPlanner.computeWithFixedTime(currentVel, 0, target - currentPos, transitionTime);
				if (myPlan && myPlan.isConsistent()) {
					var displacement = myPlan.displacementAtTime(seconds);
					var newVelocity = myPlan.velocityAtTime(seconds);
					filteredPose.set(dofName, [currentPos + displacement, newVelocity]);
				} else {
					slog(channel, "PoseOffsetFilter(dp) for " + dofName + " got invalid plan, using backup filter! (currentVel:" + currentVel + ", target:" + target + ", currentPos:" + currentPos + ", transitionTime:" + transitionTime + ")");
					//should never happen, but still need to act...  filter towards target, deccelerate a bit.
					filteredPose.set(dofName, [currentPos * 0.99 + target * 0.01, currentVel * 0.96]);
				}
			} // else if time is less than epsilon, simply don't change anything
		}
	};

	this.resetToTarget = function () {
		filteredPose.setPose(targetPose);
	};

	/**
  * @param {Pose} newCurrentPose
  */
	this.resetToPose = function (newCurrentPose) {
		filteredPose.setPose(newCurrentPose);
		targetPose.setPose(newCurrentPose);
	};

	/**
  * @param {Pose} newTargetPose
  */
	this.setTarget = function (newTargetPose) {
		targetPose.setPose(newTargetPose);
	};

	/**
  * @param {Pose} inplacePose
  */
	this.getTarget = function (inplacePose) {
		inplacePose.setPose(targetPose);
	};

	/**
  * Get the current value of the filtered pose.
  * Only positions are set in inplacePose.
  *
  * @param {Pose} inplacePose
  */
	this.getValue = function (inplacePose) {
		//inplacePose.setPose(filteredPose);
		var dofNames = filteredPose.getDOFNames();
		for (var i = 0; i < dofNames.length; i++) {
			var dofName = dofNames[i];
			inplacePose.set(dofName, filteredPose.get(dofName, 0), 0);
		}
	};

	/**
  * Get the velocities of this filter, not accounting for the
  * motion due to incoming offsets (e.g., the offsets move the positions,
  * but do not affect these separately maintained velocities)
  *
  * @param {Pose} inplacePose - replace velocities in inplacePose with our pre-offset velocities
  */
	this.getPreOffsetVelocities = function (inplacePose) {
		var dofNames = filteredPose.getDOFNames();
		for (var i = 0; i < dofNames.length; i++) {
			var dofName = dofNames[i];
			inplacePose.set(dofName, filteredPose.get(dofName, 1), 1);
		}
	};

	/**
  * Set the threshold for rejecting deltas passed into applyUnfilteredOffset.
  * Deltas larger than this threshold will be clamped.
  *
  * @param {number} rejectDeltasGreaterThan
  */
	this.setRejectDeltaThreshold = function (rejectDeltasGreaterThan) {
		rejectionDeltaThreshold = rejectDeltasGreaterThan;
	};

	/**
  * Get the threshold for rejecting deltas passed into applyUnfilteredOffset.
  * Deltas larger than this threshold will be clamped.
  *
  * @return {number}
  */
	this.getRejectDeltaThreshold = function () {
		return rejectionDeltaThreshold;
	};

	this.setAcceleration = function (accel) {
		accLimit = accel;
	};

	/**
  * Apple deltaPose as a direct addition to existing filtered pose (position only).
  * Pose is applied directly without passing through any filtering.
  *
  * @param {Pose} deltaPose
  */
	this.applyUnfilteredOffset = function (deltaPose) {
		var dofNames = deltaPose.getDOFNames();
		for (var i = 0; i < dofNames.length; i++) {
			var dofName = dofNames[i];
			var dVal = deltaPose.get(dofName, 0);
			if (rejectionDeltaThreshold !== 0 && Math.abs(dVal) > rejectionDeltaThreshold) {
				slog(channel, "Clamping application of unfiltered offset of " + dVal + " to " + dofName + " as it is greater than " + rejectionDeltaThreshold);
				if (dVal < 0) {
					dVal = -rejectionDeltaThreshold;
				} else {
					dVal = rejectionDeltaThreshold;
				}
			}
			var fVal = filteredPose.get(dofName, 0);
			if (fVal !== null) {
				//it is also in the filtered pose
				fVal += dVal;
			}
			filteredPose.set(dofName, fVal, 0);
		}
	};
};

module.exports = PoseOffsetFilter;
//# sourceMappingURL=../../map/ifr-motion/lookat/PoseOffsetFilter.js.map
