/**
 * @author mattb
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var TimestampedBuffer = require("../base/TimestampedBuffer");
var MotionTrack = require("../base/MotionTrack");
var Motion = require("../base/Motion");
var MotionEvent = require("../base/MotionEvent");
var FileTools = require("../../ifr-core/FileTools");
var slog = require("../../ifr-core/SLog");

var channel = "MODEL_LOADING";

/**
 * @constructor
 */
var AnimationLoadResult = function AnimationLoadResult() {
	/** @type {string} */
	this.url = null;
	/** @type {!boolean} */
	this.success = false;
	/** @type {string} */
	this.message = "";

	/** @type {Motion} */
	this.motion = null;
	/** @type {Array.<string>} */
	this.defaultDOFNames = null;
	/** @type {Object.<string, Object.<number, string>>} */
	this.enumMaps = null;
	/** @type {MotionEvent[]} */
	this.events = null;
};

/**
 * @constructor
 */
var AnimationLoader = function AnimationLoader() {
	/** @type {AnimationLoadResult} */
	this._result = null;
	/** @type {boolean} */
	this.flattenEnums = true;
	/** @type {boolean} */
	this.resolvePaths = true;
};

/**
 * @return {AnimationLoadResult}
 */
AnimationLoader.prototype.getResult = function () {
	return this._result;
};

/**
 * @param {string} url
 * @param callback
 */
AnimationLoader.prototype.load = function (url, callback) {
	var self = this;
	FileTools.loadJSON(url, function (error, data) {
		if (error === null) {
			self.parseData(data, url);
			if (callback) {
				callback();
			}
		} else {
			var result = new AnimationLoadResult();
			result.url = url;
			result.success = false;
			result.message = error;
			self._result = result;
			if (callback) {
				callback();
			}
		}
	});
};

/**
 * @param {Object} jsonData
 * @param {string} dataUrl
 */
AnimationLoader.prototype.parseData = function (jsonData, dataUrl) {
	this._result = new AnimationLoadResult();
	this._result.url = dataUrl;

	if (jsonData.header.fileType !== "DOFAnimation" && jsonData.header.fileType !== "Animation") {
		this._result.success = false;
		this._result.message = "don't know how to handle file type: " + jsonData.header.fileType;
		return;
	}

	var animContent = jsonData.content;

	var motion = new Motion(animContent.name);
	for (var channelIndex = 0; channelIndex < animContent.channels.length; channelIndex++) {
		var channelData = animContent.channels[channelIndex];

		var sampleBuffer = new TimestampedBuffer();
		sampleBuffer.timestampList = channelData.times;
		sampleBuffer.dataList = channelData.values;

		var track = new MotionTrack(channelData.dofName, sampleBuffer, channelData.length);
		motion.addTrack(track);
	}
	this._result.motion = motion;

	if (animContent.defaultDOFs) {
		this._result.defaultDOFNames = animContent.defaultDOFs;
	}

	if (animContent.enumMaps) {
		this._result.enumMaps = {};
		for (var mapIndex = 0; mapIndex < animContent.enumMaps.length; mapIndex++) {
			var enumMapData = animContent.enumMaps[mapIndex];
			this._result.enumMaps[enumMapData.dofName] = enumMapData.values;
		}

		if (this.flattenEnums) {
			flattenEnums(this._result.motion, this._result.enumMaps);
		}
	}

	if (this.resolvePaths) {
		resolvePaths(this._result.motion, dataUrl);
	}

	if (animContent.events) {
		this._result.events = [];
		for (var eventIndex = 0; eventIndex < animContent.events.length; eventIndex++) {
			var eventData = animContent.events[eventIndex];
			if (eventData.time === undefined || eventData.time === null) {
				slog(channel, "AnimationLoader: skipping event with null or undefined time property");
			} else if (eventData.time < 0 || eventData.time > motion.getDuration()) {
				slog(channel, "AnimationLoader: skipping event with time property: " + eventData.time + " outside of animation bounds, animation duration = " + motion.getDuration());
			} else if (eventData.eventName === undefined || eventData.eventName === null || eventData.eventName === "") {
				slog(channel, "AnimationLoader: skipping event with empty, null, or undefined eventName property");
			} else if (typeof eventData.eventName !== "string") {
				slog(channel, "AnimationLoader: skipping event with non-string eventName property: " + eventData.eventName);
			} else {
				// event data ok!
				var payload = eventData.payload !== undefined ? eventData.payload : null;
				this._result.events.push(new MotionEvent(eventData.time, eventData.eventName, payload));
			}
		}

		// sort events by timestamp
		this._result.events.sort(function (eventA, eventB) {
			return eventA.getTimestamp() - eventB.getTimestamp();
		});
	}

	this._result.success = true;
};

/**
 * @param {Motion} motion
 * @param {Object.<string, Object.<number, string>>} enumMaps
 */
var flattenEnums = function flattenEnums(motion, enumMaps) {
	var tracks = motion.getTracks();
	var dofs = Object.keys(tracks);
	for (var dofIndex = 0; dofIndex < dofs.length; dofIndex++) {
		var dofName = dofs[dofIndex];
		if (enumMaps.hasOwnProperty(dofName)) {
			var samples = tracks[dofName].getMotionData().dataList;
			var enumMap = enumMaps[dofName];

			for (var sampleIndex = 0; sampleIndex < samples.length; sampleIndex++) {
				var sample = samples[sampleIndex];
				if (sample instanceof Array) {
					sample = sample[0];
				}

				if (typeof sample === "number") {
					var enumKey = Math.round(sample);
					samples[sampleIndex] = [enumMap[enumKey]];
					if (!enumMap.hasOwnProperty(enumKey)) {
						slog(channel, "AnimationLoader: no enum value specified for key: " + enumKey + ", DOF = " + dofName);
					}
				} else {
					slog(channel, "AnimationLoader: DOF " + dofName + " has an enum map, but found non-numerical value: " + sample);
				}
			}
		}
	}
};

/**
 * @param {Motion} motion
 * @param {string} dataUrl
 */
var resolvePaths = function resolvePaths(motion, dataUrl) {
	var parentDir = "";
	var slashIndex = dataUrl.lastIndexOf('/');
	var backslashIndex = dataUrl.lastIndexOf('\\');
	if (slashIndex !== -1 || backslashIndex !== -1) {
		var lastIndex = Math.max(slashIndex, backslashIndex);
		parentDir = dataUrl.substring(0, lastIndex + 1);
	}

	var tracks = motion.getTracks();
	var dofs = Object.keys(tracks);
	for (var dofIndex = 0; dofIndex < dofs.length; dofIndex++) {
		var dofName = dofs[dofIndex];
		var samples = tracks[dofName].getMotionData().dataList;
		var alreadyProcessedObjects = [];

		var firstSample = samples[0];
		if (firstSample instanceof Array) {
			firstSample = firstSample[0];
		}

		if (typeof firstSample === "string" || (typeof firstSample === "undefined" ? "undefined" : _typeof(firstSample)) === "object") {
			// string/object valued samples!

			for (var sampleIndex = 0; sampleIndex < samples.length; sampleIndex++) {
				var sample = samples[sampleIndex];
				if (sample instanceof Array) {
					sample = sample[0];
				}

				if (typeof sample === "string") {
					samples[sampleIndex] = [parentDir + sample];
				} else if ((typeof sample === "undefined" ? "undefined" : _typeof(sample)) === "object") {
					//only object we have is a texture+normal object
					//process url or textureURL (and normalURL if present)
					if (alreadyProcessedObjects.indexOf(sample) < 0) {
						if (typeof sample.textureURL === "string") {
							sample.textureURL = parentDir + sample.textureURL;
							if (typeof sample.normalURL === "string") {
								sample.normalURL = parentDir + sample.normalURL;
							}
							alreadyProcessedObjects.push(sample);
						} else {
							slog(channel, "AnimationLoader: DOF " + dofName + " had object-valued samples, but at least one (" + sampleIndex + ") is missing \"textureURL\" field");
						}
					}
				} else {
					slog(channel, "AnimationLoader: DOF " + dofName + " had string-valued samples, but also found non-string value: " + sample);
				}
			}
		}
	}
};

module.exports = AnimationLoader;
//# sourceMappingURL=../../map/ifr-motion/loaders/AnimationLoader.js.map
