/**
 * @author mattb
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var Motion = require("./Motion");
var MotionEvent = require("./MotionEvent");

/**
 * @param {Motion} motion
 * @param {MotionEvent[]} [events]
 * @constructor
 */
var AnnotatedMotion = function AnnotatedMotion(motion, events) {
	var rep = {};
	rep.motion = motion;
	events = events || [];
	rep.events = events;
	/** @type {number} */
	rep.speed = 1;
	/** @type {number} */
	rep.inPoint = 0;
	/** @type {number} */
	rep.outPoint = motion.getDuration();

	/**
  * @return {Motion}
  */
	this.getMotion = function () {
		return rep.motion;
	};

	/**
  * @return {number}
  */
	this.getEventCount = function () {
		return rep.events.length;
	};

	/**
  * @param {number} index
  * @return {MotionEvent}
  */
	this.getEvent = function (index) {
		return rep.events[index];
	};

	/**
  * @return {MotionEvent[]}
  */
	this.getEvents = function () {
		return rep.events;
	};

	/**
  * Set sub-clip bounds.  Times are in original time scale (rather than altered timescale resulting from setSpeed)
  * @param {number} inPoint - clip start time in seconds.  start from beginning if null/undefined
  * @param {number} outPoint - clip end time in seconds.  clip to end if null/undefined
  */
	this.setClipBounds = function (inPoint, outPoint) {
		if (inPoint !== null && inPoint !== undefined) {
			rep.inPoint = inPoint;
		} else {
			rep.inPoint = 0;
		}

		if (outPoint !== null && outPoint !== undefined) {
			rep.outPoint = outPoint;
		} else {
			rep.outPoint = this.getSourceMotionDuration();
		}
	};

	/**
  * Gets the duration, in seconds, of the source motion (unaffected by settings such as speed, etc).
  * @return {number}
  */
	this.getSourceMotionDuration = function () {
		return motion.getDuration();
	};

	/**
  * Gets the duration, in seconds, of this annotated motion given current settings (speed, etc).
  * @return {number}
  */
	this.getDuration = function () {
		var clipDuration = rep.outPoint - rep.inPoint;
		return clipDuration / rep.speed;
	};

	/**
  * @return {number}
  */
	this.getSpeed = function () {
		return rep.speed;
	};

	/**
  * Set the speed of this motion relative to the source motion.
  * @param {number} speed - speed modifier (2 means twice as fast as the source motion)
  */
	this.setSpeed = function (speed) {
		if (speed <= 0) {
			throw new Error("invalid speed: " + speed);
		}

		if (speed !== rep.speed) {
			rep.speed = speed;
			if (rep.speed === 1) {
				rep.motion = motion;
				rep.events = events;
			} else {
				var newMotion = new Motion(motion.getName());
				var trackKeys = Object.keys(motion.getTracks());
				for (var tki = 0; tki < trackKeys.length; tki++) {
					//duplicate each dof's track
					var newTrack = motion.getTracks()[trackKeys[tki]].clone();

					//grab the timestamps array from TimestampedBuffer
					var timestamps = newTrack.getMotionData().timestampList;
					for (var si = 0; si < timestamps.length; si++) {
						//modify each timestamp
						timestamps[si] = timestamps[si] / speed;
					}

					//modify total length
					newTrack.length = newTrack.length / speed;

					newMotion.addTrack(newTrack);
				}
				rep.motion = newMotion;

				var newEvents = [];
				for (var evi = 0; evi < events.length; evi++) {
					var newTimestamp = events[evi].getTimestamp() / speed;
					var eventName = events[evi].getEventName();
					var payload = events[evi].getPayload();
					newEvents.push(new MotionEvent(newTimestamp, eventName, payload));
				}
				rep.events = newEvents;
			}
		}
	};
};

module.exports = AnnotatedMotion;
//# sourceMappingURL=../../map/ifr-motion/base/AnnotatedMotion.js.map
