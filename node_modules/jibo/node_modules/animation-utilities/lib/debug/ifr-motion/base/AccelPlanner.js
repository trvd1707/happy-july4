/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var slog = require("../../ifr-core/SLog");
var channel = "ACCEL_PLANNER";

var AccelPlan = function AccelPlan(initialVelocity, targetVelocity, acceleration, accelerateTime, decelerateTime, totalTime, distance) {
	this._initialVelocity = initialVelocity;
	this._targetVelocity = targetVelocity;
	this._acceleration = acceleration;
	this._accelerateTime = accelerateTime;
	this._decelerateTime = decelerateTime;
	this._totalTime = totalTime;
	this._distance = distance;
};

AccelPlan.prototype.displacementAtTime = function (tDelta) {
	var newPosition = 0;
	if (tDelta > 0) {
		var useAccTime = Math.min(tDelta, this._accelerateTime);
		newPosition += (this._initialVelocity + this._acceleration * useAccTime / 2) * useAccTime;
		tDelta -= useAccTime;
	}
	if (tDelta > 0) {
		var useDecTime = Math.min(tDelta, this._decelerateTime);
		newPosition += (this._initialVelocity + this._acceleration * this._accelerateTime - this._acceleration * useDecTime / 2) * useDecTime;
		tDelta -= useDecTime;
	}
	if (tDelta > 0) {
		newPosition += this._targetVelocity * tDelta;
	}
	return newPosition;
};

AccelPlan.prototype.velocityAtTime = function (tDelta) {
	var newVelocity = this._initialVelocity;
	if (tDelta > 0) {
		var useAccTime = Math.min(tDelta, this._accelerateTime);
		newVelocity += this._acceleration * useAccTime;
		tDelta -= useAccTime;
	}
	if (tDelta > 0) {
		var useDecTime = Math.min(tDelta, this._decelerateTime);
		newVelocity -= this._acceleration * useDecTime;
		tDelta -= useDecTime;
	}

	return newVelocity;
};

AccelPlan.prototype.isConsistent = function () {

	if (isNaN(this._accelerateTime) || isNaN(this._decelerateTime)) {
		slog(channel, "Plan has NaN times! accelerationTime:" + this._accelerateTime + " decelerationTime:" + this._decelerateTime);
		return false;
	}

	if (!isFinite(this._accelerateTime) || !isFinite(this._decelerateTime)) {
		slog(channel, "Plan has non-finite times! accelerationTime:" + this._accelerateTime + " decelerationTime:" + this._decelerateTime);
		return false;
	}

	if (isNaN(this._acceleration)) {
		slog(channel, "Plan has NaN acceleration!: " + this._acceleration);
		return false;
	}

	if (!isFinite(this._acceleration)) {
		slog(channel, "Plan has non-finite acceleration!: " + this._acceleration);
		return false;
	}

	var totalTime = this._accelerateTime + this._decelerateTime;
	var targetDisplacement = this._distance + this._targetVelocity * totalTime;

	var ourDisplacement = (this._initialVelocity + this._acceleration * this._accelerateTime / 2) * this._accelerateTime + (this._initialVelocity + this._acceleration * this._accelerateTime - this._acceleration * this._decelerateTime / 2) * this._decelerateTime;

	var ourFinalV = this._initialVelocity + this._acceleration * this._accelerateTime - this._acceleration * this._decelerateTime;

	if (this._accelerateTime < 0 || this._decelerateTime < 0) {
		slog(channel, "Plan has negative times! accelerationTime:" + this._accelerateTime + " decelerationTime:" + this._decelerateTime);
		return false;
	}

	if (Math.abs(this._accelerateTime + this._decelerateTime - this._totalTime) > 0.0000001) {
		slog(channel, "Plan time segments are not equal to target time! segments:" + (this._accelerateTime + this._decelerateTime) + " target:" + this._totalTime);
		return false;
	}

	if (Math.abs(ourDisplacement - targetDisplacement) > 0.000001) {
		slog(channel, "Plan has incorrect integral! ourDisplacement:" + ourDisplacement + " pDelta:" + targetDisplacement);
		return false;
	}

	if (Math.abs(ourFinalV - this._targetVelocity) > 0.0000001) {
		slog(channel, "Plan has incorrect final velocity resultV:" + ourFinalV + " pDelta:" + this._targetVelocity);
		return false;
	}

	return true;
};

/**
 * @returns {number}
 */
AccelPlan.prototype.getTotalTime = function () {
	return this._totalTime;
};

var AccelPlanner = function AccelPlanner() {};

/**
 * Compute the acceleration needed to intercept a target moving at
 * vTarget and starting pDelta away from our initial velocity vCurrent
 * in time totalTime.  Acceleration is the free variable, time is fixed.
 *
 * @param {number} vCurrent
 * @param {number} vTarget
 * @param {number} pDelta
 * @param {number} totalTime
 * @returns {AccelPlan}
 */
AccelPlanner.prototype.computeWithFixedTime = function (vCurrent, vTarget, pDelta, totalTime) {
	//slog(channel, "Find (accel) plan for vTarget="+vTarget+" vCurrent="+vCurrent+" totalTime="+totalTime+" pDelta="+pDelta);

	if (totalTime < 0.0000000001) {
		slog(channel, "Asked for fixed time plan with time of " + totalTime + ", returning null");
		return null;
	}

	var aChoiceT1, aChoiceT2;

	var term1 = (vTarget - vCurrent) * totalTime / 2 + pDelta;
	var tosqrt = Math.pow((vCurrent - vTarget) * totalTime / 2 - pDelta, 2) - Math.pow(totalTime, 2) * (vTarget * vCurrent / 2 - Math.pow(vCurrent, 2) / 4 - Math.pow(vTarget, 2) / 4);

	if (tosqrt < 0) {
		if (tosqrt > -0.0000000001) {
			//could occasionally, when values are very borderline, be slightly below zero here in an otherwise ok condition
			tosqrt = 0;
		} else {
			slog(channel, "Inconsistent CWFT Plan for vCurrent:" + vCurrent + ", vTarget:" + vTarget + ", pDelta:" + pDelta + ", totalTime:" + totalTime + ", tsqrt:" + tosqrt);
			return null;
		}
	}

	var term2 = Math.sqrt(tosqrt);
	var term3 = Math.pow(totalTime, 2) / 2;

	var sign = 1;
	if (pDelta < 0.5 * totalTime * (vCurrent - vTarget)) {
		sign = -1;
	}

	var aChoice = (term1 + sign * term2) / term3;

	if (aChoice === 0) {
		//special handling if acceleration is zero, times are arbitrary
		aChoiceT1 = totalTime;
		aChoiceT2 = 0;
	} else if (Math.abs(aChoice) < 0.0000000001) {
		//if accel is so small, plan may be compromised numerically
		//also, plan can be approximated by doing nothing.
		aChoice = 0;
		aChoiceT1 = totalTime;
		aChoiceT2 = 0;
	} else {
		aChoiceT1 = totalTime / 2 + (vTarget - vCurrent) / (2 * aChoice);
		aChoiceT2 = totalTime / 2 + (vCurrent - vTarget) / (2 * aChoice);
	}

	if (aChoiceT1 < 0) {
		if (aChoiceT1 > -0.0000000001) {
			aChoiceT1 = 0;
		} else {
			slog(channel, "Inconsistent CWFTaT1 Plan for vCurrent:" + vCurrent + ", vTarget:" + vTarget + ", pDelta:" + pDelta + ", totalTime:" + totalTime + ", aChoiceT1:" + aChoiceT1);
			return null;
		}
	}
	if (aChoiceT2 < 0) {
		if (aChoiceT2 > -0.0000000001) {
			aChoiceT2 = 0;
		} else {
			slog(channel, "Inconsistent CWFTaT2 Plan for vCurrent:" + vCurrent + ", vTarget:" + vTarget + ", pDelta:" + pDelta + ", totalTime:" + totalTime + ", aChoiceT2:" + aChoiceT2);
			return null;
		}
	}

	var accelPlan = new AccelPlan(vCurrent, vTarget, aChoice, aChoiceT1, aChoiceT2, totalTime, pDelta);
	return accelPlan;
};

/**
 *
 * @param {number} vCurrent
 * @param {number} vTarget
 * @param {number} pDelta
 * @param {number} acceleration
 * @returns {AccelPlan}
 */
AccelPlanner.prototype.computeWithFixedAccel = function (vCurrent, vTarget, pDelta, acceleration) {
	//slog(channel, "Find (time) plan for vTarget="+vTarget+" vCurrent="+vCurrent+" acceleration="+acceleration+" pDelta="+pDelta);

	//var plans = [];

	//if we go positive first, the smallest distance we can travel
	//is to go straight to the target velocity
	// (zero t2 in +deltaV cases, zero t1 in -deltaV cases)
	// thus if we need less distance than this path, we need -a

	if (acceleration < 0.0000000001) {
		slog(channel, "Asked for fixed acceleration plan with acceleration of " + acceleration + ", returning null");
		return null;
	}

	var useAcceleration = acceleration;
	var useSign = 1;

	//var timeToReachTargetVelocity = Math.abs((vTarget - vCurrent)/acceleration);
	//var distanceTraveled = (vTarget + vCurrent)/2 * timeToReachTargetVelocity;
	//var needToCoverDistance = pDelta + vTarget * timeToReachTargetVelocity;
	//
	//if(distanceTraveled > needToCoverDistance){
	//	useAcceleration = -acceleration;
	//}

	//simplified

	if ((vCurrent - vTarget) * Math.abs(vTarget - vCurrent) / (2 * acceleration) > pDelta) {
		useAcceleration = -acceleration;
		useSign = -1;
	}

	var term1 = 2 * vTarget - 2 * vCurrent;
	var tosqrt = 2 * Math.pow(vCurrent - vTarget, 2) + 4 * useAcceleration * pDelta;

	if (tosqrt < 0) {
		if (tosqrt > -0.0000000001) {
			//can occasionally, when values are very borderline, be slightly below zero here in an otherwise ok condition
			//e.g., vCurrent = -0.3385816504064119, vTarget = 0, pDelta = -0.019106255665321623, acceleration = 3
			tosqrt = 0;
		} else {
			slog(channel, "Inconsistent CWFA Plan for vCurrent:" + vCurrent + ", vTarget:" + vTarget + ", pDelta:" + pDelta + ", acceleration:" + acceleration + ", tsqrt:" + tosqrt);
			return null;
		}
	}

	var term2 = Math.sqrt(tosqrt);
	var term3 = 2 * useAcceleration;

	var time1Choice = (term1 + useSign * term2) / term3;
	var time2Choice = vCurrent / useAcceleration + time1Choice - vTarget / useAcceleration;

	if (time1Choice < 0) {
		if (time1Choice > -0.0000000001) {
			time1Choice = 0;
		} else {
			slog(channel, "Inconsistent CWFAt1 Plan for vCurrent:" + vCurrent + ", vTarget:" + vTarget + ", pDelta:" + pDelta + ", acceleration:" + acceleration + ", t1Choice:" + time1Choice);
			return null;
		}
	}
	if (time2Choice < 0) {
		if (time2Choice > -0.0000000001) {
			time2Choice = 0;
		} else {
			slog(channel, "Inconsistent CWFAt2 Plan for vCurrent:" + vCurrent + ", vTarget:" + vTarget + ", pDelta:" + pDelta + ", acceleration:" + acceleration + ", t2Choice:" + time2Choice);
			return null;
		}
	}

	return new AccelPlan(vCurrent, vTarget, useAcceleration, time1Choice, time2Choice, time1Choice + time2Choice, pDelta);
};

/**
 * Simple plan where we go at a constant speed for degenerate cases etc.
 * @param vCurrent speed to go at
 * @returns {AccelPlan} plan to go at constant speed with zero accel.  plan length is 1
 */
AccelPlanner.prototype.computeWithZeroAccel = function (vCurrent) {
	var accelPlan = new AccelPlan(vCurrent, vCurrent, 0, 1, 0, 1, 0);
	return accelPlan;
};

AccelPlanner.prototype.computeWithMaxAccel = function (vCurrent, vTarget, pDelta, maxAcceleration, targetInterceptTime) {
	if (maxAcceleration < 0.000001) {
		return this.computeWithZeroAccel(vCurrent);
	}
	var fixedTimePlan = this.computeWithFixedTime(vCurrent, vTarget, pDelta, targetInterceptTime);
	if (Math.abs(fixedTimePlan._acceleration) <= maxAcceleration) {
		return fixedTimePlan;
	} else {
		var fixedAccelPlan = this.computeWithFixedAccel(vCurrent, vTarget, pDelta, maxAcceleration);
		return fixedAccelPlan;
	}
};

module.exports = AccelPlanner;
//# sourceMappingURL=../../map/ifr-motion/base/AccelPlanner.js.map
