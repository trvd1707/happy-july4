/**
 * @author mattb
 * Copyright 2014 IF Robots LLC
 */

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ModelControl = require("./ModelControl");
var ModelControlFactory = require("./ModelControlFactory");
var CachedImageLoader = require("../../ifr-geometry/loaders/CachedImageLoader");
var THREE = require("three");
var slog = require("../../ifr-core/SLog");

/**
 * @constructor
 * @extends ModelControl
 */
var TextureControl = function TextureControl() {
	ModelControl.call(this);

	/** @type {string} */
	this._meshName = null;

	/** @type {THREE.Mesh} */
	this._mesh = null;

	/** @type {THREE.Texture} */
	this._texture = new THREE.Texture();
	this._texture.minFilter = THREE.LinearFilter;

	/** @type {THREE.Texture} */
	this._normal = new THREE.Texture();

	/** @type {THREE.DataTexture} */
	this._blankTexture = new THREE.DataTexture(new Uint8Array(2 * 2 * 4), 2, 2);
	this._blankTexture.minFilter = THREE.LinearFilter;

	/** @type {CachedImageLoader} */
	this._imageLoader = null;

	/** @type {string} */
	this._defaultNormalURL = null;

	/** @type {ColorControl} */
	this._colorControl = null;

	/** @type {boolean} */
	this._billboardMode = true;
};

TextureControl.prototype = Object.create(ModelControl.prototype);
TextureControl.prototype.constructor = TextureControl;
TextureControl.prototype._controlType = "TEXTURE";

/**
 * @param {Object} jsonData
 */
TextureControl.prototype.setFromJson = function (jsonData) {
	ModelControl.prototype.setFromJson.call(this, jsonData);

	this._dofNames.push(jsonData.dofName);
	this._meshName = jsonData.meshName;
};

/**
 * @param {CachedImageLoader} imageLoader
 */
TextureControl.prototype.setImageLoader = function (imageLoader) {
	this._imageLoader = imageLoader;
};

/**
 * @param {string} normalURL
 */
TextureControl.prototype.setDefaultNormalURL = function (normalURL) {
	this._defaultNormalURL = normalURL;
};

/**
 * call once after a new mesh is attached to set colors for current render mode,
 * and cache original colors to be restored
 */
function initMesh() {
	//save the specular value in the mesh itself.  this way it will be preserved
	//to be re-enabled even if a new TextureControl is attached.
	if (this._mesh.material._specular_disabled == null) {
		//null or undefined (eqnull)
		this._mesh.material._specular_disabled = new THREE.Color(this._mesh.material.specular);
	}
	if (this._billboardMode) {
		this._mesh.material.ambient.setRGB(0, 0, 0);
		this._mesh.material.specular.setRGB(0, 0, 0);
	} else {
		this._mesh.material.ambient.setRGB(1, 1, 1);
		//restore original specular
		this._mesh.material.specular.set(this._mesh.material._specular_disabled);
	}
}

/**
 * @param {Object.<string, THREE.Object3D>} modelMap
 * @return {!boolean}
 */
TextureControl.prototype.attachToModel = function (modelMap) {
	this._mesh = null;

	if (modelMap != null && modelMap.hasOwnProperty(this._meshName)) {
		this._mesh = modelMap[this._meshName];
		initMesh.call(this);
		return true;
	} else {
		return false;
	}
};

/**
 * Called once when control list is assigned to a group, used by controls
 * which need to make links amongst themselves.
 * @param {ModelControlGroup} controlGroup
 */
ModelControl.prototype.attachToControlGroup = function (controlGroup) {
	/** @type {ModelControl[]} */
	var controlList = controlGroup.getControlList();
	this._colorControl = null;
	//connect to a ColorControl that contains our mesh.
	for (var i = 0; i < controlList.length; i++) {
		if (controlList[i].getControlType() === "COLOR") {
			var colorMeshNames = controlList[i]._meshNames;
			for (var j = 0; j < colorMeshNames.length; j++) {
				if (colorMeshNames[j] === this._meshName) {
					this._colorControl = controlList[i];
					break;
				}
			}
		}
		if (this._colorControl !== null) {
			break;
		}
	}
};

/**
 *
 * @param {boolean} billboardMode
 */
function setBillboardMode(billboardMode) {
	if (this._colorControl !== null) {
		this._colorControl.setBillboardMode(billboardMode);
	}
	if (billboardMode !== this._billboardMode) {
		if (this._meshes !== null) {
			//color control will handle emissive/diffuse
			//we must handle ambient
			if (billboardMode) {
				this._mesh.material.ambient.setRGB(0, 0, 0);
				this._mesh.material.specular.setRGB(0, 0, 0);
			} else {
				this._mesh.material.ambient.setRGB(1, 1, 1);
				this._mesh.material.specular.set(this._mesh.material._specular_disabled); //stored here by initMesh
			}
		}
		this._billboardMode = billboardMode;
	}
}

/**
 * @param {number|string} dofValue
 * @return {!boolean}
 */
function updateFromDOFVal(dofValue) {
	if (typeof dofValue === "string") {
		setBillboardMode.call(this, true); //fallback mode, string only, choose billboard
		this.setTextureFromURL(dofValue);
		return true;
	} else if ((typeof dofValue === "undefined" ? "undefined" : _typeof(dofValue)) === "object") {
		var url = dofValue.textureURL;
		var useNormals = dofValue.useNormals;
		var normalURL = dofValue.normalURL;
		if (useNormals == null) {
			//null or undefined (eqnull)
			if (normalURL == null) {
				//neither key set, no normals
				useNormals = false;
			} else {
				//useNormals missing, but normalURL present, use normals
				useNormals = true;
			}
		}

		if (useNormals === true && normalURL == null) {
			normalURL = this._defaultNormalURL;
		}

		if (useNormals === true) {
			this.setNormalFromURL(normalURL);
		}

		setBillboardMode.call(this, !useNormals);

		if (url == null) {
			//null or undefined (eqnull)
			slog.error("Value for DOF " + this._dofNames[0] + " is object, but did not contain field \"textureURL\"");
		} else {
			this.setTextureFromURL(url);
		}
	} else if (typeof dofValue === "number") {
		slog.error("TextureControl for DOF " + this._dofNames[0] + ": numerical values (image indices) are no longer supported, use full image URL instead");
		return false;
	} else {
		return false;
	}
}

/**
 * @param {Object.<string, Object>} dofValues
 * @return {!boolean}
 */
TextureControl.prototype.updateFromDOFValues = function (dofValues) {
	if (this._mesh && dofValues.hasOwnProperty(this._dofNames[0])) {
		var dofValue = dofValues[this._dofNames[0]];
		return updateFromDOFVal.call(this, dofValue);
	} else {
		return false;
	}
};

/**
 * @param {Pose} pose
 * @return {!boolean}
 */
TextureControl.prototype.updateFromPose = function (pose) {
	var dofValue = pose.get(this._dofNames[0], 0);
	if (this._mesh && dofValue != null) //null or undefined (eqnull)
		{
			return updateFromDOFVal.call(this, dofValue);
		} else {
		return false;
	}
};

/**
 * @param {string} imageURL
 * @private
 */
TextureControl.prototype.setTextureFromURL = function (imageURL) {
	if (this._mesh && this._texture.sourceFile !== imageURL) {
		this._texture.sourceFile = imageURL;

		this._blankTexture.needsUpdate = true;
		this._mesh.material.map = this._blankTexture;

		var self = this;
		this._imageLoader.loadImage(imageURL, function () {
			var result = self._imageLoader.getResult();
			if (result.success && result.url === self._texture.sourceFile) {
				self._texture.image = result.image;
				self._texture.needsUpdate = true;
				self._mesh.material.map = self._texture;
			} else if (!result.success) {
				slog.error("TextureControl for DOF " + self._dofNames[0] + ": image load failed, URL = " + result.url);
			}
		});
	}
};

/**
 * @param {string} normalURL
 * @private
 */
TextureControl.prototype.setNormalFromURL = function (normalURL) {
	if (this._mesh && this._normal.sourceFile !== normalURL) {
		this._normal.sourceFile = normalURL;

		//this._blankTexture.needsUpdate = true;
		//this._mesh.material.map = this._blankTexture;

		var self = this;
		this._imageLoader.loadImage(normalURL, function () {
			var result = self._imageLoader.getResult();
			if (result.success && result.url === self._normal.sourceFile) {
				self._normal.image = result.image;
				self._normal.needsUpdate = true;
				if (self._mesh.material.normalMap == null) {
					self._mesh.material.needsUpdate = true;
				}
				self._mesh.material.normalMap = self._normal;
			} else if (!result.success) {
				slog.error("TextureControl for DOF " + self._dofNames[0] + ": normal load failed, URL = " + result.url);
			}
		});
	}
};

/**
 * Creates a copy of this dof, or fills in this dof's data to the provided
 * argument (to allow type to be defined by subclass's getCopy).
 *
 * @param {TextureControl} copyInto - optional object to copy into
 * @return {TextureControl} copy of this dof, not attached to any model
 * @override
 */
TextureControl.prototype.getCopy = function (copyInto) {
	if (!copyInto) {
		copyInto = new TextureControl();
	}
	ModelControl.prototype.getCopy.call(this, copyInto);

	copyInto._meshName = this._meshName;

	copyInto._texture = this._texture ? this._texture.clone() : null;

	copyInto._imageLoader = this._imageLoader;

	copyInto._defaultNormalURL = this._defaultNormalURL;

	return copyInto;
};

/**
 * @constructor
 */
TextureControl.Factory = function () {
	/** @type {CachedImageLoader} */
	this._sharedImageLoader = new CachedImageLoader();
};

TextureControl.Factory.prototype = Object.create(ModelControlFactory.prototype);
TextureControl.Factory.prototype.constructor = TextureControl.Factory;
TextureControl.Factory.prototype._controlType = TextureControl.prototype._controlType;
TextureControl.Factory.prototype._controlConstructor = TextureControl;

/**
 * @param {CachedImageLoader} sharedImageLoader
 */
TextureControl.Factory.prototype.setSharedImageLoader = function (sharedImageLoader) {
	this._sharedImageLoader = sharedImageLoader;
};

/**
 * @param {Object} jsonData
 * @return {ModelControl}
 */
TextureControl.Factory.prototype.constructFromJson = function (jsonData) {
	/** @type {TextureControl} */
	var textureControl = ModelControlFactory.prototype.constructFromJson.call(this, jsonData);
	if (textureControl) {
		textureControl.setImageLoader(this._sharedImageLoader);
	}
	return textureControl;
};

module.exports = TextureControl;
//# sourceMappingURL=../../map/ifr-motion/dofs/TextureControl.js.map
