/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

/**
 *
 * @param {ModelControlGroup} modelControlGroup
 * @param {THREE.Object3D} hierarchyRoot
 * @constructor
 */

var KinematicGroup = function KinematicGroup(modelControlGroup, hierarchyRoot) {
	this._modelControlGroup = modelControlGroup;
	this._hierarchyRoot = hierarchyRoot;

	/** @type {Object<string, THREE.Object3D>} */
	this._modelMap = null;
};

/**
 * Copy tree, but only nodes in map.  Assumes that "node" is in map
 *
 * @param node
 * @param {Object.<string,boolean>} includeNamesMap - map of boolean values, true to include.  assumed to be continuous and touch root.
 */
var copyTree = function copyTree(node, includeNamesMap) {
	var n = node.clone(undefined, false);
	for (var i = 0; i < node.children.length; i++) {
		var c = node.children[i];
		if (c.name != null && includeNamesMap[c.name]) {
			n.add(copyTree(c, includeNamesMap));
		}
	}
	return n;
};

var printTree = function printTree(node, tabs) {
	if (tabs == null) {
		tabs = "";
	}
	console.log(tabs + node.name);
	for (var i = 0; i < node.children.length; i++) {
		printTree(node.children[i], tabs + "\t");
	}
};

/**
 * Get a copy of this KinematicGroup, including a copy of the transform hierarchy and a copy of the ModelControls,
 * bound to the new hierarchy.  If requiredTransforms is present, the copy will include a sub-tree of the original
 * hierarchy, with only transforms required to connect the required transforms to the root.  Only ModelControls
 * associated with those branches will be included.
 *
 * If kinematicOnly is true, the copy will only include controls that are associated with the motion of transforms,
 * not any render-only controls (e.g, texture, color, etc.).
 *
 * @param {string[]} [requiredTransforms] - if present, only include chains connecting root to required transforms
 * @param {boolean} [kinematicOnly=true] - if true, only include ModelControls that represent kinematic motions
 * @returns {KinematicGroup}
 */
KinematicGroup.prototype.getCopy = function (requiredTransforms, kinematicOnly) {
	// eslint-disable-line no-unused-vars
	//TODO: support requiredTransforms and kinematicOnly
	//TODO: get meshes out of here!

	var copiedHierarchy;

	if (requiredTransforms != null && this._hierarchyRoot != null) {
		var toInclude = {};
		var modelMap = this.getModelMap();
		for (var i = 0; i < requiredTransforms.length; i++) {
			var t = modelMap[requiredTransforms[i]];
			while (t != null) {
				if (!toInclude.hasOwnProperty(t.name)) {
					toInclude[t.name] = true;
					t = t.parent;
				} else {
					t = null; //met up with already traversed root
				}
			}
		}
		if (toInclude[this._hierarchyRoot.name]) {
			copiedHierarchy = copyTree(this._hierarchyRoot, toInclude);
		} else {
			console.log("Warning, none of required dofs (" + (requiredTransforms == null ? "null" : requiredTransforms.toString()) + ")present in hierarchy!");
			copiedHierarchy = null;
		}
	} else {
		copiedHierarchy = this._hierarchyRoot ? this._hierarchyRoot.clone() : null;
	}
	var copiedGroup = this._modelControlGroup ? this._modelControlGroup.getCopy() : null;
	copiedGroup.attachToModelAndPrune(copiedHierarchy);
	//if(requiredTransforms!=null) {
	//	console.log("MADE TREE! for trans " + requiredTransforms.toString());
	//	printTree(copiedHierarchy);
	//}
	return new KinematicGroup(copiedGroup, copiedHierarchy);
};

/**
 *
 * @param {Pose} inplacePose
 * @return {Pose}
 */
KinematicGroup.prototype.getPose = function (inplacePose) {// eslint-disable-line no-unused-vars

};

/**
 *
 * @param {Pose} pose
 */
KinematicGroup.prototype.setFromPose = function (pose) {
	this._modelControlGroup.updateFromPose(pose);
};

/**
 * @return {string[]}
 */
KinematicGroup.prototype.getDOFNames = function () {
	return this._modelControlGroup.getDOFNames();
};

/**
 * @return {ModelControlGroup}
 */
KinematicGroup.prototype.getModelControlGroup = function () {
	return this._modelControlGroup;
};

/**
 * @return {THREE.Object3D}
 */
KinematicGroup.prototype.getRoot = function () {
	return this._hierarchyRoot;
};

/**
 * @param {THREE.Vector3} hierarchyRoot
 * @returns {Object.<string, THREE.Object3D>}
 */
KinematicGroup.generateTransformMap = function (hierarchyRoot) {
	/** @type {Object.<string, THREE.Object3D>} */
	var modelMap = {};

	// flatten model tree
	/** @type {Array.<THREE.Object3D>} */
	var nodesToVisit = [hierarchyRoot];
	while (nodesToVisit.length > 0) {
		var node = nodesToVisit.shift();
		if (node.name) {
			modelMap[node.name] = node;
		}
		if (node.children) {
			for (var c = 0; c < node.children.length; c++) {
				nodesToVisit.push(node.children[c]);
			}
		}
	}
	return modelMap;
};

/**
 * @return {Object<string, THREE.Object3D>}
 */
KinematicGroup.prototype.getModelMap = function () {
	if (!this._modelMap) {
		this._modelMap = KinematicGroup.generateTransformMap(this._hierarchyRoot);
	}
	return this._modelMap;
};

/**
 * @param {string} transformName
 * @return {THREE.Object3D}
 */
KinematicGroup.prototype.getTransform = function (transformName) {
	if (!this._modelMap) {
		this._modelMap = KinematicGroup.generateTransformMap(this._hierarchyRoot);
	}
	return this._modelMap[transformName];
};

module.exports = KinematicGroup;
//# sourceMappingURL=../../map/ifr-motion/dofs/KinematicGroup.js.map
