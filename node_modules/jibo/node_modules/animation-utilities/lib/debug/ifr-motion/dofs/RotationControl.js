/**
 * @author mattb
 * Copyright 2014 IF Robots LLC
 */

"use strict";

var ModelControl = require("./ModelControl");
var ModelControlFactory = require("./ModelControlFactory");
var BasicFrame = require("../../ifr-geometry/BasicFrame");
var THREE = require("three");

/**
 * @constructor
 * @extends ModelControl
 */
var RotationControl = function RotationControl() {
	ModelControl.call(this);

	/** @type {string} */
	this._skeletonFrameName = null;

	/** @type {THREE.Vector3} */
	this._rotationalAxis = new THREE.Vector3();
	/** @type {THREE.Quaternion} */
	this._initialRotation = new THREE.Quaternion();

	/** @type {number} */
	this._min = null;
	/** @type {number} */
	this._max = null;

	/** @type {boolean} */
	this._isCyclic = false;

	/** @type {THREE.Object3D} */
	this._skeletonFrame = null;
};

RotationControl.prototype = Object.create(ModelControl.prototype);
RotationControl.prototype.constructor = RotationControl;
RotationControl.prototype._controlType = "ROTATION";

/**
 * @param {Object} jsonData
 * @override
 */
RotationControl.prototype.setFromJson = function (jsonData) {
	ModelControl.prototype.setFromJson.call(this, jsonData);

	this._dofNames.push(jsonData.dofName);
	this._skeletonFrameName = jsonData.skeletonFrameName;
	this._rotationalAxis.copy(BasicFrame.vector3FromJson(jsonData.xyzRotationAxis));
	this._initialRotation.copy(BasicFrame.quaternionFromJson(jsonData.wxyzQuatInitialRotation));
	this._min = jsonData.min;
	this._max = jsonData.max;
	this._isCyclic = jsonData.isCyclic | false;
};

/**
 * @param {Object.<string, THREE.Object3D>} modelMap
 * @return {!boolean}
 * @override
 */
RotationControl.prototype.attachToModel = function (modelMap) {
	this._skeletonFrame = null;

	if (modelMap != null && modelMap.hasOwnProperty(this._skeletonFrameName)) {
		this._skeletonFrame = modelMap[this._skeletonFrameName];
		return true;
	} else {
		return false;
	}
};

/**
 * @param {number} dofValue
 */
function updateFromDOFVal(dofValue) {
	//dofValue = THREE.Math.clamp(dofValue, this._min, this._max);
	var rotationAroundAxis = new THREE.Quaternion().setFromAxisAngle(this._rotationalAxis, dofValue);
	this._skeletonFrame.quaternion.multiplyQuaternions(this._initialRotation, rotationAroundAxis);
}

/**
 * @param {Object.<string, Object>} dofValues
 * @return {!boolean}
 * @override
 */
RotationControl.prototype.updateFromDOFValues = function (dofValues) {
	if (this._skeletonFrame && dofValues.hasOwnProperty(this._dofNames[0])) {
		var dofValue = dofValues[this._dofNames[0]];

		updateFromDOFVal.call(this, dofValue);

		return true;
	} else {
		return false;
	}
};

/**
 * @param {Pose} pose
 * @return {!boolean}
 * @override
 */
RotationControl.prototype.updateFromPose = function (pose) {
	var dofValue = pose.get(this._dofNames[0], 0);
	if (this._skeletonFrame && dofValue != null) //null or undefined (eqnull)
		{
			updateFromDOFVal.call(this, dofValue);
			return true;
		} else {
		return false;
	}
};

/**
 * @param {THREE.Vector3 } inplaceVector3 - new vector will be created if null or omitted
 * @return {!THREE.Vector3} the rotational axis.  will be === inplaceVector3 if provided
 */
RotationControl.prototype.getRotationalAxis = function (inplaceVector3) {
	if (inplaceVector3 == null) {
		//null or undefined (eqnull)
		inplaceVector3 = new THREE.Vector3();
	}
	return inplaceVector3.copy(this._rotationalAxis);
};

/**
 * @param {THREE.Quaternion } inplaceQuaternion - new vector will be created if null or omitted
 * @return {!THREE.Quaternion} the initial rotation.  will be === inplaceQuaternion if provided
 */
RotationControl.prototype.getInitialRotation = function (inplaceQuaternion) {
	if (inplaceQuaternion == null) {
		//null or undefined (eqnull)
		inplaceQuaternion = new THREE.Quaternion();
	}
	return inplaceQuaternion.copy(this._initialRotation);
};

/**
 * @returns {number}
 */
RotationControl.prototype.getMin = function () {
	return this._min;
};

/**
 * @returns {number}
 */
RotationControl.prototype.getMax = function () {
	return this._max;
};

/**
 * @returns {boolean}
 */
RotationControl.prototype.isCyclic = function () {
	return this._isCyclic;
};

/**
 * Creates a copy of this dof, or fills in this dof's data to the provided
 * argument (to allow type to be defined by subclass's getCopy).
 *
 * @param {RotationControl} copyInto - optional object to copy into
 * @return {RotationControl} copy of this dof, not attached to any model
 * @override
 */
RotationControl.prototype.getCopy = function (copyInto) {
	if (!copyInto) {
		copyInto = new RotationControl();
	}

	ModelControl.prototype.getCopy.call(this, copyInto);

	copyInto._skeletonFrameName = this._skeletonFrameName;

	copyInto._rotationalAxis = this._rotationalAxis ? this._rotationalAxis.clone() : null;

	copyInto._initialRotation = this._initialRotation ? this._initialRotation.clone() : null;

	copyInto._min = this._min;

	copyInto._max = this._max;

	copyInto._isCyclic = this._isCyclic;

	return copyInto;
};

/**
 ** @returns {string}
 */
RotationControl.prototype.getTransformName = function () {
	return this._skeletonFrameName;
};

/**
 * @return {Array.<string>}
 * @override
 */
RotationControl.prototype.getTransformNames = function () {
	return [this.getTransformName()];
};

/**
 * @constructor
 */
RotationControl.Factory = function () {};

RotationControl.Factory.prototype = Object.create(ModelControlFactory.prototype);
RotationControl.Factory.prototype.constructor = RotationControl.Factory;
RotationControl.Factory.prototype._controlType = RotationControl.prototype._controlType;
RotationControl.Factory.prototype._controlConstructor = RotationControl;

module.exports = RotationControl;
//# sourceMappingURL=../../map/ifr-motion/dofs/RotationControl.js.map
