/**
 * @author mattb
 * Copyright 2014 IF Robots LLC
 */

"use strict";

var KinematicGroup = require("./KinematicGroup");
var DOFInfo = require("./DOFInfo");

/**
 * @constructor
 */
var ModelControlGroup = function ModelControlGroup() {
	/** @type {Array.<ModelControl>} */
	this._controlList = [];
	/** @type {string[]} */
	this._dofNames = [];
	/** @type {Object.<string, ModelControl>} */
	this._dofNameToControlMap = {};
	/** @type {Object.<string, DOFInfo>} */
	this._dofInfos = {};
};

/**
 * @param {Array.<ModelControl>} controlList
 */
ModelControlGroup.prototype.setControlList = function (controlList) {
	var controlIndex;

	this._controlList = controlList;
	this._dofNames = [];
	this._dofNameToControlMap = {};
	this._dofInfos = {};

	for (controlIndex = 0; controlIndex < this._controlList.length; controlIndex++) {
		var modelControl = this._controlList[controlIndex];
		var dofNames = modelControl.getDOFNames();

		for (var dofIndex = 0; dofIndex < dofNames.length; dofIndex++) {
			this._dofNames.push(dofNames[dofIndex]);
			this._dofNameToControlMap[dofNames[dofIndex]] = modelControl;
			this._dofInfos[dofNames[dofIndex]] = new DOFInfo(dofNames[dofIndex], modelControl);
		}
	}

	for (controlIndex = 0; controlIndex < this._controlList.length; controlIndex++) {
		this._controlList[controlIndex].attachToControlGroup(this);
	}
};

/**
 * @return {Array.<ModelControl>}
 */
ModelControlGroup.prototype.getControlList = function () {
	return this._controlList;
};

/**
 * @return {string[]}
 */
ModelControlGroup.prototype.getDOFNames = function () {
	return this._dofNames;
};

/**
 * @param {string} dofName
 * @return {ModelControl}
 */
ModelControlGroup.prototype.getControlForDOF = function (dofName) {
	return this._dofNameToControlMap[dofName];
};

/**
 * @param {string} dofName
 * @return {DOFInfo}
 */
ModelControlGroup.prototype.getDOFInfo = function (dofName) {
	return this._dofInfos[dofName];
};

/**
 * @param {THREE.Object3D} modelRoot
 * @return {!boolean}
 */
ModelControlGroup.prototype.attachToModel = function (modelRoot) {
	/** @type {Object.<string, THREE.Object3D>} */
	var modelMap = KinematicGroup.generateTransformMap(modelRoot);

	// flatten model tree
	///** @type {Array.<THREE.Object3D>} */
	//var nodesToVisit = [modelRoot];
	//while (nodesToVisit.length > 0)
	//{
	//	var node = nodesToVisit.shift();
	//	if (node.name)
	//	{
	//		modelMap[node.name] = node;
	//	}
	//	if (node.children)
	//	{
	//		for (var c=0; c<node.children.length; c++)
	//		{
	//			nodesToVisit.push(node.children[c]);
	//		}
	//	}
	//}

	var attachedAll = true;
	for (var controlIndex = 0; controlIndex < this._controlList.length; controlIndex++) {
		var attached = this._controlList[controlIndex].attachToModel(modelMap);
		if (!attached) {
			attachedAll = false;
			console.warn("failed to attach model control: " + this._controlList[controlIndex].getDescriptiveName());
		}
	}

	return attachedAll;
};

/**
 * @param {THREE.Object3D} modelRoot
 */
ModelControlGroup.prototype.attachToModelAndPrune = function (modelRoot) {
	/** @type {Object.<string, THREE.Object3D>} */
	var modelMap = KinematicGroup.generateTransformMap(modelRoot);

	this.setControlList(this._controlList.filter(function (control) {
		return control.attachToModel(modelMap);
	}));
};

/**
 * @param {Object.<string, Object>} dofValues
 * @return {!boolean}
 */
ModelControlGroup.prototype.updateFromDOFValues = function (dofValues) {
	var updatedAll = true;
	for (var controlIndex = 0; controlIndex < this._controlList.length; controlIndex++) {
		var updated = this._controlList[controlIndex].updateFromDOFValues(dofValues);
		if (!updated) {
			updatedAll = false;
		}
	}

	return updatedAll;
};

/**
 * @param {Pose} pose
 * @return {!boolean}
 */
ModelControlGroup.prototype.updateFromPose = function (pose) {
	var updatedAll = true;
	for (var controlIndex = 0; controlIndex < this._controlList.length; controlIndex++) {
		var updated = this._controlList[controlIndex].updateFromPose(pose);
		if (!updated) {
			updatedAll = false;
		}
	}
	return updatedAll;
};

/**
 * @param {string[]} dofNames
 * @return {string[]}
 */
ModelControlGroup.prototype.getRequiredTransformNamesForDOFs = function (dofNames) {
	if (dofNames === null) {
		return null;
	}
	var r = [];
	for (var i = 0; i < dofNames.length; i++) {
		var control = this.getControlForDOF(dofNames[i]);
		var transformNames = control.getTransformNames();
		if (transformNames != null) {
			for (var j = 0; j < transformNames.length; j++) {
				r.push(transformNames[j]);
			}
		}
	}
	return r;
};

/**
 * @param {Pose} inplacePose
 * @return {!boolean}
 */
ModelControlGroup.prototype.getPose = function (inplacePose) // eslint-disable-line no-unused-vars
{
	//TODO
};

/**
 * Get a copy of this group, differing only in that it will by unbound to any model.
 * @returns {ModelControlGroup}
 */
ModelControlGroup.prototype.getCopy = function () {
	if (this._controlList == null) {
		return new ModelControlGroup();
	} else {
		var controlsCopy = [this._controlList.length];
		for (var i = 0; i < this._controlList.length; i++) {
			controlsCopy[i] = this._controlList[i].getCopy(null);
		}
		var groupCopy = new ModelControlGroup();
		groupCopy.setControlList(controlsCopy);
		return groupCopy;
	}
};

module.exports = ModelControlGroup;
//# sourceMappingURL=../../map/ifr-motion/dofs/ModelControlGroup.js.map
