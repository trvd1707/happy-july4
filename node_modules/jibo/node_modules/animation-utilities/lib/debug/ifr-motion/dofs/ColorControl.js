/**
 * @author mattb
 * Copyright 2014 IF Robots LLC
 */

"use strict";

var ModelControl = require("./ModelControl");
var ModelControlFactory = require("./ModelControlFactory");
var THREE = require("three");

/**
 * @constructor
 * @extends ModelControl
 */
var ColorControl = function ColorControl() {
	ModelControl.call(this);

	/** @type {Array.<string>} */
	this._meshNames = null;
	/** @type {Array.<string>} */
	this._ledNames = null;

	/** @type {Array.<THREE.Mesh>} */
	this._meshes = [];

	/**
  * @type {boolean}
  * @private
  */
	this._billboardMode = true;
};

ColorControl.prototype = Object.create(ModelControl.prototype);
ColorControl.prototype.constructor = ColorControl;
ColorControl.prototype._controlType = "COLOR";

/**
 * @param {Object} jsonData
 * @override
 */
ColorControl.prototype.setFromJson = function (jsonData) {
	ModelControl.prototype.setFromJson.call(this, jsonData);

	this._dofNames.push(jsonData.redDOFName);
	this._dofNames.push(jsonData.greenDOFName);
	this._dofNames.push(jsonData.blueDOFName);
	this._meshNames = jsonData.meshNames;
	if (jsonData.ledNames) {
		this._ledNames = jsonData.ledNames;
	}
};

/**
 * @param {Object.<string, THREE.Object3D>} modelMap
 * @return {!boolean}
 * @override
 */
ColorControl.prototype.attachToModel = function (modelMap) {
	this._meshes.length = 0; //clear all meshes
	if (modelMap == null) {
		return false;
	}

	for (var meshIndex = 0; meshIndex < this._meshNames.length; meshIndex++) {
		if (modelMap.hasOwnProperty(this._meshNames[meshIndex])) {
			this._meshes.push(modelMap[this._meshNames[meshIndex]]);
		} else {
			return false;
		}
	}

	return true;
};

/**
 *
 * @param {boolean} billboard - true for billboard (emissive) mode, false for normal (diffuse) mode
 */
ColorControl.prototype.setBillboardMode = function (billboard) {
	if (billboard !== this._billboardMode) {
		if (this._meshes.length > 0) {
			var setDiffuse = new THREE.Color(0, 0, 0);
			var setEmissive = new THREE.Color(0, 0, 0);
			if (billboard) {
				//move existing color from diffuse to emissive, other to 0
				setEmissive.copy(this._meshes[0].material.color);
			} else {
				//move existing color from emissive to diffuse, other to 0
				setDiffuse.copy(this._meshes[0].material.emissive);
			}
			for (var meshIndex = 0; meshIndex < this._meshes.length; meshIndex++) {
				this._meshes[meshIndex].material.emissive.copy(setEmissive);
				this._meshes[meshIndex].material.color.copy(setDiffuse);
			}
		}
		this._billboardMode = billboard;
	}
};

/***
 *
 * @param {number} r
 * @param {number} g
 * @param {number} b
 */
function updateFromRGB(r, g, b) {
	for (var meshIndex = 0; meshIndex < this._meshes.length; meshIndex++) {
		if (this._billboardMode) {
			this._meshes[meshIndex].material.emissive.setRGB(r, g, b);
		} else {
			this._meshes[meshIndex].material.color.setRGB(r, g, b);
		}
	}
}

/**
 * @param {Object.<string, Object>} dofValues
 * @return {!boolean}
 * @override
 */
ColorControl.prototype.updateFromDOFValues = function (dofValues) {
	var dofValueList = [];
	var dofIndex;
	for (dofIndex = 0; dofIndex < this._dofNames.length; dofIndex++) {
		if (dofValues.hasOwnProperty(this._dofNames[dofIndex])) {
			dofValueList.push(dofValues[this._dofNames[dofIndex]]);
		} else {
			return false;
		}
	}

	if (this._meshes.length > 0) {
		updateFromRGB.call(this, dofValueList[0], dofValueList[1], dofValueList[2]);
		return true;
	} else {
		return false;
	}
};

/**
 * @param {Pose} pose
 * @return {!boolean}
 * @override
 */
ColorControl.prototype.updateFromPose = function (pose) {
	var dofValueList = [];
	var dofIndex;
	for (dofIndex = 0; dofIndex < this._dofNames.length; dofIndex++) {
		var c = pose.get(this._dofNames[dofIndex], 0);
		if (c != null) //null or undefined (eqnull)
			{
				dofValueList.push(c);
			} else {
			return false;
		}
	}

	if (this._meshes.length > 0) {
		updateFromRGB.call(this, dofValueList[0], dofValueList[1], dofValueList[2]);
		return true;
	} else {
		return false;
	}
};

/**
 * Creates a copy of this dof, or fills in this dof's data to the provided
 * argument (to allow type to be defined by subclass's getCopy).
 *
 * @param {ColorControl} copyInto - optional object to copy into
 * @return {ColorControl} copy of this dof, not attached to any model
 * @override
 */
ColorControl.prototype.getCopy = function (copyInto) {
	if (!copyInto) {
		copyInto = new ColorControl();
	}
	ModelControl.prototype.getCopy.call(this, copyInto);
	copyInto._meshNames = this._meshNames ? this._meshNames.slice(0) : null;
	copyInto._ledNames = this._ledNames ? this._ledNames.slice(0) : null;

	return copyInto;
};

/**
 * @constructor
 */
ColorControl.Factory = function () {};

ColorControl.Factory.prototype = Object.create(ModelControlFactory.prototype);
ColorControl.Factory.prototype.constructor = ColorControl.Factory;
ColorControl.Factory.prototype._controlType = ColorControl.prototype._controlType;
ColorControl.Factory.prototype._controlConstructor = ColorControl;

module.exports = ColorControl;
//# sourceMappingURL=../../map/ifr-motion/dofs/ColorControl.js.map
