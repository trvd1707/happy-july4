/**
 * @author mattb
 * Copyright 2014 IF Robots LLC
 */

"use strict";

var ModelControl = require("./ModelControl");
var ModelControlFactory = require("./ModelControlFactory");
var BasicFrame = require("../../ifr-geometry/BasicFrame");
var THREE = require("three");
/**
 * @constructor
 * @extends ModelControl
 */
var TranslationControl = function TranslationControl() {
	ModelControl.call(this);

	/** @type {string} */
	this._skeletonFrameName = null;

	/** @type {THREE.Vector3} */
	this._initialPosition = new THREE.Vector3();
	/** @type {Array.<THREE.Vector3>} */
	this._translationalDirectionList = [];

	/** @type {Array.<number>} */
	this._minList = [];
	/** @type {Array.<number>} */
	this._maxList = [];

	/** @type {THREE.Object3D} */
	this._skeletonFrame = null;
};

TranslationControl.prototype = Object.create(ModelControl.prototype);
TranslationControl.prototype.constructor = TranslationControl;
TranslationControl.prototype._controlType = "TRANSLATION";

/**
 * @param {Object} jsonData
 * @override
 */
TranslationControl.prototype.setFromJson = function (jsonData) {
	ModelControl.prototype.setFromJson.call(this, jsonData);

	this._dofNames.push(jsonData.dofName);
	this._skeletonFrameName = jsonData.skeletonFrameName;
	this._initialPosition.copy(BasicFrame.vector3FromJson(jsonData.xyzInitialPosition));
	this._translationalDirectionList.push(BasicFrame.vector3FromJson(jsonData.xyzTranslationDirection));
	this._minList.push(jsonData.min);
	this._maxList.push(jsonData.max);
};

/**
 * @param {TranslationControl} translationControlB
 */
TranslationControl.prototype.appendControl = function (translationControlB) {
	this._controlNames = this._controlNames.concat(translationControlB._controlNames);
	this._dofNames = this._dofNames.concat(translationControlB._dofNames);
	this._translationalDirectionList = this._translationalDirectionList.concat(translationControlB._translationalDirectionList);
	this._minList = this._minList.concat(translationControlB._minList);
	this._maxList = this._maxList.concat(translationControlB._maxList);
};

/**
 * @param {Object.<string, THREE.Object3D>} modelMap
 * @return {!boolean}
 * @override
 */
TranslationControl.prototype.attachToModel = function (modelMap) {
	this._skeletonFrame = null;

	if (modelMap != null && modelMap.hasOwnProperty(this._skeletonFrameName)) {
		this._skeletonFrame = modelMap[this._skeletonFrameName];
		return true;
	} else {
		return false;
	}
};

/**
 * @param {number[]} dofValueList - values in order of our dofs
 * @return {THREE.Vector3}
 */
function computeForDOFValueList(dofValueList) {
	var newPosition = new THREE.Vector3().copy(this._initialPosition);
	var deltaPosition = new THREE.Vector3();
	for (var dofIndex = 0; dofIndex < dofValueList.length; dofIndex++) {
		var dofValue = THREE.Math.clamp(dofValueList[dofIndex], this._minList[dofIndex], this._maxList[dofIndex]);
		deltaPosition.copy(this._translationalDirectionList[dofIndex]).multiplyScalar(dofValue);
		newPosition.add(deltaPosition);
	}
	return newPosition;
}

/**
 * @param {Object.<string, Object>} dofValues
 * @return {THREE.Vector3} computed value (null if cannot compute)
 */
TranslationControl.prototype.computeFromDOFValues = function (dofValues) {
	var dofValueList = [];
	for (var dofIndex = 0; dofIndex < this._dofNames.length; dofIndex++) {
		if (dofValues.hasOwnProperty(this._dofNames[dofIndex])) {
			dofValueList.push(dofValues[this._dofNames[dofIndex]]);
		} else {
			return null;
		}
	}

	return computeForDOFValueList.call(this, dofValueList);
};

/**
 * @param {Object.<string, Object>} dofValues
 * @return {!boolean}
 * @override
 */
TranslationControl.prototype.updateFromDOFValues = function (dofValues) {
	var newPosition = this.computeFromDOFValues(dofValues);
	if (newPosition != null && this._skeletonFrame != null) //checks for null or undefined (eqnull)
		{
			this._skeletonFrame.position.copy(newPosition);
			return true;
		} else {
		return false;
	}
};

/**
 * @param {Pose} pose
 * @return {THREE.Vector3} computed value (null if cannot compute)
 */
TranslationControl.prototype.computeFromPose = function (pose) {
	var dofValueList = [];
	for (var dofIndex = 0; dofIndex < this._dofNames.length; dofIndex++) {
		var val = pose.get(this._dofNames[dofIndex], 0);
		if (val != null) {
			dofValueList.push(val);
		} else {
			return null;
		}
	}

	return computeForDOFValueList.call(this, dofValueList);
};

/**
 * @param {Pose} pose
 * @return {!boolean}
 * @override
 */
TranslationControl.prototype.updateFromPose = function (pose) {
	var newPosition = this.computeFromPose(pose);
	if (newPosition != null && this._skeletonFrame != null) //checks for null or undefined (eqnull)
		{
			this._skeletonFrame.position.copy(newPosition);
			return true;
		} else {
		return false;
	}
};

/**
 * Creates a copy of this dof, or fills in this dof's data to the provided
 * argument (to allow type to be defined by subclass's getCopy).
 *
 * @param {TranslationControl} copyInto - optional object to copy into
 * @return {TranslationControl} copy of this dof, not attached to any model
 * @override
 */
TranslationControl.prototype.getCopy = function (copyInto) {
	if (!copyInto) {
		copyInto = new TranslationControl();
	}

	ModelControl.prototype.getCopy.call(this, copyInto);

	copyInto._skeletonFrameName = this._skeletonFrameName;

	copyInto._initialPosition = this._initialPosition ? this._initialPosition.clone() : null;

	copyInto._translationalDirectionList = this._translationalDirectionList ? this._translationalDirectionList.slice(0) : null;
	if (copyInto._translationalDirectionList) {
		//copy the vecs
		for (var i = 0; i < copyInto._translationalDirectionList.length; i++) {
			copyInto[i] = copyInto[i] ? copyInto[i].clone() : null;
		}
	}

	copyInto._minList = this._minList ? this._minList.slice(0) : this._minList;

	copyInto._maxList = this._maxList ? this._maxList.slice(0) : this._maxList;

	return copyInto;
};

/**
 ** @returns {string}
 */
TranslationControl.prototype.getTransformName = function () {
	return this._skeletonFrameName;
};

/**
 * @return {Array.<string>}
 * @override
 */
TranslationControl.prototype.getTransformNames = function () {
	return [this.getTransformName()];
};

/**
 * @constructor
 */
TranslationControl.Factory = function () {};

TranslationControl.Factory.prototype = Object.create(ModelControlFactory.prototype);
TranslationControl.Factory.prototype.constructor = TranslationControl.Factory;
TranslationControl.Factory.prototype._controlType = TranslationControl.prototype._controlType;
TranslationControl.Factory.prototype._controlConstructor = TranslationControl;

/**
 * @param {Array.<ModelControl>} controlList
 * @return {Array.<ModelControl>}
 */
TranslationControl.Factory.prototype.postProcessControlList = function (controlList) {
	/** @type {Object.<string, TranslationControl>} */
	var translationControlMap = {};

	/** @type {Array.<ModelControl>} */
	var trimmedControlList = [];
	for (var c = 0; c < controlList.length; c++) {
		var control = controlList[c];
		if (control instanceof TranslationControl) {
			if (translationControlMap.hasOwnProperty(control._skeletonFrameName)) {
				var masterTranslationControl = translationControlMap[control._skeletonFrameName];
				masterTranslationControl.appendControl(control);
			} else {
				translationControlMap[control._skeletonFrameName] = control;
				trimmedControlList.push(control);
			}
		} else {
			trimmedControlList.push(control);
		}
	}

	return trimmedControlList;
};

module.exports = TranslationControl;
//# sourceMappingURL=../../map/ifr-motion/dofs/TranslationControl.js.map
