{"version":3,"sources":["animation-animate/timeline/MotionTimelineSampledLayerRenderer.js"],"names":[],"mappings":"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","file":"animation-animate/timeline/MotionTimelineSampledLayerRenderer.js","sourcesContent":["/**\n * @author jg\n */\n\n\"use strict\";\n\nvar MotionTrack = require(\"../../ifr-motion/base/MotionTrack\");\nvar TimestampedBuffer = require(\"../../ifr-motion/base/TimestampedBuffer\");\nvar Motion = require(\"../../ifr-motion/base/Motion\");\nvar MotionTimelineLayerRenderer = require(\"./MotionTimelineLayerRenderer\");\n/**\n *\n * @param {SampleCombiner} sampleCombiner\n * @param {InterpolatorSet} interpolatorSet\n * @constructor\n * @extends MotionTimelineLayerRenderer\n */\nvar MotionTimelineSampledLayerRenderer = function(sampleCombiner, interpolatorSet){\n\tMotionTimelineLayerRenderer.call(this);\n\t/** @type {SampleCombiner} */\n\tthis._sampleCombiner = sampleCombiner;\n\t/** @type {InterpolatorSet} */\n\tthis._interpolatorSet = interpolatorSet;\n};\n\nMotionTimelineSampledLayerRenderer.prototype = Object.create(MotionTimelineLayerRenderer.prototype);\nMotionTimelineSampledLayerRenderer.prototype.constructor = MotionTimelineSampledLayerRenderer;\n\n/**\n * //TODO: clip anchored at startTime but outside data not clipped\n *\n * @param {MotionTimelineClip[]} layerData\n * @param {string} dofName\n * @param {Time} startTime\n * @param {Time} endTime\n * @param {number[]} leftVal\n * @param {BaseInterpolator} interpolator\n *\n * @return {TimestampedBuffer}\n */\nvar renderLayerForDOF = function(layerData, dofName, startTime, endTime, leftVal, interpolator){\n\n\tvar previousVal = leftVal;\n\tvar buffer = new TimestampedBuffer();\n\n\tfor(var ci = 0; ci < layerData.length; ci++) {\n\t\tvar clip = layerData[ci];\n\t\tif(clip.getDurationForDOF(dofName) === null){\n\t\t\tcontinue;\n\t\t}\n\t\tvar durationForDOF = clip.getDurationForDOF(dofName);\n\t\tvar track = clip.getMotion().getTracks()[dofName];\n\t\tvar trackData = track.getMotionData();\n\t\tvar offsetForThisClip = clip.getStartTime().subtract(startTime);\n\n\t\tif(durationForDOF !== null){\n\t\t\tvar si = 0;\n\n\t\t\t//TODO: should we add a t=0 and t=durationForDOF sample?\n\n\t\t\tvar usingStartTime = 0;\n\t\t\t{ //add a sample at the start\n\t\t\t\tvar sampleAtStart;\n\t\t\t\tif(trackData.getTimestamp(0)===usingStartTime){ //TODO: need to find the index (not zero necessarily) when we have start insets\n\t\t\t\t\tsampleAtStart = trackData.getData(0);\n\t\t\t\t}else{\n\t\t\t\t\tsampleAtStart = track.getDataAtTime(usingStartTime, interpolator);\n\t\t\t\t}\n\t\t\t\tbuffer.append(offsetForThisClip, previousVal); //clamp previous to avoid unintended linear interpolation\n\t\t\t\tbuffer.append(offsetForThisClip, sampleAtStart);\n\t\t\t\tpreviousVal = sampleAtStart;\n\t\t\t}\n\n\t\t\twhile(si < trackData.size() && trackData.getTimestamp(si) <= durationForDOF){\n\t\t\t\tvar sampleTime = trackData.getTimestamp(si);\n\n\t\t\t\tif(sampleTime > usingStartTime) { //don't re-add the sample we added above as the start\n\t\t\t\t\tvar sampleValue = trackData.getData(si);\n\n\t\t\t\t\tvar ts = offsetForThisClip + sampleTime;\n\n\t\t\t\t\t//round to nearest microseconds.  clips that have an \"identical\" end to the next one's start\n\t\t\t\t\t//may have floating point error otherwise and be in the wrong order\n\t\t\t\t\tts = Math.round(ts * 1000000) / 1000000;\n\t\t\t\t\t//if(si === 0){\n\t\t\t\t\t//\t//add the left-side lead in value\n\t\t\t\t\t//\tbuffer.append(ts, previousVal);\n\t\t\t\t\t//}\n\n\t\t\t\t\tbuffer.append(ts, sampleValue);\n\t\t\t\t\tpreviousVal = sampleValue;\n\t\t\t\t}\n\t\t\t\tsi++;\n\t\t\t}\n\n\t\t\t{//and add a sample at the end if we didn't happen to hit it exactly\n\t\t\t\tvar finalSampleTS = offsetForThisClip + durationForDOF;\n\t\t\t\tfinalSampleTS = Math.round(finalSampleTS * 1000000) / 1000000;\n\t\t\t\tif (buffer.getTimestamp(buffer.size() - 1) < finalSampleTS) {\n\t\t\t\t\tvar finalSample = track.getDataAtTime(durationForDOF, interpolator);\n\t\t\t\t\tbuffer.append(finalSampleTS, finalSample);\n\t\t\t\t\tpreviousVal = finalSample;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif(buffer.size() === 0){\n\t\tbuffer.append(0, previousVal);\n\t}\n\n\treturn buffer;\n};\n\n\n/**\n *\n * @param {MotionTimelineClip[]} layerClips\n * @param {Pose} defaultPose\n * @param {Time} startTime\n * @param {Time} endTime\n * @param {Motion} motionSoFar\n * @return {Motion}\n * @override\n */\nMotionTimelineSampledLayerRenderer.prototype.render = function(layerClips, defaultPose, startTime, endTime, motionSoFar){\n\n\tvar motion = new Motion(\"render\");\n\n\tfor(var di = 0; di < defaultPose.getDOFNames().length; di++){\n\t\tvar dofName = defaultPose.getDOFNames()[di];\n\t\tvar leftVal = defaultPose.get(dofName);\n\t\tvar interpolator = this._interpolatorSet.getInterpolator(dofName);\n\t\tvar buffer = renderLayerForDOF(layerClips, dofName, startTime, endTime, leftVal, interpolator);\n\t\tvar newMotionTrack = new MotionTrack(dofName, buffer, buffer.getEndTime());\n\t\tif(motionSoFar && motionSoFar.getTracks().hasOwnProperty(dofName)){\n\t\t\tvar trackSoFar = motionSoFar.getTracks()[dofName];\n\t\t\tvar t1i = 0;\n\t\t\tvar t2i = 0;\n\t\t\tvar t1 = trackSoFar.getMotionData().getTimestamp(t1i);\n\t\t\tvar t2 = buffer.getTimestamp(t2i);\n\t\t\tvar combined = new TimestampedBuffer();\n\t\t\twhile(t1!==null || t2!==null) {\n\t\t\t\tvar t;\n\t\t\t\tif (t1 !== null && t2 !== null && t1 === t2) {\n\t\t\t\t\tt = t1;\n\t\t\t\t\tt1i++;\n\t\t\t\t\tt2i++;\n\t\t\t\t} else if (t2 === null || (t1 !== null && t1 < t2)) {\n\t\t\t\t\tt = t1;\n\t\t\t\t\tt1i++;\n\t\t\t\t} else if (t1 === null || t2 < t1) {\n\t\t\t\t\tt = t2;\n\t\t\t\t\tt2i++;\n\t\t\t\t}else{\n\t\t\t\t\tthrow new Error(\"cannot happen\");\n\t\t\t\t}\n\t\t\t\tif (t1i < trackSoFar.getMotionData().size()) {\n\t\t\t\t\tt1 = trackSoFar.getMotionData().getTimestamp(t1i);\n\t\t\t\t} else {\n\t\t\t\t\tt1 = null;\n\t\t\t\t}\n\t\t\t\tif (t2i < buffer.size()) {\n\t\t\t\t\tt2 = buffer.getTimestamp(t2i);\n\t\t\t\t} else {\n\t\t\t\t\tt2 = null;\n\t\t\t\t}\n\t\t\t\tcombined.append(t, this._sampleCombiner.combineSamples(dofName, trackSoFar.getDataAtTime(t, interpolator), newMotionTrack.getDataAtTime(t, interpolator)));\n\t\t\t}\n\t\t\tmotion.addTrack(new MotionTrack(dofName, combined, combined.getEndTime()));\n\t\t}else{\n\t\t\tmotion.addTrack(newMotionTrack); //TODO: end time?\n\t\t}\n\t}\n\n\tif(motionSoFar!==null) {\n\t\t//pass through any tracks not addressed here\n\t\tvar motionSoFarTrackNames = Object.keys(motionSoFar.getTracks());\n\t\tfor (var ri = 0; ri < motionSoFarTrackNames.length; ri++) {\n\t\t\tif (!motion.getTracks().hasOwnProperty(motionSoFarTrackNames[ri])) {\n\t\t\t\tmotion.addTrack(motionSoFar.getTracks()[motionSoFarTrackNames[ri]]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\treturn motion;\n\n};\n\nmodule.exports = MotionTimelineSampledLayerRenderer;"],"sourceRoot":"/source/"}