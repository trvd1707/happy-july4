{"version":3,"sources":["animation-animate/timeline/MotionTimeline.js"],"names":[],"mappings":"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","file":"animation-animate/timeline/MotionTimeline.js","sourcesContent":["/**\n * @author jg, mattb\n */\n\n\"use strict\";\n\nvar Pose = require(\"../../ifr-motion/base/Pose\");\nvar DOFGlobalAlignment = require(\"../../ifr-motion/base/DOFGlobalAlignment\");\nvar CyclicMath = require(\"../../ifr-motion/base/CyclicMath\");\nvar slog = require(\"../../ifr-core/SLog\");\nvar TimelineEventDispatcher = require(\"./TimelineEventDispatcher\");\nvar LayerState = require(\"./LayerState\");\n\n\n/**\n * @param {string} name\n * @param {RobotInfo} robotInfo\n * @param {Clock} clock\n * @param {LayerCombiner} layerCombiner\n * @param {string} modalityName\n *\n * @constructor\n */\nvar MotionTimeline = function(name, robotInfo, clock, layerCombiner, modalityName)\n{\n\t/** @type {string} */\n\tthis._name = name;\n\n\t/** @type {Object<string,MotionGenerator[]>} */\n\tthis._layers = {};\n\n\t/** @type {string[]} */\n\tthis._layerNames = [];\n\n\t/** @type {RobotInfo} */\n\tthis._robotInfo = robotInfo;\n\n\t/** @type {string[]} */\n\tthis._dofNames = robotInfo.getDOFNames();\n\n\t/**\n\t * current state for each layer\n\t * @type {object.<string,LayerState>}*/\n\tthis._layerStates = {};\n\t/**\n\t * previous state for each layer\n\t * @type {object.<string,LayerState>}*/\n\tthis._previousLayerStates = {};\n\n\t/**\n\t * full combined system state\n\t * @type {LayerState} */\n\tthis._systemState = new LayerState(clock.currentTime(), robotInfo.getKinematicInfo().getDefaultPose().getCopy());\n\t/**\n\t * previous combined system state\n\t * @type {LayerState}*/\n\tthis._previousSystemState = this._systemState.getCopy();\n\n\t/** @type {Array.<*>} */\n\tthis._outputs = [];\n\n\t/** @type {Clock} */\n\tthis._clock = clock;\n\n\t/** @type {LayerCombiner} */\n\tthis._layerCombiner = layerCombiner;\n\n\t/** @type {string} */\n\tthis._modalityName = modalityName;\n\n\t/** @type {DOFGlobalAlignment} */\n\tthis._dofAlignment = new DOFGlobalAlignment(this._robotInfo.getKinematicInfo().getFullKinematicGroup(), null);\n\n\t/** @type {string[]} */\n\tthis._sortedDOFNames = this._dofNames.slice(0);\n\tthis._sortedDOFNames = this._dofAlignment.sortDOFsByDepth(this._sortedDOFNames);\n\n\t/** @type {Object<string, Object<string, string>>} */\n\tthis._dofMapByLayer = {};\n\n\t/** @type {number} */\n\tthis._minimumUpdateDelay = 0.01;\n};\n\n/**\n * @param {string} modality\n *\n * @return {MotionTimeline}\n */\nMotionTimeline.prototype.getModalityDelegate = function(modality)\n{\n\tif (modality === this._modalityName)\n\t{\n\t\treturn this;\n\t}\n\telse\n\t{\n\t\treturn null;\n\t}\n};\n\n/**\n * @return {Clock}\n */\nMotionTimeline.prototype.getClock = function()\n{\n\treturn this._clock;\n};\n\n/**\n * @return {string}\n */\nMotionTimeline.prototype.getName = function()\n{\n\treturn this._name;\n};\n\n/**\n * @param {string} layerName\n * @param {string[]} [dofs]\n */\nMotionTimeline.prototype.createLayer = function(layerName, dofs)\n{\n\tif (!this._layers.hasOwnProperty(layerName))\n\t{\n\t\tif (dofs == null) { //null or undefined (eqnull)\n\t\t\tdofs = this._dofNames;\n\t\t}\n\n\t\tthis._layers[layerName] = [];\n\t\tthis._layerNames.push(layerName);\n\n\t\tvar initialPose = this._robotInfo.getKinematicInfo().getDefaultPose();\n\t\tvar pose = new Pose(layerName + \"_pose\", dofs.slice(0));\n\t\tpose.setPose(initialPose);\n\n\t\tthis._layerStates[layerName] = new LayerState(this._clock.currentTime(), pose);\n\t\tthis._previousLayerStates[layerName] = this._layerStates[layerName].getCopy();\n\n\t\tthis._dofMapByLayer[layerName] = {};\n\t\tfor (var i=0; i<dofs.length; i++)\n\t\t{\n\t\t\tvar dofName = dofs[i];\n\t\t\tthis._dofMapByLayer[layerName][dofName] = dofName;\n\t\t}\n\t}\n\telse\n\t{\n\t\tslog.error(\"Not creating Timeline layer \"+layerName+\" since we already have one!\");\n\t}\n};\n\n/**\n * @return {Array.<string>}\n */\nMotionTimeline.prototype.getLayerNames = function()\n{\n\treturn this._layerNames.slice(0);\n};\n\n/**\n * @return {LayerCombiner}\n */\nMotionTimeline.prototype.getLayerCombiner = function()\n{\n\treturn this._layerCombiner;\n};\n\n/**\n * get the current combined state for the timeline.\n * the state will combine all layers by default, or optionally just a\n * specified subset of layers.\n * @param {string[]} [layerNames] - the subset of layers to combine (defaults to all layers)\n * @return {LayerState}\n */\nMotionTimeline.prototype.getCurrentState = function(layerNames)\n{\n\tif (!layerNames)\n\t{\n\t\treturn this._systemState;\n\t}\n\n\t/** @type {LayerState[]} */\n\tvar layerStates = [];\n\tvar i;\n\tfor (i=0; i<layerNames.length; i++)\n\t{\n\t\tif (this._layerStates.hasOwnProperty(layerNames[i]))\n\t\t{\n\t\t\tlayerStates.push(this._layerStates[layerNames[i]]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tslog.error(\"MotionTimeline: requested state for unknown layer: \"+layerNames[i]);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tvar currentState = this._layerCombiner.combineLayers(layerNames, layerStates);\n\n\t// calculate velocity\n\tif (currentState !== null)\n\t{\n\t\t/** @type {Object.<string, LayerState>} */\n\t\tvar previousLayers = null;\n\t\tif (currentState.getTime().subtract(this._previousLayerStates[layerNames[0]].getTime()) >= this._minimumUpdateDelay)\n\t\t{\n\t\t\tpreviousLayers = this._previousLayerStates;\n\t\t}\n\n\t\tif (previousLayers !== null)\n\t\t{\n\t\t\t/** @type {LayerState[]} */\n\t\t\tvar previousLayerStates = [];\n\t\t\tfor (i=0; i<layerNames.length; i++)\n\t\t\t{\n\t\t\t\tif (previousLayers.hasOwnProperty(layerNames[i]))\n\t\t\t\t{\n\t\t\t\t\tpreviousLayerStates.push(previousLayers[layerNames[i]]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpreviousLayerStates = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (previousLayerStates !== null)\n\t\t\t{\n\t\t\t\tvar previousState = this._layerCombiner.combineLayers(layerNames, previousLayerStates);\n\t\t\t\tif (previousState !== null)\n\t\t\t\t{\n\t\t\t\t\tthis.computeVelocity(previousState, currentState);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentState;\n};\n\n/**\n * @param {MotionGenerator} motionGenerator\n * @param {string} layerName\n * @return {MotionGenerator} - the motion generator, or null if add failed\n */\nMotionTimeline.prototype.add = function(motionGenerator, layerName)\n{\n\tif (!this._layers.hasOwnProperty(layerName))\n\t{\n\t\tslog.error(\"MotionTimeline: skipping add on unknown layer: \"+layerName);\n\t\treturn null;\n\t}\n\n\tvar startTime = motionGenerator.getStartTime();\n\tvar dofNames = motionGenerator.getDOFs();\n\n\tvar insertAt = 0;\n\tvar intoLayer = this._layers[layerName];\n\tvar i = 0;\n\n\twhile (i < intoLayer.length)\n\t{\n\t\t//iterate over clips in this layer.  find the spot where we should be inserted\n\t\t//crop existing clips if necessary, and delete them if the crop makes them empty\n\n\t\tvar clip = intoLayer[i];\n\t\tif (clip.getEndTime().isGreater(startTime))\n\t\t{\n\t\t\t//clip may need to be truncated where it overlaps with newClip\n\t\t\tclip.cropEnd(startTime, dofNames);\n\t\t}\n\t\tif (clip.getDuration()>0)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tintoLayer.splice(i, 1); //remove the clip\n\t\t\tclip.notifyRemoved();\n\t\t}\n\n\t\tif (startTime.isGreaterOrEqual(clip.getStartTime()))\n\t\t{\n\t\t\tinsertAt = i; //we can be after \"clip\".  insertAt will advance until we cannot be after the \"clip\"\n\t\t}\n\t}\n\n\tif (motionGenerator.getDuration()>0)\n\t{\n\t\tintoLayer.splice(insertAt, 0, motionGenerator);\n\t}\n\telse\n\t{\n\t\t//console.log(\"Immediately removing new clip \"+newClip.getName()+\" since it has zero duration\");\n\t\tmotionGenerator.notifyRemoved();\n\t\tmotionGenerator = null;\n\t}\n\n\treturn motionGenerator;\n};\n\n/**\n * Remove any clips that end on or before cullToTime.\n *\n * @param {Time} cullToTime\n */\nMotionTimeline.prototype.cullUpToTime = function(cullToTime)\n{\n\tvar layerNames = Object.keys(this._layers);\n\n\tfor(var li = 0; li < layerNames.length; li++) {\n\t\tvar layer = this._layers[layerNames[li]];\n\t\tvar ci = 0;\n\t\twhile(ci < layer.length && cullToTime.isGreater(layer[ci].getStartTime())){\n\t\t\tvar clip = layer[ci];\n\t\t\tif(cullToTime.isGreaterOrEqual(clip.getEndTime())){\n\t\t\t\tlayer.splice(ci, 1); //remove from layer, don't need to increase index\n\t\t\t\tclip.notifyRemoved();\n\t\t\t}else{\n\t\t\t\tci++;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * @param {Time} currentTime\n */\nMotionTimeline.prototype.render = function(currentTime)\n{\n\tvar layerIndex, dofIndex, clipIndex;\n\tvar layerName, dofName;\n\tvar layer, clip;\n\t/** @type {number[]} */\n\tvar newDOFState;\n\t/** @type {MotionGenerator} */\n\tvar generatorForDOF;\n\t/** @type {Time} */\n\tvar endTimeForDOF;\n\n\t// swap the current and previous states\n\tvar tempState = this._previousSystemState;\n\tthis._previousSystemState = this._systemState;\n\tthis._systemState = tempState;\n\tthis._systemState.setTime(currentTime);\n\tfor (layerIndex = 0; layerIndex < this._layerNames.length; layerIndex++)\n\t{\n\t\tlayerName = this._layerNames[layerIndex];\n\t\ttempState = this._previousLayerStates[layerName];\n\t\tthis._previousLayerStates[layerName] = this._layerStates[layerName];\n\t\tthis._layerStates[layerName] = tempState;\n\t\tthis._layerStates[layerName].setTime(currentTime);\n\t}\n\n\t// render dof-by-dof in skeleton-sorted order\n\n\tfor (dofIndex = 0; dofIndex < this._sortedDOFNames.length; dofIndex++)\n\t{\n\t\tdofName = this._sortedDOFNames[dofIndex];\n\n\t\tfor (layerIndex = 0; layerIndex < this._layerNames.length; layerIndex++)\n\t\t{\n\t\t\tlayerName = this._layerNames[layerIndex];\n\n\t\t\tif (this._dofMapByLayer[layerName].hasOwnProperty(dofName))\n\t\t\t{\n\t\t\t\tlayer = this._layers[layerName];\n\n\t\t\t\t/** @type {MotionGenerator} */\n\t\t\t\tgeneratorForDOF = null;\n\n\t\t\t\tclipIndex = 0;\n\t\t\t\twhile (clipIndex < layer.length && currentTime.isGreaterOrEqual(layer[clipIndex].getStartTime()))\n\t\t\t\t{\n\t\t\t\t\tclip = layer[clipIndex];\n\t\t\t\t\tendTimeForDOF = clip.getEndTimeForDOF(dofName);\n\t\t\t\t\tif (endTimeForDOF !== null && endTimeForDOF.isGreater(this._previousLayerStates[layerName].getTime()))\n\t\t\t\t\t{\n\t\t\t\t\t\tgeneratorForDOF = clip;\n\t\t\t\t\t}\n\t\t\t\t\tclipIndex++;\n\t\t\t\t}\n\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tnewDOFState = null;\n\t\t\t\tif (generatorForDOF)\n\t\t\t\t{\n\t\t\t\t\tnewDOFState = generatorForDOF.getDOFState(dofName, this._systemState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// use the state from the previous tick\n\t\t\t\t\tnewDOFState = this._previousLayerStates[layerName].getDOFState(dofName);\n\t\t\t\t}\n\t\t\t\t//if(this._robotInfo.getDOFInfo(dofName).isMetric() && (isNaN(newDOFState[0]) || (newDOFState.length>1 && isNaN[1]))){\n\t\t\t\t//\tslog.error(\"Generator \"+((generatorForDOF!=null)?generatorForDOF.getName():\"null(using cached value\")+\" on layer \"+layerName+\" generating NaN for \"+dofName+\" (\"+newDOFState.toString()+\")\");\n\t\t\t\t//}\n\n\t\t\t\tthis._layerStates[layerName].setDOFState(dofName, newDOFState);\n\n\t\t\t\t// update partial render state\n\t\t\t\tif (layerIndex === 0)\n\t\t\t\t{\n\t\t\t\t\tthis._systemState.setDOFState(dofName, newDOFState);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis._layerCombiner.incrementState(this._systemState, layerName, this._layerStates[layerName], dofName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// compute the velocity for the current state\n\tthis.computeVelocity(this._previousSystemState, this._systemState);\n};\n\nMotionTimeline.prototype.addOutput = function(output)\n{\n\tthis._outputs.push(output);\n};\n\nMotionTimeline.prototype.removeOutput = function(output){\n\tvar outputIndex = this._outputs.indexOf(output);\n\tif (outputIndex > -1){\n\t\tthis._outputs.splice(outputIndex, 1);\n\t}\n};\n\n/**\n * @return {Object[]}\n */\nMotionTimeline.prototype.getOutputs = function(){\n\treturn this._outputs;\n};\n\n/**\n * compute velocity between two layer states, storing the result in the second state\n * @param {LayerState} previousLayerState\n * @param {LayerState} currentLayerState\n */\nMotionTimeline.prototype.computeVelocity = function(previousLayerState, currentLayerState)\n{\n\tvar elapsedTime = currentLayerState.getTime().subtract(previousLayerState.getTime());\n\tvar previousPose = previousLayerState.getPose();\n\tvar currentPose = currentLayerState.getPose();\n\tvar dofNames = currentLayerState.getDOFNames();\n\n\tfor (var dofIndex=0; dofIndex<dofNames.length; dofIndex++)\n\t{\n\t\tvar dofName = dofNames[dofIndex];\n\t\tvar dofInfo = this._robotInfo.getDOFInfo(dofName);\n\t\tif (dofInfo.isMetric())\n\t\t{\n\t\t\tvar currentValue = currentPose.get(dofName, 0);\n\t\t\tvar previousValue = previousPose.get(dofName, 0);\n\t\t\tif (dofInfo.isCyclic())\n\t\t\t{\n\t\t\t\tcurrentValue = CyclicMath.closestEquivalentRotation(currentValue, previousValue);\n\t\t\t}\n\t\t\tvar velocity = (currentValue - previousValue) / elapsedTime;\n\t\t\t//if(isNaN(velocity)){\n\t\t\t//\tslog.error(\"MotionTimeline: got NaN velocity for \"+dofName+\" from \"+previousValue+\" to \"+currentValue+\" over time \"+elapsedTime);\n\t\t\t//}\n\t\t\tcurrentLayerState.getPose().set(dofName, velocity, 1);\n\t\t}\n\t}\n};\n\nMotionTimeline.prototype.update = function()\n{\n\t/** @type {Time} */\n\tvar currentTime = this._clock.currentTime();\n\tif (currentTime.subtract(this._systemState.getTime()) < this._minimumUpdateDelay)\n\t{\n\t\t// update too soon, return!\n\t\treturn;\n\t}\n\n\tvar layerNames = this._layerNames;\n\tvar layerIndex, clipIndex;\n\tvar layer;\n\tvar clip;\n\n\t// notify update started\n\tfor (layerIndex=0; layerIndex<layerNames.length; layerIndex++)\n\t{\n\t\tlayer = this._layers[layerNames[layerIndex]];\n\t\tfor (clipIndex=0; clipIndex<layer.length; clipIndex++)\n\t\t{\n\t\t\tclip = layer[clipIndex];\n\t\t\tclip.notifyUpdateStarted(currentTime);\n\t\t}\n\t}\n\n\t// render\n\tthis.render(currentTime);\n\n\t// update outputs\n\tfor (var outputIndex=0; outputIndex<this._outputs.length; outputIndex++)\n\t{\n\t\tvar out = this._outputs[outputIndex];\n\t\tout.handleOutput(currentTime, this._systemState.getPose());\n\t}\n\n\t// notify update finished\n\tfor (layerIndex=0; layerIndex<layerNames.length; layerIndex++)\n\t{\n\t\tlayer = this._layers[layerNames[layerIndex]];\n\t\tfor (clipIndex=0; clipIndex<layer.length; clipIndex++)\n\t\t{\n\t\t\tclip = layer[clipIndex];\n\t\t\tclip.notifyUpdateFinished(currentTime);\n\t\t}\n\t}\n\n\tthis.cullUpToTime(currentTime);\n\n\tTimelineEventDispatcher.dispatchQueuedEvents();\n};\n\n/**\n * @param {string} layerName\n * @return {string[]}\n */\nMotionTimeline.prototype.getDOFsForLayer = function(layerName)\n{\n\tif (this._layerStates.hasOwnProperty(layerName))\n\t{\n\t\treturn this._layerStates[layerName].getDOFNames();\n\t}\n\telse\n\t{\n\t\treturn null;\n\t}\n};\n\n\nmodule.exports = MotionTimeline;\n"],"sourceRoot":"/source/"}