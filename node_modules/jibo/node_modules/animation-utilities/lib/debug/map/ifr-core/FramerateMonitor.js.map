{"version":3,"sources":["ifr-core/FramerateMonitor.js"],"names":[],"mappings":";;;;;AAKA;;AAEA,IAAI,QAAQ,QAAQ,SAAR,CAAR;AACJ,IAAI,OAAO,QAAQ,QAAR,CAAP;;;;;;;;;AASJ,IAAI,mBAAmB,SAAnB,gBAAmB,CAAS,qBAAT,EAAgC,WAAhC,EAA6C,UAA7C,EACvB;AACC,KAAI,UAAU,WAAC,KAAgB,SAAhB,GAA6B,WAA9B,GAA4C,IAA5C,CADf;AAEC,KAAI,SAAS,UAAC,KAAe,SAAf,GAA4B,UAA7B,GAA0C,OAA1C,CAFd;;AAIC,KAAI,cAAc,CAAd,CAJL;AAKC,KAAI,0BAA0B,MAAM,WAAN,EAA1B,CALL;AAMC,KAAI,mBAAmB,CAAnB,CANL;;AAQC,KAAI,OAAO,IAAP,CARL;;AAUC,MAAK,MAAL,GAAc,YACd;AACC,gBADD;EADc,CAVf;;AAeC,MAAK,iBAAL,GAAyB,YACzB;AACC,SAAO,YAAU;AAAE,QAAK,MAAL,GAAF;GAAV,CADR;EADyB,CAf1B;;AAoBC,MAAK,YAAL,GAAoB,YACpB;AACC,SAAO,gBAAP,CADD;EADoB,CApBrB;;AAyBC,KAAI,kBAAkB,SAAlB,eAAkB,GACtB;AACC,MAAI,cAAc,MAAM,WAAN,EAAd,CADL;AAEC,qBAAmB,cAAe,YAAY,QAAZ,CAAqB,uBAArB,CAAf,CAFpB;AAGC,gBAAc,CAAd,CAHD;AAIC,4BAA0B,WAA1B,CAJD;;AAMC,MAAI,YAAY,IAAZ,EACJ;AACC,QAAK,OAAL,EAAc,KAAG,MAAH,GAAU,gBAAV,CAAd,CADD;GADA;EAPqB,CAzBvB;;AAsCC,KAAI,uBAAuB,KAAK,KAAL,CAAW,wBAAwB,IAAxB,CAAlC,CAtCL;AAuCC,aAAY,eAAZ,EAA6B,oBAA7B,EAvCD;CADuB;;AA6CvB,OAAO,OAAP,GAAiB,gBAAjB","file":"ifr-core/FramerateMonitor.js","sourcesContent":["/**\n * @author mattb\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar Clock = require(\"./Clock\");\nvar slog = require(\"./SLog\");\n\n/**\n * constructs a new framerate monitor.\n * @param {number} updateIntervalSeconds - the period at which the framerate measurement will be updated\n * @param {string} [slogChannel] - if specified, at every measurement the framerate will be printed to the given slog channel\n * @param {string} [prefixText] - prefix text for the framerate printout, defaults to 'fps: '\n * @constructor\n */\nvar FramerateMonitor = function(updateIntervalSeconds, slogChannel, prefixText)\n{\n\tvar channel = (slogChannel !== undefined) ? slogChannel : null;\n\tvar prefix = (prefixText !== undefined) ? prefixText : \"fps: \";\n\n\tvar updateCount = 0;\n\tvar lastFramerateUpdateTime = Clock.currentTime();\n\tvar updatesPerSecond = 0;\n\n\tvar self = this;\n\n\tthis.update = function()\n\t{\n\t\tupdateCount++;\n\t};\n\n\tthis.getUpdateFunction = function()\n\t{\n\t\treturn function(){ self.update(); };\n\t};\n\n\tthis.getFramerate = function()\n\t{\n\t\treturn updatesPerSecond;\n\t};\n\n\tvar updateFramerate = function()\n\t{\n\t\tvar currentTime = Clock.currentTime();\n\t\tupdatesPerSecond = updateCount / (currentTime.subtract(lastFramerateUpdateTime));\n\t\tupdateCount = 0;\n\t\tlastFramerateUpdateTime = currentTime;\n\n\t\tif (channel !== null)\n\t\t{\n\t\t\tslog(channel, \"\"+prefix+updatesPerSecond);\n\t\t}\n\t};\n\n\tvar updateIntervalMillis = Math.round(updateIntervalSeconds * 1000);\n\tsetInterval(updateFramerate, updateIntervalMillis);\n};\n\n\n\nmodule.exports = FramerateMonitor;\n"],"sourceRoot":"/source/"}