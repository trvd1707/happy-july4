{"version":3,"sources":["ifr-geometry/ExtraMath.js"],"names":[],"mappings":";;;;;;;;;AAUA;;AAGA,IAAI,QAAQ,QAAQ,OAAR,CAAR;;AAEJ,IAAI,YAAY,EAAZ;;AAEJ,UAAU,4BAAV,GAA0C,YAAU;;;AAGnD,KAAI,kBAAkB,IAAlB;;;;;;;;;AAH+C,QAY5C,UAAS,KAAT,EAAgB,cAAhB,EAAgC,aAAhC,EAA8C;AACpD,MAAG,oBAAoB,IAApB,EAAyB;AAC3B,qBAAkB,IAAI,MAAM,UAAN,EAAtB,CAD2B;GAA5B;AAGA,MAAG,kBAAkB,SAAlB,IAA+B,kBAAkB,IAAlB,EAAuB;AACxD,mBAAgB,IAAI,MAAM,OAAN,EAApB,CADwD;GAAzD;AAGA,QAAM,kBAAN,CAAyB,eAAzB,EAPoD;AAQpD,SAAO,cAAc,IAAd,CAAmB,cAAnB,EAAmC,eAAnC,CAAmD,eAAnD,CAAP,CARoD;EAA9C,CAZ4C;CAAV,EAA1C;;;;;;;;AA8BA,UAAU,cAAV,GAA2B,UAAS,SAAT,EAAoB,aAApB,EAAkC;AAC5D,KAAG,kBAAkB,SAAlB,IAA+B,kBAAkB,IAAlB,EAAuB;AACxD,kBAAgB,IAAI,MAAM,OAAN,EAApB,CADwD;EAAzD;AAGA,KAAI,KAAK,KAAK,GAAL,CAAS,UAAU,CAAV,CAAd,CAJwD;AAK5D,KAAI,KAAK,KAAK,GAAL,CAAS,UAAU,CAAV,CAAd,CALwD;AAM5D,KAAI,KAAK,KAAK,GAAL,CAAS,UAAU,CAAV,CAAd;;;AANwD,KASzD,MAAM,EAAN,IAAY,MAAM,EAAN,EAAS;;AACvB,gBAAc,GAAd,CAAkB,UAAU,CAAV,EAAa,CAAC,UAAU,CAAV,EAAa,CAA7C,EADuB;EAAxB,MAEK;;AACJ,gBAAc,GAAd,CAAkB,CAAlB,EAAqB,UAAU,CAAV,EAAa,CAAC,UAAU,CAAV,CAAnC,CADI;EAFL;AAKA,QAAO,aAAP,CAd4D;CAAlC;;AAkB3B,UAAU,iBAAV,GAA+B,YAAU;;AAExC,KAAI,iBAAiB,IAAjB;;;;;;;;;;AAFoC,QAYjC,UAAS,IAAT,EAAe,KAAf,EAAsB,iBAAtB,EAAwC;;AAE9C,MAAG,mBAAmB,IAAnB,EAAwB;AAC1B,oBAAiB,IAAI,MAAM,OAAN,EAArB,CAD0B;GAA3B;AAGA,MAAG,sBAAsB,IAAtB,EAA2B;AAC7B,uBAAoB,IAAI,MAAM,UAAN,EAAxB,CAD6B;GAA9B;;AAIA,iBAAe,IAAf,CAAoB,IAApB,EAA0B,SAA1B,GAT8C;AAU9C,SAAO,kBAAkB,gBAAlB,CAAmC,cAAnC,EAAmD,KAAnD,CAAP,CAV8C;EAAxC,CAZiC;CAAV,EAA/B;;AA0BA,UAAU,QAAV,GAAqB,UAAS,IAAT,EAAc;AAClC,QAAO,MAAI,KAAK,CAAL,GAAO,IAAX,GAAgB,KAAK,CAAL,GAAO,IAAvB,GAA4B,KAAK,CAAL,GAAO,GAAnC,CAD2B;CAAd;;AAKrB,OAAO,OAAP,GAAiB,SAAjB","file":"ifr-geometry/ExtraMath.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\n/**\n * @file Extra math functions/wrappers for THREE math access.\n */\n\n\"use strict\";\n\n\nvar THREE = require(\"three\");\n\nvar ExtraMath = {};\n\nExtraMath.convertDirectionLocalToWorld = (function(){\n\n\t/** {THREE.Quaternion} */\n\tvar worldQuaternion = null;\n\n\t/**\n\t * Wrapper for converting a direction Vector3 from local to a THREE Object3D to a world direction.\n\t *\n\t * @param {THREE.Object3D} frame - localDirection is in this frame\n\t * @param {THREE.Vector3} localDirection - local direction\n\t * @param {THREE.Vector3} inplaceResult - (may be null or omitted or the same instance as direction)\n\t */\n\treturn function(frame, localDirection, inplaceResult){\n\t\tif(worldQuaternion === null){\n\t\t\tworldQuaternion = new THREE.Quaternion();\n\t\t}\n\t\tif(inplaceResult === undefined || inplaceResult === null){\n\t\t\tinplaceResult = new THREE.Vector3();\n\t\t}\n\t\tframe.getWorldQuaternion(worldQuaternion);\n\t\treturn inplaceResult.copy(localDirection).applyQuaternion(worldQuaternion);\n\t};\n}());\n\n/**\n * Find a Vector3 orthogonal to the given Vector3.\n *\n * @param {THREE.Vector3} direction\n * @param {THREE.Vector3} inplaceResult - (may be null or omitted or the same instance as direction)\n */\nExtraMath.findOrthogonal = function(direction, inplaceResult){\n\tif(inplaceResult === undefined || inplaceResult === null){\n\t\tinplaceResult = new THREE.Vector3();\n\t}\n\tvar ax = Math.abs(direction.x);\n\tvar ay = Math.abs(direction.y);\n\tvar az = Math.abs(direction.z);\n\n\t//works as long as one of the two being swapped is non zero\n\tif(ax >= ay && ax >= az){ //x is biggest, involve it\n\t\tinplaceResult.set(direction.y, -direction.x, 0);\n\t}else{ //y or z is biggest, involve them\n\t\tinplaceResult.set(0, direction.z, -direction.y);\n\t}\n\treturn inplaceResult;\n};\n\n\nExtraMath.quatFromAxisAngle = (function(){\n\n\tvar normalizedAxis = null;\n\n\t/**\n\t * Axis/Angle quaternion construction wrapper that doesn't require axis to be normalized.\n\t *\n\t * @param {THREE.Vector3} axis - rotational axis, doesn't need to be normalized\n\t * @param {number} angle\n\t * @param {THREE.Quaternion} inplaceQuaternion - optional inplace quaternion to fill in\n\t * @returns {Quaternion}\n\t */\n\treturn function(axis, angle, inplaceQuaternion){\n\n\t\tif(normalizedAxis === null){\n\t\t\tnormalizedAxis = new THREE.Vector3();\n\t\t}\n\t\tif(inplaceQuaternion === null){\n\t\t\tinplaceQuaternion = new THREE.Quaternion();\n\t\t}\n\n\t\tnormalizedAxis.copy(axis).normalize();\n\t\treturn inplaceQuaternion.setFromAxisAngle(normalizedAxis, angle);\n\t};\n}());\n\nExtraMath.toString = function(vec3){\n\treturn \"(\"+vec3.x+\", \"+vec3.y+\", \"+vec3.z+\")\";\n};\n\n\nmodule.exports = ExtraMath;\n"],"sourceRoot":"/source/"}