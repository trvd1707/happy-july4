{"version":3,"sources":["animation-body/BodyTrajectoryOutput.js"],"names":[],"mappings":";;;;AAKA;;AAGA,IAAI,WAAW,QAAQ,YAAR,CAAX;AACJ,IAAI,aAAa,QAAQ,cAAR,CAAb;;;;;;;;;;;;;AAaJ,IAAI,uBAAuB,SAAvB,oBAAuB,CAAS,KAAT,EAAgB,SAAhB,EAA2B,cAA3B,EAA2C,YAA3C,EAAyD,oBAAzD,EAA+E,YAA/E,EAC3B;AACC,YAAW,IAAX,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,SAA7B,EAAwC,cAAxC,EAAwD,YAAxD,EAAsE,oBAAtE,EAA4F,YAA5F,EADD;CAD2B;;AAK3B,qBAAqB,SAArB,GAAiC,OAAO,MAAP,CAAc,WAAW,SAAX,CAA/C;AACA,qBAAqB,SAArB,CAA+B,WAA/B,GAA6C,UAA7C;;AAEA,qBAAqB,SAArB,CAA+B,MAA/B,GAAwC,YACxC;AACC,KAAI,cAAc,KAAK,KAAL,CAAW,WAAX,EAAd,CADL;;AAGC,KAAI,UAAU,KAAK,qBAAL,CAA2B,YAAY,GAAZ,CAAgB,KAAK,YAAL,CAA3C,CAAV,CAHL;;AAKC,KAAI,YAAY,IAAZ,IAAoB,KAAK,eAAL,CAAqB,WAArB,EAApB,EACJ;AACC,OAAK,IAAI,IAAE,CAAF,EAAK,IAAE,KAAK,QAAL,CAAc,MAAd,EAAsB,GAAtC,EACA;AACC,OAAI,cAAc,KAAK,YAAL,CAAkB,CAAlB,IAAuB,SAAS,eAAT,CAAyB,UAAzB,GAAsC,SAAS,eAAT,CAAyB,IAAzB,CADhF;AAEC,OAAI,gBAAgB,GAAhB,CAFL;AAGC,OAAI,oBAAoB,EAApB,CAHL;AAIC,OAAI,UAAU,CAAC,QAAQ,CAAR,EAAW,QAAX,EAAqB,QAAQ,CAAR,EAAW,QAAX,EAAqB,aAA3C,EAA0D,CAA1D,CAAV;;;AAJL,OAOC,CAAK,eAAL,CAAqB,UAArB,CAAgC,KAAK,QAAL,CAAc,CAAd,CAAhC,EAAkD,WAAlD,EAA+D,gBAAc,SAAS,eAAT,CAAyB,UAAzB,GAAoC,OAAlD,GAA0D,CAA1D,EAA6D,IAA5H,EAAkI,iBAAlI,EAAqJ,IAArJ,EAPD;;AASC,OAAI,KAAK,aAAL,CAAmB,MAAnB,GAA4B,CAA5B,EACJ;AACC,QAAI,QAAQ,KAAK,eAAL,CAAqB,QAArB,CAA8B,KAAK,QAAL,CAAc,CAAd,CAA9B,CAAR,CADL;AAEC,QAAI,OAAO;AACV,cAAS,KAAK,QAAL,CAAc,CAAd,CAAT;AACA,gBAAW,WAAX;AACA,uBAAkB,MAAM,GAAN;AAClB,qBAAgB,QAAQ,CAAR,EAAW,QAAX;AAChB,uBAAkB,MAAM,GAAN;AAClB,sBAAiB,QAAQ,CAAR,EAAW,QAAX;KANd,CAFL;AAUC,SAAK,IAAI,IAAE,CAAF,EAAK,IAAE,KAAK,aAAL,CAAmB,MAAnB,EAA2B,GAA3C,EACA;AACC,UAAK,aAAL,CAAmB,CAAnB,EAAsB,IAAtB,EADD;KADA;IAXD;GAVD;;AA4BA,OAAK,eAAL,CAAqB,WAArB,GA7BD;EADA;CANuC;;AAyCxC,OAAO,OAAP,GAAiB,oBAAjB","file":"animation-body/BodyTrajectoryOutput.js","sourcesContent":["/**\n * @author mattb\n */\n\n\n\"use strict\";\n\n\nvar BodyData = require(\"./BodyData\");\nvar BodyOutput = require(\"./BodyOutput\");\n\n/**\n * Timeline output connecting to the body service.\n * Communicates with the (remote) trajectory control mode running on the body boards.\n * @param {Clock} clock - the timeline clock\n * @param {RobotInfo} robotInfo - robot info object\n * @param {string} bodyServiceURL - base URL for the body service\n * @param {boolean} [startEnabled] - optional, if true, start up with motors enabled (defaults to false)\n * @param {number} [updateIntervalMillis] - if specified and non-zero, auto-update at the given interval\n * @param {string} [sessionToken] - optional session security token\n * @constructor\n */\nvar BodyTrajectoryOutput = function(clock, robotInfo, bodyServiceURL, startEnabled, updateIntervalMillis, sessionToken)\n{\n\tBodyOutput.call(this, clock, robotInfo, bodyServiceURL, startEnabled, updateIntervalMillis, sessionToken);\n};\n\nBodyTrajectoryOutput.prototype = Object.create(BodyOutput.prototype);\nBodyTrajectoryOutput.prototype.constructor = BodyOutput;\n\nBodyTrajectoryOutput.prototype.update = function()\n{\n\tvar currentTime = this.clock.currentTime();\n\n\tvar targets = this.computeTargetsForTime(currentTime.add(this.reactionTime));\n\n\tif (targets !== null && this.motionInterface.isConnected())\n\t{\n\t\tfor (var i=0; i<this.dofNames.length; i++)\n\t\t{\n\t\t\tvar commandMode = this.enabledArray[i] ? BodyData.AxisCommandMode.TRAJECTORY : BodyData.AxisCommandMode.LIMP;\n\t\t\tvar interceptTime = 0.3;\n\t\t\tvar accelerationLimit = 30;\n\t\t\tvar command = [targets[i].velocity, targets[i].position, interceptTime, 0];\n\n\t\t\t//send only 1 value if we're in \"limp\" mode\n\t\t\tthis.motionInterface.setCommand(this.dofNames[i], commandMode, commandMode===BodyData.AxisCommandMode.TRAJECTORY?command:0, null, accelerationLimit, null);\n\n\t\t\tif (this.infoListeners.length > 0)\n\t\t\t{\n\t\t\t\tvar state = this.motionInterface.getState(this.dofNames[i]);\n\t\t\t\tvar info = {\n\t\t\t\t\tdofName: this.dofNames[i],\n\t\t\t\t\ttimestamp: currentTime,\n\t\t\t\t\tobservedPosition: state.pos,\n\t\t\t\t\ttargetPosition: targets[i].position,\n\t\t\t\t\tobservedVelocity: state.vel,\n\t\t\t\t\tcommandVelocity: targets[i].velocity\n\t\t\t\t};\n\t\t\t\tfor (var c=0; c<this.infoListeners.length; c++)\n\t\t\t\t{\n\t\t\t\t\tthis.infoListeners[c](info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.motionInterface.sendCommand();\n\t}\n};\n\n\nmodule.exports = BodyTrajectoryOutput;\n"],"sourceRoot":"/source/"}