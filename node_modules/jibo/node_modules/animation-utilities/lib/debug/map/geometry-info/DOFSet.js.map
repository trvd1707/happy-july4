{"version":3,"sources":["geometry-info/DOFSet.js"],"names":[],"mappings":";;;;AAIA;;AAEA,IAAI,YAAY,QAAQ,uBAAR,CAAZ;AACJ,IAAI,OAAO,QAAQ,kBAAR,CAAP;;AAEJ,IAAI,UAAU,eAAV;;;;;;;;;;;;;;AAcJ,IAAI,SAAS,SAAT,MAAS,CAAS,WAAT,EAAsB,WAAtB,EAAkC;;;;AAI9C,KAAI,WAAW,EAAX,CAJ0C;;AAO9C,KAAG,eAAe,IAAf,EAAqB;;AACvB,OAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,YAAY,MAAZ,EAAoB,GAAxC,EAA6C;AAC5C,YAAS,YAAY,CAAZ,CAAT,IAA2B,IAA3B,CAD4C;GAA7C;EADD;;;;;;;;;;AAP8C,KAuB9C,CAAK,IAAL,GAAY,UAAS,QAAT,EAAkB;;AAE7B,MAAI,QAAJ,CAF6B;;AAI7B,MAAG,OAAO,QAAP,KAAqB,QAArB,EAA8B;AAChC,cAAW,YAAY,QAAZ,CAAX,CADgC;GAAjC,MAEK;AACJ,cAAW,QAAX,CADI;GAFL;;AAMA,MAAI,UAAU,KAAK,OAAL,EAAV,CAVyB;AAW7B,MAAI,eAAe,SAAS,OAAT,EAAf,CAXyB;;AAa7B,MAAG,YAAY,IAAZ,EAAkB;;AACpB,QAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,aAAa,MAAb,EAAqB,GAAzC,EAA8C;;AAE7C,QAAI,CAAC,SAAS,cAAT,CAAwB,aAAa,CAAb,CAAxB,CAAD,EAA2C;AAC9C,aAAQ,IAAR,CAAa,aAAa,CAAb,CAAb,EAD8C;KAA/C;IAFD;GADD;;AASA,SAAO,IAAI,MAAJ,CAAW,OAAX,EAAoB,WAApB,CAAP,CAtB6B;EAAlB;;;;;;;;;AAvBkC,KAuD9C,CAAK,KAAL,GAAa,UAAS,QAAT,EAAkB;;AAE9B,MAAI,aAAJ,CAF8B;;AAI9B,MAAG,OAAO,QAAP,KAAqB,QAArB,EAA8B;AAChC,mBAAgB,YAAY,QAAZ,CAAhB,CADgC;GAAjC,MAEK;AACJ,mBAAgB,QAAhB,CADI;GAFL;;AAMA,MAAI,UAAU,EAAV,CAV0B;AAW9B,MAAI,SAAS,KAAK,OAAL,EAAT,CAX0B;;AAa9B,MAAG,iBAAiB,IAAjB,EAAuB;;AACzB,QAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,OAAO,MAAP,EAAe,GAAnC,EAAwC;AACvC,QAAI,CAAC,cAAc,MAAd,CAAqB,OAAO,CAAP,CAArB,CAAD,EAAkC;AACrC,aAAQ,IAAR,CAAa,OAAO,CAAP,CAAb,EADqC;KAAtC;IADD;GADD,MAMK;AACJ,aAAU,MAAV;AADI,GANL;;AAUA,SAAO,IAAI,MAAJ,CAAW,OAAX,EAAoB,WAApB,CAAP,CAvB8B;EAAlB;;;;;;AAvDiC,KAqF9C,CAAK,OAAL,GAAe,YAAU;AACxB,SAAO,OAAO,IAAP,CAAY,QAAZ,CAAP,CADwB;EAAV;;;;;;;AArF+B,KA+F9C,CAAK,MAAL,GAAc,UAAS,OAAT,EAAiB;AAC9B,SAAO,SAAS,cAAT,CAAwB,OAAxB,CAAP,CAD8B;EAAjB,CA/FgC;CAAlC;;;;;;;;;;;;;;;AAkHb,OAAO,IAAP,GAAc,UAAS,GAAT,EAAc,QAAd,EAAuB;AACpC,WAAU,QAAV,CAAmB,GAAnB,EAAwB,UAAS,KAAT,EAAgB,IAAhB,EAAqB;AAC5C,MAAI,UAAU,IAAV,EAAgB;AACnB,OAAI,aAAa,OAAO,qBAAP,CAA6B,IAA7B,CAAb,CADe;AAEnB,OAAI,QAAJ,EAAa;AACZ,aAAS,UAAT,EAAqB,IAArB,EADY;IAAb;GAFD,MAKK;AACJ,OAAI,QAAJ,EAAa;AACZ,aAAS,IAAT,EAAe,KAAf,EADY;IAAb;GAND;EADuB,CAAxB,CADoC;CAAvB;;;;;;;AAoBd,OAAO,qBAAP,GAA+B,UAAS,QAAT,EAAmB;AACjD,KAAI,CAAJ,CADiD;AAEjD,KAAI,SAAS,MAAT,CAAgB,QAAhB,KAA6B,SAA7B,EAAwC;AAC3C,OAAK,OAAL,EAAc,qDAAmD,SAAS,MAAT,CAAgB,QAAhB,CAAjE,CAD2C;EAA5C;;;AAFiD,KAO7C,cAAc,SAAS,OAAT,CAAiB,OAAjB,CAP+B;AAQjD,KAAI,QAAQ,OAAO,IAAP,CAAY,WAAZ,CAAR;;;AAR6C,KAW7C,aAAa,EAAb,CAX6C;;AAajD,MAAI,IAAI,CAAJ,EAAO,IAAI,MAAM,MAAN,EAAc,GAA7B,EAAiC;AAChC,aAAW,MAAM,CAAN,CAAX,IAAuB,IAAI,MAAJ,CAAW,YAAY,MAAM,CAAN,CAAZ,CAAX,EAAkC,UAAlC,CAAvB,CADgC;EAAjC;;AAIA,KAAG,SAAS,OAAT,CAAiB,cAAjB,CAAgC,cAAhC,CAAH,EAAmD;;;;;AAKlD,MAAI,eAAe,SAAS,OAAT,CAAiB,YAAjB,CAL+B;AAMlD,MAAI,gBAAgB,OAAO,IAAP,CAAY,YAAZ,CAAhB,CAN8C;;AAQlD,OAAI,IAAI,CAAJ,EAAO,IAAI,cAAc,MAAd,EAAsB,GAArC,EAAyC;AACxC,OAAI,mBAAmB,aAAa,cAAc,CAAd,CAAb,CAAnB,CADoC;AAExC,OAAI,KAAK,IAAI,MAAJ,CAAW,IAAX,EAAiB,UAAjB,CAAL,CAFoC;AAGxC,QAAI,IAAI,IAAI,CAAJ,EAAO,IAAI,iBAAiB,MAAjB,EAAyB,GAA5C,EAAgD;AAC/C,QAAI,WAAW,iBAAiB,CAAjB,CAAX,CAD2C;AAE/C,QAAG,WAAW,cAAX,CAA0B,QAA1B,CAAH,EAAwC;AACvC,UAAK,GAAG,IAAH,CAAQ,WAAW,QAAX,CAAR,CAAL,CADuC;KAAxC,MAEK;AACJ,UAAK,OAAL,EAAc,4BAA0B,cAAc,CAAd,CAA1B,GAA2C,uBAA3C,GAAmE,QAAnE,GAA4E,gCAA5E,CAAd,CADI;KAFL;IAFD;AAQA,cAAW,cAAc,CAAd,CAAX,IAA+B,EAA/B,CAXwC;GAAzC;EARD;;AAuBA,QAAO,UAAP,CAxCiD;CAAnB;;AA4C/B,OAAO,OAAP,GAAiB,MAAjB","file":"geometry-info/DOFSet.js","sourcesContent":["/**\n * @author jg\n */\n\n\"use strict\";\n\nvar FileTools = require(\"../ifr-core/FileTools\");\nvar slog = require(\"../ifr-core/SLog\");\n\nvar channel = \"MODEL_LOADING\";\n\n/**\n * Protected constructor for internal use only.\n *\n * Creates a DOFSet, including the provided DOFs. \n * The dofSetGroup provided looks up other DOFSets by name when \n * sets are identified by name (e.g., in the \"plus\" function).\n *\n * @param {string[]} includeDOFs - DOFs in this set. If null, 0 DOFs will be in set.\n * @param {Object.<string, DOFSet>} dofSetGroup - Map to look up other DOFSets by name when requested (e.g., \"plus\" function).\n * @constructor\n * @protected\n */\nvar DOFSet = function(includeDOFs, dofSetGroup){\n\n\t/** @type {Object.<string, boolean>} */\n\t/** @private */\n\tvar _dofsSet = {};\n\n\n\tif(includeDOFs != null) { //checks for undefined or null (eqnull)\n\t\tfor (var i = 0; i < includeDOFs.length; i++) {\n\t\t\t_dofsSet[includeDOFs[i]] = true;\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Creates a new DOFSet containing the all of the DOFs of this\n\t * DOFSet plus all the dofs of the set passed in.  Duplicates\n\t * are included only once (union of the sets)\n\t *\n\t * @param {DOFSet|string} otherSet - Set to add, either the name of the set or the actual DOFSet.\n\t * @returns {DOFSet} Union of this and otherSet.\n\t */\n\tthis.plus = function(otherSet){\n\t\t/** @type {DOFSet} */\n\t\tvar setToAdd;\n\n\t\tif(typeof(otherSet) === \"string\"){\n\t\t\tsetToAdd = dofSetGroup[otherSet];\n\t\t}else{\n\t\t\tsetToAdd = otherSet;\n\t\t}\n\n\t\tvar newList = this.getDOFs();\n\t\tvar incomingList = setToAdd.getDOFs();\n\n\t\tif(setToAdd != null) { //check for null or undefined (eqnull)\n\t\t\tfor (var i = 0; i < incomingList.length; i++) {\n\t\t\t\t//add all from otherSet that aren't already in\n\t\t\t\tif (!_dofsSet.hasOwnProperty(incomingList[i])) {\n\t\t\t\t\tnewList.push(incomingList[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new DOFSet(newList, dofSetGroup);\n\t};\n\n\t/**\n\t * Creates a new DOFSet containing all the DOFs of this\n\t * DOFSet that are not present in otherSet.\n\t *\n\t * @param {DOFSet|string} otherSet - Set to subtract, either the name of the set or the actual DOFSet.\n\t * @returns {DOFSet} DOFSet containing DOFs of this set that are not in the argument set.\n\t */\n\tthis.minus = function(otherSet){\n\t\t/** @type {DOFSet} */\n\t\tvar setToSubtract;\n\n\t\tif(typeof(otherSet) === \"string\"){\n\t\t\tsetToSubtract = dofSetGroup[otherSet];\n\t\t}else{\n\t\t\tsetToSubtract = otherSet;\n\t\t}\n\n\t\tvar newList = [];\n\t\tvar myDOFs = this.getDOFs();\n\n\t\tif(setToSubtract != null) { //check for null or undefined (eqnull)\n\t\t\tfor (var i = 0; i < myDOFs.length; i++) {\n\t\t\t\tif (!setToSubtract.hasDOF(myDOFs[i])) {\n\t\t\t\t\tnewList.push(myDOFs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tnewList = myDOFs; //other is null\n\t\t}\n\n\t\treturn new DOFSet(newList, dofSetGroup);\n\t};\n\n\t/**\n\t * Get the DOFs from this set as an array of strings.\n\t * @returns {string[]}\n\t */\n\tthis.getDOFs = function(){\n\t\treturn Object.keys(_dofsSet);\n\t};\n\n\n\t/**\n\t * Check if this DOFSet contains a particular DOF.\n\t * @param {string} dofName - DOF name to test for membership in this set.\n\t * @returns {boolean} true if this DOFSet has this dof.\n\t */\n\tthis.hasDOF = function(dofName){\n\t\treturn _dofsSet.hasOwnProperty(dofName);\n\t};\n};\n\n\n/**\n * @callback DOFSetLoadCallback\n * @param {Object.<string, DOFSet>} allDOFSets - Set of all DOFSets, or null if load failed.\n * @param {string} errorMessage - Error message if error occurred.\n * @private\n */\n\n/**\n *\n * @param {string} url\n * @param {DOFSetLoadCallback} callback\n * @private\n */\nDOFSet.load = function(url, callback){\n\tFileTools.loadJSON(url, function(error, data){\n\t\tif (error === null) {\n\t\t\tvar allDOFSets = DOFSet.createDOFSetsFromJSON(data);\n\t\t\tif (callback){\n\t\t\t\tcallback(allDOFSets, null);\n\t\t\t}\n\t\t}else{\n\t\t\tif (callback){\n\t\t\t\tcallback(null, error);\n\t\t\t}\n\t\t}\n\t});\n};\n\n/**\n * @param {Object} jsonData\n * @return {Object.<string, DOFSet>}\n * @private\n */\nDOFSet.createDOFSetsFromJSON = function(jsonData) {\n\tvar i;\n\tif (jsonData.header.fileType !== \"DOFSets\") {\n\t\tslog(channel, \"DOFSet doesn't know how to parse file with type \"+jsonData.header.fileType);\n\t}\n\n\t/** @type {Object.<string, string[]>} */\n\tvar jsonDOFSets = jsonData.content.DOFSets;\n\tvar names = Object.keys(jsonDOFSets);\n\n\t/** @type {Object.<string, DOFSet>} */\n\tvar allDOFSets = {};\n\n\tfor(i = 0; i < names.length; i++){\n\t\tallDOFSets[names[i]] = new DOFSet(jsonDOFSets[names[i]], allDOFSets);\n\t}\n\n\tif(jsonData.content.hasOwnProperty(\"CompoundSets\")){\n\t\t//CompoundSets should be a map from DOFSet names (name of set being created)\n\t\t//to names of basic DOFSets defined in the DOFSet map above\n\t\t// (previously defined CompoundSets are also ok, if they are defined earlier in the file)\n\t\t//all names in a single compound will be combined into one set\n\t\tvar compoundSets = jsonData.content.CompoundSets;\n\t\tvar compoundNames = Object.keys(compoundSets);\n\n\t\tfor(i = 0; i < compoundNames.length; i++){\n\t\t\tvar combineTheseSets = compoundSets[compoundNames[i]];\n\t\t\tvar cs = new DOFSet(null, allDOFSets);\n\t\t\tfor(var c = 0; c < combineTheseSets.length; c++){\n\t\t\t\tvar basicSet = combineTheseSets[c];\n\t\t\t\tif(allDOFSets.hasOwnProperty(basicSet)) {\n\t\t\t\t\tcs = cs.plus(allDOFSets[basicSet]);\n\t\t\t\t}else{\n\t\t\t\t\tslog(channel, \"Error, compound DOFSet \"+compoundNames[i]+\" requested basic set \"+basicSet+\" but it is not present in file\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tallDOFSets[compoundNames[i]] = cs;\n\t\t}\n\t}\n\n\treturn allDOFSets;\n};\n\n\nmodule.exports = DOFSet;"],"sourceRoot":"/source/"}