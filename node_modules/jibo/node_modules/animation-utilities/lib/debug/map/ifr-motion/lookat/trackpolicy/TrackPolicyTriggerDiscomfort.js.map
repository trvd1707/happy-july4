{"version":3,"sources":["ifr-motion/lookat/trackpolicy/TrackPolicyTriggerDiscomfort.js"],"names":[],"mappings":";;;;;AAKA;;AAEA,IAAI,qBAAqB,QAAQ,sBAAR,CAArB;;;;;;;;;;;;;;;;;;;AAmBJ,IAAI,+BAA+B,SAA/B,4BAA+B,CAAS,UAAT,EAAqB,UAArB,EAAiC,UAAjC,EAA6C,UAA7C,EAAyD,wBAAzD,EAAkF;AACpH,oBAAmB,IAAnB,CAAwB,IAAxB;;;AADoH,KAIpH,CAAK,WAAL,GAAmB,UAAnB;;;;AAJoH,KAQpH,CAAK,WAAL,GAAmB,UAAnB;;;;AARoH,KAYpH,CAAK,gBAAL,GAAwB,UAAxB;;;;AAZoH,KAgBpH,CAAK,gBAAL,GAAwB,UAAxB;;;;AAhBoH,KAoBpH,CAAK,yBAAL,GAAiC,wBAAjC;;;;AApBoH,KAwBpH,CAAK,kBAAL,GAA0B,CAA1B,CAxBoH;CAAlF;;AA4BnC,6BAA6B,SAA7B,GAAyC,OAAO,MAAP,CAAc,mBAAmB,SAAnB,CAAvD;AACA,6BAA6B,SAA7B,CAAuC,WAAvC,GAAqD,4BAArD;;;;;;;;;AASA,6BAA6B,SAA7B,CAAuC,mBAAvC,GAA6D,UAAS,wBAAT,EAAmC,SAAnC,EAA6C;;AAEzG,KAAI,SAAS,IAAT,CAFqG;;AAIzG,KAAI,WAAW,yBAAyB,4BAAzB,CAJ0F;AAKzG,KAAG,WAAW,KAAK,WAAL,EAAiB;AAC9B,OAAK,kBAAL,GAA0B,CAA1B,CAD8B;AAE9B,WAAS,mBAAmB,WAAnB,CAA+B,EAA/B,CAFqB;EAA/B,MAGK;AACJ,MAAG,YAAY,KAAK,WAAL,IAAoB,KAAK,yBAAL,EAA+B;AACjE,QAAK,kBAAL,GAA0B,CAA1B,CADiE;AAEjE,YAAS,mBAAmB,WAAnB,CAA+B,GAA/B,CAFwD;GAAlE,MAGM,IAAI,KAAK,WAAL,GAAmB,KAAK,WAAL,EAAiB;;;AAE7C,cAAW,KAAK,GAAL,CAAS,KAAK,WAAL,EAAkB,KAAK,GAAL,CAAS,KAAK,WAAL,EAAkB,QAA3B,CAA3B,CAAX,CAF6C;AAG7C,OAAI,QAAQ,CAAC,WAAW,KAAK,WAAL,CAAZ,IAAiC,KAAK,WAAL,GAAmB,KAAK,WAAL,CAApD,CAHiC;AAI7C,OAAI,UAAU,CAAC,IAAE,KAAF,CAAD,GAAU,KAAK,gBAAL,GAAwB,QAAM,KAAK,gBAAL,CAJT;AAK7C,QAAK,kBAAL,IAA4B,UAAU,SAAV,CALiB;AAM7C,OAAG,KAAK,kBAAL,GAA0B,CAA1B,EAA4B;AAC9B,aAAS,mBAAmB,WAAnB,CAA+B,GAA/B,CADqB;IAA/B,MAEK;AACJ,aAAS,mBAAmB,WAAnB,CAA+B,KAA/B,CADL;IAFL;GANK;EAPP;;AAqBA,QAAO,MAAP,CA1ByG;CAA7C;;;;;AAgC7D,6BAA6B,SAA7B,CAAuC,KAAvC,GAA+C,YAAU;AACxD,MAAK,kBAAL,GAA0B,CAA1B,CADwD;CAAV;;AAI/C,OAAO,OAAP,GAAiB,4BAAjB","file":"ifr-motion/lookat/trackpolicy/TrackPolicyTriggerDiscomfort.js","sourcesContent":["/**\n * @author jg\n * Copyright 2016 IF Robots LLC\n */\n\n\"use strict\";\n\nvar TrackPolicyTrigger = require(\"./TrackPolicyTrigger\");\n\n/**\n * Track policy based on accumulating discomfort based on distance between current and optimal-position-for-target (delta).\n * Track is triggered when accumulation reaches 1.  Accumulation increases at a rate computed by linearly interpolating\n * from accumInner to accumOuter based on our delta's position between innerLimit and outerLimit.\n *\n * Track can be triggered immediately if \"delta > outerLimit\" and moveImmediatelyPastOuter is true.  (Otherwise accumulation\n * proceeds as if delta = outerLimit).  accumInner and accumOuter are in units/second.\n *\n *\n * @param {number} innerLimit - never move if delta < innerLimit.  innerLimit associates with accumInner for discomfort accumulation.\n * @param {number} outerLimit - outerLimit associates with accumOuter for discomfort accumulation.  Optionally move immediately if delta > outerLimit (see moveImmediatelyPastOuter)\n * @param {number} accumInner - accumulate discomfort at this rate when \"delta = innerLimit\"\n * @param {number} accumOuter - accumulate discomfort at this rate when \"delta = outerLimit\"\n * @param {boolean} moveImmediatelyPastOuter - if true, track immediately if \"delta > outerLimit\".  Otherwise accumulated discomfort as if delta = outerLimit.\n * @constructor\n * @extends TrackPolicyTrigger\n */\nvar TrackPolicyTriggerDiscomfort = function(innerLimit, outerLimit, accumInner, accumOuter, moveImmediatelyPastOuter){\n\tTrackPolicyTrigger.call(this);\n\t/** @type {number}\n\t * @private */\n\tthis._limitInner = innerLimit;\n\n\t/** @type {number}\n\t * @private */\n\tthis._limitOuter = outerLimit;\n\n\t/** @type {number}\n\t * @private */\n\tthis._accumValueInner = accumInner;\n\n\t/** @type {number}\n\t * @private */\n\tthis._accumValueOuter = accumOuter;\n\n\t/** @type {boolean}\n\t * @private */\n\tthis._moveImmediatelyPastOuter = moveImmediatelyPastOuter;\n\n\t/** @type {number}\n\t * @private */\n\tthis._accumValueCurrent = 0;\n\n};\n\nTrackPolicyTriggerDiscomfort.prototype = Object.create(TrackPolicyTrigger.prototype);\nTrackPolicyTriggerDiscomfort.prototype.constructor = TrackPolicyTriggerDiscomfort;\n\n/**\n *\n * @param {LookatNodeDistanceReport} lookatNodeDistanceReport\n * @param {number} timeDelta\n * @return {StartStatus}\n * @override\n */\nTrackPolicyTriggerDiscomfort.prototype.shouldStartTracking = function(lookatNodeDistanceReport, timeDelta){\n\n\tvar status = null;\n\n\tvar distance = lookatNodeDistanceReport.highestDistanceHoldToOptimal;\n\tif(distance < this._limitInner){\n\t\tthis._accumValueCurrent = 0;\n\t\tstatus = TrackPolicyTrigger.StartStatus.NO;\n\t}else{\n\t\tif(distance >= this._limitOuter && this._moveImmediatelyPastOuter){\n\t\t\tthis._accumValueCurrent = 1;\n\t\t\tstatus = TrackPolicyTrigger.StartStatus.YES;\n\t\t}else if (this._limitOuter > this._limitInner){ //if they are equal, this type of accum disabled\n\t\t\t//clamp\n\t\t\tdistance = Math.max(this._limitInner, Math.min(this._limitOuter, distance));\n\t\t\tvar alpha = (distance - this._limitInner) / (this._limitOuter - this._limitInner);\n\t\t\tvar toAccum = (1-alpha)*this._accumValueInner + alpha*this._accumValueOuter;\n\t\t\tthis._accumValueCurrent += (toAccum * timeDelta);\n\t\t\tif(this._accumValueCurrent > 1){\n\t\t\t\tstatus = TrackPolicyTrigger.StartStatus.YES;\n\t\t\t}else{\n\t\t\t\tstatus = TrackPolicyTrigger.StartStatus.LATER;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n};\n\n/**\n * Called to notify trigger to reset state\n */\nTrackPolicyTriggerDiscomfort.prototype.reset = function(){\n\tthis._accumValueCurrent = 0;\n};\n\nmodule.exports = TrackPolicyTriggerDiscomfort;\n\n\n"],"sourceRoot":"/source/"}