{"version":3,"sources":["ifr-motion/base/Pose.js"],"names":[],"mappings":"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","file":"ifr-motion/base/Pose.js","sourcesContent":["/**\n * A pose is a set of values indicating the position of one or more DOFs.  Pose objects\n * are used to store and transfer these values.  Each Pose object has a fixed set of entries\n * (DOF names) that it will store values for.  It is ok to transfer data between poses\n * that have different sets of entries; only the overlapping data is transferred.\n *\n * A lazy-init is provided for cases where it is inconvenient to know ahead of time the\n * set of desired dof names; the set of dof names will be taken from the first Pose object\n * copied into the local instance using setPose.\n *\n * @author mattb, jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar namesToIndex = null;\nvar indexToName = null;\nvar globalNumDOFs = null;\n\nvar globalSetup = function(dofNames){\n\t//console.log(\"Global setup of Pose with \"+dofNames.toString());\n\tglobalNumDOFs = dofNames.length;\n\tnamesToIndex = new Array(globalNumDOFs);\n\tindexToName = new Array(globalNumDOFs);\n\tfor(var i = 0; i < globalNumDOFs; i++){\n\t\tnamesToIndex[dofNames[i]] = i;\n\t\tindexToName[i] = dofNames[i];\n\t}\n};\n\nvar setupDOFNamesFromNames = function(pose, dofNames){\n\tvar dofIndex;\n\tif(pose.dofNames !== null){\n\t\tthrow new Error (\"Cannot re-setup pose with new dofnames!\");\n\t}\n\tif(namesToIndex === null){\n\t\tthrow new Error (\"Pose used before __globalSetup!\");\n\t}\n\tpose.dofNames = dofNames;\n\tpose.dofIndices = new Array(dofNames.length);\n\tpose.dofPresent = new Array(globalNumDOFs);\n\tpose.dofVals = new Array(globalNumDOFs);\n\tfor(dofIndex = 0; dofIndex < globalNumDOFs; dofIndex++){\n\t\tpose.dofPresent[dofIndex] = false;\n\t}\n\tfor(var i = 0; i < dofNames.length; i++){\n\t\tdofIndex = namesToIndex[dofNames[i]];\n\t\tif(typeof dofIndex === \"undefined\"){\n\t\t\tthrow new Error (\"Cannot use DOF \"+dofNames[i]+\", not in dofset!\");\n\t\t}\n\t\tpose.dofIndices[i] = dofIndex;\n\t\tpose.dofPresent[dofIndex] = true;\n\t\tpose.dofVals[dofIndex] = [];\n\t}\n};\n\n/**\n * @param {string} name the name of this pose\n * @param {Array.<string>} [dofNames=null] array of DOF names that this pose will store values for (use null for lazy-init via setPose)\n * @constructor\n */\nvar Pose = function(name, dofNames)\n{\n\t/** @type {string} */\n\tthis.name = name;\n\t/** @type {Array.<string>} */\n\tthis.dofNames = null;\n\t/** @type {Array.<number>} */\n\tthis.dofIndices = null;\n\t/** @type {Array.<boolean>} */\n\tthis.dofPresent = null;\n\n\t/** @type {Object.<number, Array>} */\n\tthis.dofVals = null;\n\n\tif((dofNames !== undefined)){\n\t\tsetupDOFNamesFromNames(this, dofNames);\n\t}\n};\n\n/**\n * Set all entries in this Pose to the values contained in the specified pose.  DOF entries in\n * this pose not contained in the specified pose are left as is.\n *\n * If this pose was constructed with a null array of DOF names (lazy-init), then the first time this function is\n * called the local set of entries will be copied fully from the specified pose; subsequent calls\n * will behave as normal with this set of entries/DOF names.\n *\n * @param {Pose} pose pose to copy values from into this instance\n */\nPose.prototype.setPose = function(pose)\n{\n\tif (this.dofNames === null)\n\t{\n\t\tsetupDOFNamesFromNames(this, pose.dofNames);\n\t}\n\n\tfor (var i=0; i<this.dofIndices.length; i++)\n\t{\n\t\tvar dofIndex = this.dofIndices[i];\n\t\tif (pose.dofPresent[dofIndex])\n\t\t{\n\t\t\tvar v = pose.dofVals[dofIndex];\n\t\t\tvar myV = this.dofVals[dofIndex];\n\t\t\tfor(var j = 0; j < v.length; j++){\n\t\t\t\tmyV[j] = v[j];\n\t\t\t}\n\t\t\tmyV.length = v.length;\n\t\t}\n\t}\n};\n\n/**\n * @param {Pose} inplacePose pose to copy this instance's values into\n */\nPose.prototype.getPose = function(inplacePose)\n{\n\tinplacePose.setPose(this);\n};\n\n/**\n * Set the entry for the specified DOF name to the specified value.  If the specified DOF name\n * is not an element of this pose, this call has no effect.\n *\n * If derivativeIndex is specified, value is interpreted as a specific element in the DOF's\n * position-derivative array.  If derivativeIndex is left undefined, value must specify the\n * DOF's full position-derivative array.\n *\n * @param {string} dofName name of the DOF entry to set\n * @param {Array|*} value DOF value to set: either the full position-derivative array, or (if derivativeIndex is specified) a single element in the position-derivative array\n * @param {number} [derivativeIndex] derivative index of the specified value (e.g. 0 for position, 1 for first derivative, 2 for second derivative, etc.)\n */\nPose.prototype.set = function(dofName, value, derivativeIndex)\n{\n\tvar dofIndex = namesToIndex[dofName];\n\tif(this.dofPresent[dofIndex]){\n\t\tif(typeof derivativeIndex !== \"undefined\"){\n\t\t\tthis.dofVals[dofIndex][derivativeIndex] = value;\n\t\t}else{\n\t\t\tthis.dofVals[dofIndex] = value;\n\t\t}\n\t}\n};\n\n/**\n * Get the value for the specified DOF.  If the specified DOF is not an\n * element of this pose, null is returned.\n *\n * If derivativeIndex is specified, this call will return the specified element of the DOF's\n * position-derivative array, or null if no such element exists.\n *\n * @param {string} dofName name of the DOF value to get\n * @param {number} [derivativeIndex] derivative index to get (e.g. 0 for position, 1 for first derivative, 2 for second derivative, etc.)\n * @return {Array|*} the requested DOF value, or null if not present\n */\nPose.prototype.get = function(dofName, derivativeIndex)\n{\n\tvar dofIndex = namesToIndex[dofName];\n\tif (this.dofPresent[dofIndex]){\n\t\tvar val;\n\t\tif (derivativeIndex !== undefined)\n\t\t{\n\t\t\tval = this.dofVals[dofIndex][derivativeIndex];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval = this.dofVals[dofIndex];\n\t\t}\n\t\treturn (val !== undefined) ? val : null;\n\t}\n\telse\n\t{\n\t\treturn null;\n\t}\n};\n\n/**\n * @return {string} the name of this pose\n */\nPose.prototype.getName = function()\n{\n\treturn this.name;\n};\n\n/**\n * @return {Array.<string>} the array of DOF names that this pose stores values for\n */\nPose.prototype.getDOFNames = function()\n{\n\treturn this.dofNames;\n};\n\n/**\n * clear the DOF values stored in this pose\n */\nPose.prototype.clear = function()\n{\n\tif (this.dofNames !== null)\n\t{\n\t\tfor (var i=0; i<this.dofIndices.length; i++)\n\t\t{\n\t\t\tthis.dofVals[this.dofIndices[i]].length = 0;\n\t\t}\n\t}\n};\n\n/**\n * Get a copy of this pose that does not share any reps.\n *\n * @param {string} [name] - optional, will use original name if omitted\n * @return {Pose}\n */\nPose.prototype.getCopy = function(name){\n\tvar p = new Pose(name!=null?name:this.name); //null or undefined (eqnull)\n\n\tvar originalDOFNames = this.dofNames;\n\tvar originalDOFIndices = this.dofIndices;\n\tvar originalDOFPresent = this.dofPresent;\n\tvar numDOFs = originalDOFNames.length;\n\tvar copiedDOFNames = new Array(numDOFs);\n\tvar copiedDOFIndices = new Array(numDOFs);\n\tvar copiedDOFPresent = new Array(globalNumDOFs);\n\tfor(var i = 0; i < numDOFs; i++){\n\t\tcopiedDOFNames[i] = originalDOFNames[i];\n\t\tcopiedDOFIndices[i] = originalDOFIndices[i];\n\t}\n\tfor(var k = 0; k < globalNumDOFs; k++){\n\t\tcopiedDOFPresent[k] = originalDOFPresent[k];\n\t}\n\tp.dofNames = copiedDOFNames;\n\tp.dofIndices = copiedDOFIndices;\n\tp.dofPresent = copiedDOFPresent;\n\tp.dofVals = new Array(numDOFs);\n\n\tfor (var ii=0; ii< numDOFs; ii++)\n\t{\n\t\tvar dofIndex = originalDOFIndices[ii];\n\t\tvar origVal = this.dofVals[dofIndex];\n\t\tvar newVal = new Array(origVal.length);\n\t\tfor(var j = 0; j < origVal.length; j++){\n\t\t\tnewVal[j] = origVal[j];\n\t\t}\n\t\tp.dofVals[dofIndex] = newVal;\n\t}\n\treturn p;\n};\n\n/**\n * Operator for computeBinary.  Will only be called on non-null arguments\n * (e.g., both poses contain the dof.).  They could have zero elements however.\n *\n * @callback binaryOperator\n * @param {string} dofName\n * @param {number[]} pose1Data\n * @param {number[]} pose2Data\n * @return {number[]}\n */\n\n/**\n * Only the values present in both a, b, and inplaceResult\n * will be computed and stored in inplaceResult.  If clearUnused is true,\n * then values in inplaceResult but not in a AND b will be cleared.\n * If inplaceResult is null or omitted, it will be created and will have\n * values present in a AND b.  Any or all arguments can point to the same Pose.\n *\n * @param {Pose} a\n * @param {Pose} b\n * @param {binaryOperator} operator\n * @param {boolean} [clearUnused=false] - clear elements in result not in (a AND b), otherwise leave them as is.\n * @param {Pose} [result=null]\n */\nPose.computeBinary = function(a, b, operator, clearUnused, result){\n\tvar i, dofIndex;\n\tif(result == null || result.dofNames == null){ //null or undefined (eqnull)\n\t\t//we'll go here if result is \"blank\" (no dof names set yet) or not provided.\n\t\tif(result == null) {\n\t\t\tresult = new Pose(a.getName() + \" x \" + b.getName());\n\t\t}\n\t\tvar intersectingDofNames = [];\n\t\tfor (dofIndex=0; dofIndex < globalNumDOFs; dofIndex++){\n\t\t\tif(a.dofPresent[dofIndex] && b.dofPresent[dofIndex]){\n\t\t\t\tintersectingDofNames.push(indexToName[dofIndex]);\n\t\t\t}\n\t\t}\n\t\tsetupDOFNamesFromNames(result, intersectingDofNames);\n\n\t}\n\n\tfor (i=0; i<result.dofIndices.length; i++){\n\t\tdofIndex = result.dofIndices[i];\n\t\tif (a.dofPresent[dofIndex] && b.dofPresent[dofIndex]){ //everyone's got it\n\t\t\tresult.dofVals[dofIndex] = operator(result.dofNames[i], a.dofVals[dofIndex], b.dofVals[dofIndex]);\n\t\t}else if(clearUnused){\n\t\t\tresult.dofVals[dofIndex].length = 0;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Operator for computeUnary.  Will only be called on non-null arguments\n * (e.g., pose contains the dof.).  It may have zero elements however.\n *\n * @callback unaryOperator\n * @param {string} dofName\n * @param {number[]} poseData\n * @return {number[]}\n */\n\n/**\n * Only the values present in a and inplaceResult\n * will be computed and stored in inplaceResult.  If clearUnused is true,\n * then values in inplaceResult but not in a will be cleared.\n * If inplaceResult is null or omitted, it will be created and will have\n * values present in a.  Any or all arguments can point to the same Pose.\n *\n * @param {Pose} a\n * @param {unaryOperator} operator\n * @param {boolean} [clearUnused=false] - clear elements in result not in a, otherwise leave them as is.\n * @param {Pose} [result=null]\n */\nPose.computeUnary = function(a, operator, clearUnused, result){\n\tvar i, dofIndex;\n\tif(result == null || result.dofNames == null){ //null or undefined (eqnull)\n\t\t//we'll go here if result is \"blank\" (no dof names set yet) or not provided.\n\t\tif(result == null) {\n\t\t\tresult = new Pose(a.getName(), a.dofNames);\n\t\t}else{\n\t\t\tsetupDOFNamesFromNames(result, a.dofNames);\n\t\t}\n\t}\n\n\tfor (i=0; i<result.dofIndices.length; i++){\n\t\tdofIndex = result.dofIndices[i];\n\t\tif (a.dofPresent[dofIndex]){ //everyone has it\n\t\t\tresult.dofVals[dofIndex] = operator(result.dofNames[i], a.dofVals[dofIndex]);\n\t\t}else if(clearUnused){\n\t\t\tresult.dofVals[dofIndex].length = 0;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n\n/**\n *\n * @param {string} dofName\n * @param {number[]} pose1Data\n * @param {number[]} pose2Data\n * @return {number[]}\n * @private\n */\nPose._subtractOperator = function(dofName, pose1Data, pose2Data){\n\tvar result = [];\n\tvar p10 = pose1Data.length>0?pose1Data[0]:0;\n\tvar p20 = pose2Data.length>0?pose2Data[0]:0;\n\tresult[0] = p10 - p20; //do at least the first (position), even if it's not explicitly present, will be treated as zero.\n\tvar i = 1;\n\twhile(i < pose1Data.length && i < pose2Data.length){\n\t\tresult.push(pose1Data[i] - pose2Data[i]);\n\t\ti++;\n\t}\n\treturn result;\n};\n\n/**\n *\n * @param {string} dofName\n * @param {number[]} pose1Data\n * @param {number[]} pose2Data\n * @return {number[]}\n * @private\n */\nPose._additionOperator = function(dofName, pose1Data, pose2Data){\n\tvar result = [];\n\tvar p10 = pose1Data.length>0?pose1Data[0]:0;\n\tvar p20 = pose2Data.length>0?pose2Data[0]:0;\n\tresult[0] = p10 + p20; //do at least the first (position), even if it's not explicitly present, will be treated as zero.\n\tvar i = 1;\n\twhile(i < pose1Data.length && i < pose2Data.length){\n\t\tresult.push(pose1Data[i] + pose2Data[i]);\n\t\ti++;\n\t}\n\treturn result;\n};\n\n/**\n * Compute the advance of dofs in poseData by their velocities, optionally by the time specified (can be negative).\n * Dofs with no velocity are not advanced.  derivative data passed through to result unchanged.\n *\n * @param {string} dofName\n * @param {number[]} poseData\n * @param {number} [time=1]\n * @return {number[]}\n * @private\n */\nPose._advanceByVelocityOperator = function(dofName, poseData, time){\n\tvar result = [];\n\tif(poseData.length > 0) {\n\t\tif (time == null) {//null of undefined (eqnull)\n\t\t\ttime = 1;\n\t\t}\n\t\tvar velocity = 0;\n\t\tif (poseData.length >= 2) {\n\t\t\tvelocity = poseData[1];\n\t\t}\n\t\tresult[0] = (velocity * time + poseData[0]);\n\n\t\tfor(var i = 1; i < poseData.length; i++) {\n\t\t\tresult.push(poseData[i]);\n\t\t}\n\t}\n\treturn result;\n};\n\n\n/**\n * Only the values present in both a, b, and inplaceResult\n * will be subtracted and stored in inplaceResult.  If clearUnused is true,\n * then values in inplaceResult but not in a AND b will be cleared.\n * If inplaceResult is null or omitted, it will be created and will have\n * values present in a AND b.  Any or all arguments can point to the same Pose.\n *\n * Derivatives will be subtracted if both are present for a dof.  Positions will\n * always be subtracted for dofs in all poses.\n *\n * @param {Pose} a\n * @param {Pose} b\n * @param {boolean} [clearUnused=false] - clear elements in result not in (a AND b), otherwise leave them as is.\n * @param {Pose} [result=null]\n */\nPose.subtract = function(a, b, clearUnused, result){\n\treturn Pose.computeBinary(a, b, Pose._subtractOperator, clearUnused, result);\n};\n\n/**\n * Only the values present in both a, b, and inplaceResult\n * will be added and stored in inplaceResult.  If clearUnused is true,\n * then values in inplaceResult but not in a AND b will be cleared.\n * If inplaceResult is null or omitted, it will be created and will have\n * values present in a AND b.  Any or all arguments can point to the same Pose.\n *\n * Derivatives will be added if both are present for a dof.  Positions will\n * always be added for dofs in all poses.\n *\n * @param {Pose} a\n * @param {Pose} b\n * @param {boolean} [clearUnused=false] - clear elements in result not in (a AND b), otherwise leave them as is.\n * @param {Pose} [result=null]\n */\nPose.add = function(a, b, clearUnused, result){\n\treturn Pose.computeBinary(a, b, Pose._additionOperator, clearUnused, result);\n};\n\n/**\n * Only the values present in a and inplaceResult\n * will be advanced and stored in inplaceResult.  If clearUnused is true,\n * then values in inplaceResult but not in a will be cleared.\n * If inplaceResult is null or omitted, it will be created and will have\n * values present in a.  Any or all arguments can point to the same Pose.\n * Empty velocities are assumed to be zero.\n *\n * @param a - pose to advance\n * @param clearUnused - clear elements in result not used in a\n * @param result - resulting advanced pose\n * @param [time=null] - if omitted or null, default (1) will be used\n */\nPose.advanceByTime = function(a, clearUnused, result, time){\n\tif(time == null){\n\t\treturn Pose.computeUnary(a, Pose._advanceByVelocityOperator, clearUnused, result);\n\t}else{\n\t\treturn Pose.computeUnary(a, function(dofName, poseData){\n\t\t\treturn Pose._advanceByVelocityOperator(dofName, poseData, time);\n\t\t}, clearUnused, result);\n\t}\n};\n\nPose.prototype.toString = function(){\n\tvar s = \"Pose{\";\n\tfor(var i = 0; i < this.dofNames.length; i++){\n\t\ts+=this.dofNames[i]+\":[\"+this.dofVals[this.dofIndices[i]].toString()+\"]\";\n\t\tif(i < this.dofNames.length-1){\n\t\t\ts+=\",\";\n\t\t}\n\t}\n\treturn s+\"}\";\n};\n\nPose.__globalSetup = globalSetup;\n\nmodule.exports = Pose;"],"sourceRoot":"/source/"}