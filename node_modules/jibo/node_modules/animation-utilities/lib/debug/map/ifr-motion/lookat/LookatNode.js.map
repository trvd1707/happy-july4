{"version":3,"sources":["ifr-motion/lookat/LookatNode.js"],"names":[],"mappings":"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","file":"ifr-motion/lookat/LookatNode.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar PointADOF = require(\"./PointADOF\");\nvar slog = require(\"../../ifr-core/SLog\");\n\nvar channel = \"LOOKAT\";\n\nvar PointNodeReport = function(){\n\t/**\n\t * 0 for unstable target, 1 for very stable\n\t * @type {?number} */\n\tthis._targetStability = null;\n\tthis._pointSucceeded = true;\n};\n\n\n/**\n *\n * @param {string} name\n * @param {LookatDOF[]} lookatDOFs - assumed to be in order root to leaf\n * @param {KinematicGroup} myKinematicGroup\n * @constructor\n */\nvar LookatNode = function(name, lookatDOFs){\n\t/** @type {string} */\n\tthis._name = name;\n\t/** @type {LookatDOF[]} */\n\tthis._lookatDOFs = lookatDOFs;\n\t/** @type {KinematicGroup} */\n\tthis._kinematicGroup = null;\n};\n\nLookatNode.PointNodeReport = PointNodeReport;\n\n/**\n * @param {KinematicGroup} kinematicGroup\n */\nLookatNode.prototype.connectToGroup = function(kinematicGroup){\n\tthis._kinematicGroup = kinematicGroup;\n\n\tfor(var i = 0; i < this._lookatDOFs.length; i++){\n\t\tthis._lookatDOFs[i].connectToGroup(this._kinematicGroup);\n\t}\n};\n\n/**\n *\n * @param {PointReport} newDOFReport\n * @param {PointNodeReport} nodeReportInplace\n */\nfunction updateReport(newDOFReport, nodeReportInplace, pointSucceeded){\n\tvar angleValue = newDOFReport._angleToAxis / (Math.PI/2);\n\tvar distanceValue = Math.min(newDOFReport._distanceToTarget * 5, 1); //1 for >20cm, linear score down to 0 from there.\n\tif(nodeReportInplace._targetStability === null){\n\t\tnodeReportInplace._targetStability = angleValue * distanceValue;\n\t}else{\n\t\tnodeReportInplace._targetStability *= (angleValue * distanceValue);\n\t}\n\tif(!pointSucceeded){\n\t\tnodeReportInplace._pointSucceeded = false;\n\t}\n\t//if(nodeReportInplace._targetStability > 1.001){\n\t//\tconsole.log(\"stability = \"+nodeReportInplace._targetStability+\", \"+newDOFReport._angleToAxis+\", \"+newDOFReport._distanceToTarget);\n\t//}\n}\n\n/**\n *\n * @param {Pose} currentPose\n * @param {Pose} inplaceOutput\n * @param {THREE.Vector3} target\n * @param {Pose} [defaultPose] - use this pose's values in place of values that cannot be currently computed. (currentPose used if ommitted)\n * @param {PointReport} [pointNodeReport] - inplace arg to return metadata about combined computation\n * @return {boolean} true if all nodes computed a value; false if one or more was uncomputable and had to utilize defaultPose.\n */\nLookatNode.prototype.getPose = function(currentPose, inplaceOutput, target, defaultPose, pointNodeReport){\n\tif(inplaceOutput!==currentPose) { //no need if they are the same instance..\n\t\tinplaceOutput.setPose(currentPose);\n\t}\n\n\tif(defaultPose == null){ //null or undefined (eqnull)\n\t\tdefaultPose = currentPose;\n\t}\n\n\tvar anyFailures = false;\n\n\tthis._kinematicGroup.setFromPose(currentPose);\n\tthis._kinematicGroup.getRoot().updateMatrixWorld(true);\n\n\tvar pointDOFReport = null;\n\n\tfor(var i = 0; i < this._lookatDOFs.length; i++){\n\t\tif(pointNodeReport){\n\t\t\tpointDOFReport = new PointADOF.PointReport();\n\t\t}\n\n\t\tvar value = this._lookatDOFs[i].valToPointAtTarget(target, pointDOFReport);\n\n\t\tif(pointDOFReport){\n\t\t\tupdateReport(pointDOFReport, pointNodeReport, value != null);\n\t\t}\n\n\t\tif(value != null){\n\t\t\tinplaceOutput.set(this._lookatDOFs[i].getControlledDOFName(), value, 0);\n\t\t}else{\n\t\t\tslog(channel, \"LookatNode \"+this._name+\" using last value due to uncomputable value for target (\"+target.x+\", \"+target.y+\", \"+target.z+\")\");\n\t\t\tinplaceOutput.set(this._lookatDOFs[i].getControlledDOFName(), defaultPose.get(this._lookatDOFs[i].getControlledDOFName(),0),0);\n\t\t\tanyFailures = true;\n\t\t}\n\t\tif(i < this._lookatDOFs.length-1){ //more updating to do\n\t\t\tthis._kinematicGroup.setFromPose(inplaceOutput);\n\t\t\tthis._kinematicGroup.getRoot().updateMatrixWorld(true);\n\t\t}\n\t}\n\n\treturn !anyFailures;\n};\n\n/**\n * Get all the dofs that are modified by this node\n * @return {string[]}\n */\nLookatNode.prototype.getDOFs = function(){\n\tvar allDOFs = [];\n\tfor(var i = 0; i < this._lookatDOFs.length; i++){\n\t\tallDOFs.push(this._lookatDOFs[i].getControlledDOFName());\n\t}\n\treturn allDOFs;\n};\n\n/**\n * Find the distance between 2 poses, only accounting for DOFs that are part of this LookatNode.\n * The difference is calculated as a ratio (of error over dof range) rather than absolute value.\n * This function is designed to give a metric lookat progress, e.g., pass in optimal and\n * filtered/current to see how far the lookat still has to go.\n *\n * @param {Pose} pose1\n * @param {Pose} pose2\n * @return {number} greatest ratio (distance/totalDistance) of any of our lookat DOFs between pose1 to pose2\n */\nLookatNode.prototype.distanceAsRatio = function(pose1, pose2){\n\tvar maxRatio = 0;\n\tfor(var i = 0; i < this._lookatDOFs.length; i++) {\n\t\tvar lookatDOF = this._lookatDOFs[i];\n\t\tvar dofName = lookatDOF.getControlledDOFName();\n\t\tvar p1v = pose1.get(dofName, 0);\n\t\tvar p2v = pose2.get(dofName, 0);\n\t\tvar ratio = lookatDOF.errorRatio(p1v-p2v);\n\t\tif(ratio > maxRatio){\n\t\t\tmaxRatio = ratio;\n\t\t}\n\t}\n\treturn maxRatio;\n};\n\n/**\n * @returns {string}\n */\nLookatNode.prototype.getName = function(){\n\treturn this._name;\n};\n\n/**\n *\n * @param {Pose} currentPose - use this current pose\n * @param {THREE.Vector3} inplaceVec\n * @return {THREE.Vector3} a suggestion for a target that is forward for this lookat (node is already looking at this point)\n */\nLookatNode.prototype.suggestForwardTarget = function(currentPose, inplaceVec){\n\tthis._kinematicGroup.setFromPose(currentPose);\n\tthis._kinematicGroup.getRoot().updateMatrixWorld(true);\n\treturn this._lookatDOFs[0].suggestForwardTarget(inplaceVec);\n};\n\n\n\nmodule.exports = LookatNode;"],"sourceRoot":"/source/"}