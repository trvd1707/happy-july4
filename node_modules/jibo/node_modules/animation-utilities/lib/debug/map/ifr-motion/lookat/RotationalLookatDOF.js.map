{"version":3,"sources":["ifr-motion/lookat/RotationalLookatDOF.js"],"names":[],"mappings":";;;;;AAKA;;AAEA,IAAI,QAAQ,QAAQ,OAAR,CAAR;AACJ,IAAI,YAAY,QAAQ,aAAR,CAAZ;AACJ,IAAI,YAAY,QAAQ,aAAR,CAAZ;;;;;;;;;;AAUJ,IAAI,sBAAsB,SAAtB,mBAAsB,CAAS,IAAT,EAAe,iBAAf,EAAkC,gBAAlC,EAAmD;AAC5E,WAAU,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2B,iBAA3B;;;AAD4E,KAI5E,CAAK,QAAL,GAAgB,IAAhB;;;AAJ4E,KAO5E,CAAK,WAAL,GAAmB,gBAAnB;;;AAP4E,KAU5E,CAAK,UAAL,GAAkB,IAAlB;;;AAV4E,KAa5E,CAAK,KAAL,GAAa,IAAb,CAb4E;CAAnD;;AAgB1B,oBAAoB,SAApB,GAAgC,OAAO,MAAP,CAAc,UAAU,SAAV,CAA9C;AACA,oBAAoB,SAApB,CAA8B,WAA9B,GAA4C,mBAA5C;;;;;AAKA,oBAAoB,SAApB,CAA8B,cAA9B,GAA+C,UAAS,cAAT,EAAwB;AACtE,WAAU,SAAV,CAAoB,cAApB,CAAmC,IAAnC,CAAwC,IAAxC,EAA8C,cAA9C,EADsE;AAEtE,KAAG,KAAK,eAAL,EAAsB;AACxB,OAAK,QAAL,GAAgB,KAAK,eAAL,CAAqB,oBAArB,GAA4C,gBAA5C,CAA6D,KAAK,kBAAL,CAA7E,CADwB;AAExB,OAAK,UAAL,GAAkB,KAAK,eAAL,CAAqB,YAArB,CAAkC,KAAK,QAAL,CAAc,gBAAd,EAAlC,CAAlB,CAFwB;AAGxB,OAAK,KAAL,GAAa,IAAI,MAAM,OAAN,EAAjB,CAHwB;AAIxB,OAAK,QAAL,CAAc,iBAAd,CAAgC,KAAK,KAAL,CAAhC,CAJwB;EAAzB,MAKK;AACJ,OAAK,UAAL,GAAkB,IAAlB,CADI;AAEJ,OAAK,QAAL,GAAgB,IAAhB,CAFI;AAGJ,OAAK,KAAL,GAAa,IAAb,CAHI;EALL;CAF8C;;;;;;;;;;AAuB/C,oBAAoB,SAApB,CAA8B,kBAA9B,GAAmD,UAAS,MAAT,EAAiB,WAAjB,EAA6B;AAC/E,QAAO,UAAU,QAAV,CAAmB,KAAK,QAAL,EAAe,KAAK,UAAL,EAAiB,KAAK,WAAL,EAAkB,MAArE,EAA6E,WAA7E,CAAP,CAD+E;CAA7B;;;;;;;;;;AAYnD,oBAAoB,SAApB,CAA8B,UAA9B,GAA2C,UAAS,aAAT,EAAuB;AACjE,KAAG,KAAK,QAAL,CAAc,QAAd,EAAH,EAA4B;AAC3B,SAAO,KAAK,GAAL,CAAS,iBAAiB,KAAK,EAAL,GAAQ,CAAR,CAAjB,CAAhB,CAD2B;EAA5B,MAEK;AACJ,SAAO,KAAK,GAAL,CAAS,iBAAiB,KAAK,QAAL,CAAc,MAAd,KAAuB,KAAK,QAAL,CAAc,MAAd,EAAvB,CAAjB,CAAhB,CADI;EAFL;CAD0C;;;;;;;;AAc3C,oBAAoB,SAApB,CAA8B,oBAA9B,GAAqD,UAAS,UAAT,EAAoB;AACxE,KAAG,KAAK,UAAL,IAAmB,IAAnB,EAAwB;AAC1B,SAAO,IAAP,CAD0B;EAA3B,MAEK;AACJ,aAAW,IAAX,CAAgB,KAAK,WAAL,CAAhB,CADI;AAEJ,aAAW,cAAX,CAA0B,EAA1B,EAFI;AAGJ,OAAK,UAAL,CAAgB,YAAhB,CAA6B,UAA7B,EAHI;AAIJ,SAAO,UAAP,CAJI;EAFL;CADoD;;AAWrD,OAAO,OAAP,GAAiB,mBAAjB","file":"ifr-motion/lookat/RotationalLookatDOF.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar THREE = require(\"three\");\nvar PointADOF = require(\"./PointADOF\");\nvar LookatDOF = require(\"./LookatDOF\");\n\n/**\n *\n * @param {string} name\n * @param {string} controlledDOFName\n * @param {THREE.Vector3} forwardDirection\n * @extends LookatDOF\n * @constructor\n */\nvar RotationalLookatDOF = function(name, controlledDOFName, forwardDirection){\n\tLookatDOF.call(this, name, controlledDOFName);\n\n\t/** @type {RotationControl} */\n\tthis._control = null;\n\n\t/**\t@type {THREE.Vector3} */\n\tthis._forwardDir = forwardDirection;\n\n\t/** @type {THREE.Object3D} */\n\tthis._transform = null;\n\n\t/** @type {THREE.Vector3} */\n\tthis._axis = null;\n};\n\nRotationalLookatDOF.prototype = Object.create(LookatDOF.prototype);\nRotationalLookatDOF.prototype.constructor = RotationalLookatDOF;\n\n/**\n * @param {KinematicGroup} kinematicGroup group to use for kinematic math (assumed to be configured as desired before valToPointAtTarget calls)\n */\nRotationalLookatDOF.prototype.connectToGroup = function(kinematicGroup){\n\tLookatDOF.prototype.connectToGroup.call(this, kinematicGroup);\n\tif(this._kinematicGroup) {\n\t\tthis._control = this._kinematicGroup.getModelControlGroup().getControlForDOF(this._controlledDOFName);\n\t\tthis._transform = this._kinematicGroup.getTransform(this._control.getTransformName());\n\t\tthis._axis = new THREE.Vector3();\n\t\tthis._control.getRotationalAxis(this._axis);\n\t}else{\n\t\tthis._transform = null;\n\t\tthis._control = null;\n\t\tthis._axis = null;\n\t}\n};\n\n\n/**\n * Compute value is relative to current setup of the hierarchy that this._transform is part of.\n *\n * @param {THREE.Vector2} target\n * @return {number} Value to cause this._control to point local this._forwardDir at the target\n * @param {PointReport} [pointReport] - inplace arg to return metadata about computation\n * @override\n */\nRotationalLookatDOF.prototype.valToPointAtTarget = function(target, pointReport){\n\treturn PointADOF.pointDOF(this._control, this._transform, this._forwardDir, target, pointReport);\n};\n\n/**\n * Provide the ratio that this error represents for the range of motion of this LookatDOF.\n * For cyclic dofs, range is considered one revolution.\n *\n * @param errorAbsolute absolute error\n * @return {number} ratio that absoluteError represents of the total range of this LookatDOF\n * @override\n */\nRotationalLookatDOF.prototype.errorRatio = function(errorAbsolute){\n\tif(this._control.isCyclic()){\n\t\treturn Math.abs(errorAbsolute / (Math.PI*2));\n\t}else{\n\t\treturn Math.abs(errorAbsolute / (this._control.getMax()-this._control.getMin()));\n\t}\n};\n\n/**\n * provide a suggestion for a target that is forward for this lookat (node is already looking at this point)\n * @param {THREE.Vector3} inplaceVec\n * @return {THREE.Vector3}\n * @override\n */\nRotationalLookatDOF.prototype.suggestForwardTarget = function(inplaceVec){\n\tif(this._transform == null){\n\t\treturn null;\n\t}else{\n\t\tinplaceVec.copy(this._forwardDir);\n\t\tinplaceVec.multiplyScalar(10);\n\t\tthis._transform.localToWorld(inplaceVec);\n\t\treturn inplaceVec;\n\t}\n};\n\nmodule.exports = RotationalLookatDOF;\n"],"sourceRoot":"/source/"}