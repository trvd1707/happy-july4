{"version":3,"sources":["ifr-motion/lookat/PointADOF.js"],"names":[],"mappings":"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","file":"ifr-motion/lookat/PointADOF.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar THREE = require(\"three\");\nvar slog = require(\"../../ifr-core/SLog\");\n\nvar channel = \"LOOKAT\";\n\nvar epsilon = 0.001; //TODO: THREE has a high epsilon for converting quaternions to axis angle, ours could decrease if we switched implementation there\nvar epsilonSquared = epsilon*epsilon;\nvar visHelper = null;\n\nvar PointReport = function(){\n\t/**\n\t * value 0 to PI/2 representing angle from target vec to axis (0 means solution arbitrary)\n\t * @type {?number} */\n\tthis._angleToAxis = null;\n\tthis._distanceToTarget = null;\n};\n\nvar PointADOF = {name:\"PointADOF\"};\n\nPointADOF.PointReport = PointReport;\n\nPointADOF.setVisHelper = function(useVisHelper){\n\tvisHelper = useVisHelper;\n};\n\n/**\n * Find unsigned distance between \"angle\" and closest multiple of PI\n *\n * Find the min angle between a direction vector and a line (i.e., should always be 0 to PI/2)\n * @param angle - angle from a direction vector to a line\n */\nvar minAngleToLine = function(angle){\n\tangle = Math.abs(angle % Math.PI); //now between 0 and PI\n\tangle = Math.abs(Math.PI/2 - angle); //now between 0==ortho and PI/2==aligned\n\tangle = Math.PI/2 - angle; //now between 0==aligned, PI/2==ortho\n\treturn angle;\n};\n\n/**\n * @param {number} original\n * @param {number} min\n * @param {number} max\n * @returns {number} value cyclically equivalent to original.  between min/max if possible, otherwise original is returned.\n */\n// eslint-disable-next-line no-unused-vars\nvar replaceWithInLimitEquivalentIfPossible = function(original, min, max){\n\tvar diff, numCircles, testOriginal;\n\tif(original > max){\n\t\tdiff = original - max;\n\t\tnumCircles = Math.ceil(diff / (Math.PI*2));\n\t\ttestOriginal = original - (Math.PI*2)*numCircles;\n\t\tif(testOriginal >= min){\n\t\t\treturn testOriginal;\n\t\t}else{\n\t\t\treturn original;\n\t\t}\n\t}else if(original < min){\n\t\tdiff = min - original;\n\t\tnumCircles = Math.ceil(diff / (Math.PI*2));\n\t\ttestOriginal = original + (Math.PI*2)*numCircles;\n\t\tif(testOriginal <= max){\n\t\t\treturn testOriginal;\n\t\t}else{\n\t\t\treturn original;\n\t\t}\n\t}else{\n\t\treturn original;\n\t}\n};\n\n\n/**\n *\n * @param {THREE.Vector4} axisAngleV4 - rotational axis in XYZ (normalized), rotation magnitude in radians in W\n * @param {THREE.Vector3} referenceAxisV3 - assumed to be normalized\n * @return {number}\n */\nvar correctAngleSign = function(axisAngleV4, referenceAxisV3){\n\tvar calculatedAxis = new THREE.Vector3().copy(axisAngleV4);\n\tvar angleNow = calculatedAxis.angleTo(referenceAxisV3);\n\tvar angleInv = calculatedAxis.multiplyScalar(-1).angleTo(referenceAxisV3);\n\tif(angleNow <= angleInv){\n\t\t//ok\n\t\tif(angleNow > 0.1 && minAngleToLine(axisAngleV4.w) > epsilon){ //expect arbitrary axes for singular rotations\n\t\t\tslog(channel, \"Error, computed axis (\"+calculatedAxis.x+\", \"+calculatedAxis.y+\", \"+calculatedAxis.z+\") not so close (\"+angleNow+\") to references axis (\"+referenceAxisV3.x+\", \"+referenceAxisV3.y+\", \"+referenceAxisV3.z+\"), angle = \"+axisAngleV4.w);\n\t\t\treturn null;\n\t\t}\n\t\treturn axisAngleV4.w;\n\t}else {\n\t\t//use inverse\n\t\tif(angleInv > 0.1 && minAngleToLine(axisAngleV4.w) > epsilon){ //expect arbitrary axes for singular rotations\n\t\t\tslog(channel, \"Error, computed axis (\"+calculatedAxis.x+\", \"+calculatedAxis.y+\", \"+calculatedAxis.z+\") not so close (\"+angleNow+\") to references axis (\"+referenceAxisV3.x+\", \"+referenceAxisV3.y+\", \"+referenceAxisV3.z+\"), angle = \"+axisAngleV4.w);\n\t\t\treturn null;\n\t\t}\n\t\treturn -axisAngleV4.w;\n\t}\n};\n\n\n/**\n * Gets the angle between forward and target, with all restricted to the plane provided\n * All are in the local coordinate space of transform (except target).  angleOrigin can be used\n * to change the origin point from which the ray to target is defined if that point is not the origin\n * of transform.\n *\n * @param transform - the transform that all the params in the coordinate system of\n * @param targetPosWorld - world space target\n * @param angleOrigin - local origin to calculate angle from\n * @param angleForward - local forward dir to calculate angel from\n * @param anglePlaneNormal - local plane normal to restrict angle to\n * @param {PointReport} [pointReport] - inplace arg to return metadata about computation\n * @returns {?number}\n */\nPointADOF.getRelativeAngle = function(transform, targetPosWorld,\n\t\t\t\t\t\t\t\t\t\tangleOrigin, angleForward, anglePlaneNormal, pointReport){\n\tif(angleOrigin == null){\n\t\tangleOrigin = new THREE.Vector3(0,0,0);\n\t}\n\n\tvar localTarget = transform.worldToLocal(new THREE.Vector3().copy(targetPosWorld));\n\n\t//wa may want to have params to subtract off local trans/rot\n\t//take local rotation out of localTarget\n\t//var localRotation = new THREE.Quaternion().copy(transform.quaternion);\n\t//localTarget.applyQuaternion(localRotation);\n\n\t//take local translation out of localTarget\n\t//var localTranslation = new THREE.Quaternion().copy(transform.position);\n\t//localTarget.sub(localTranslation);\n\n\t/** @type {THREE.Vector3} */\n\tvar originToLocalTarget = (new THREE.Vector3().copy(localTarget)).sub(angleOrigin);\n\n\tif(pointReport){\n\t\tpointReport._angleToAxis = minAngleToLine(originToLocalTarget.angleTo(anglePlaneNormal));\n\t\tpointReport._distanceToTarget = originToLocalTarget.length();\n\t}\n\n\tvar forwardProjected = new THREE.Vector3().copy(angleForward).projectOnPlane(anglePlaneNormal);\n\tvar originToLocalTargetProjected = new THREE.Vector3().copy(originToLocalTarget).projectOnPlane(anglePlaneNormal);\n\n\tif(forwardProjected.lengthSq() < epsilonSquared){\n\t\tslog(channel, \"Error getting relative angle, forward too close to plane normal (\"+anglePlaneNormal.x+\", \"+anglePlaneNormal.y+\", \"+anglePlaneNormal.z+\") too close to axis (\"+anglePlaneNormal.x+\", \"+anglePlaneNormal.y+\", \"+anglePlaneNormal.z+\")\");\n\t\treturn null;\n\t}\n\tif(originToLocalTargetProjected.lengthSq() < epsilonSquared){\n\t\tslog(channel, \"Error getting relative angle, target dir too close to plane normal (\"+anglePlaneNormal.x+\", \"+anglePlaneNormal.y+\", \"+anglePlaneNormal.z+\") too close to axis (\"+originToLocalTargetProjected.x+\", \"+originToLocalTargetProjected.y+\", \"+originToLocalTargetProjected.z+\")\");\n\t\treturn null;\n\t}\n\n\toriginToLocalTargetProjected.normalize();\n\tforwardProjected.normalize();\n\n\t//arguments must be normalized\n\tvar rotationNeededQuaternion = new THREE.Quaternion().setFromUnitVectors(forwardProjected, originToLocalTargetProjected);\n\tvar axisAngleV4 = new THREE.Vector4().setAxisAngleFromQuaternion(rotationNeededQuaternion);\n\tvar signedAngle = correctAngleSign(axisAngleV4, anglePlaneNormal);\n\n\tif(visHelper !== null && visHelper.shouldDraw(this)){\n\n\t\tvisHelper.drawRayLocal(this, \"RelativeAngle:Forward\", transform, angleOrigin, angleForward, new THREE.Color(1, 0, 0));\n\n\t\tvisHelper.drawLineLocal(this, \"RelativeAngle:Target\", transform, angleOrigin, new THREE.Vector3().copy(angleOrigin).add(originToLocalTarget), new THREE.Color(0.6, 0.6, 0));\n\n\t\tvisHelper.drawLineLocal(this, \"RelativeAngle:FlatTarget\", transform, angleOrigin, new THREE.Vector3().copy(angleOrigin).add(originToLocalTargetProjected), new THREE.Color(0, 1, 1));\n\n\t\tvisHelper.drawRayLocal(this, \"RelativeAngle:AxisOfRotation\", transform, angleOrigin, anglePlaneNormal, new THREE.Color(0.5, 1, 0));\n\t\tvisHelper.drawPlaneLocal(this, \"RelativeAngle:PlaneOfRotation\", transform, angleOrigin, anglePlaneNormal, new THREE.Color(1, 0, 1));\n\t}\n\n\treturn signedAngle;\n};\n\n/**\n * This function defines an internal point in the coordinate system of transform by displacing\n * by along -forward by internalDistanceToCenter.  Then, the intersection of a line between this point\n * and target is computed in the plane defined by angleOrigin and angleForward. All values restricted to\n * the plane defined by anglePlaneNormal.\n *\n *\n * @param transform - the transform that all the params in the coordinate system of\n * @param targetPosWorld - world space target\n * @param angleOrigin - local origin to calculate angle from\n * @param angleForward - local forward dir to calculate angel from\n * @param anglePlaneNormal - local plane normal to restrict angle to\n * @param internalDistanceToCenter - distance behind the origin (-forward) to place the eye center\n * @param {PointReport} [pointReport] - inplace arg to return metadata about computation\n * @returns {?number}\n */\nPointADOF.planeIntersectFromRear = function(transform, targetPosWorld,\n\t\t\t\t\t\t\t\t\t\t\tangleOrigin, angleForward, anglePlaneNormal,\n\t\t\t\t\t\t\t\t\t\t\tinternalDistanceToCenter, pointReport) {\n\tif(angleOrigin == null){\n\t\tangleOrigin = new THREE.Vector3(0,0,0);\n\t}\n\n\tvar internalOrigin = new THREE.Vector3().copy(angleForward).normalize().multiplyScalar(-internalDistanceToCenter).add(angleOrigin);\n\n\tvar angle = PointADOF.getRelativeAngle(transform, targetPosWorld,\n\t\tinternalOrigin, angleForward, anglePlaneNormal, pointReport);\n\n\tif(angle != null){\n\t\tvar displacement;\n\t\tif(angle >= Math.PI/2){\n\t\t\t//slog(channel, \"Cannot compute exact plane intersect, ray will not intersect plane\");\n\t\t\tdisplacement = Number.POSITIVE_INFINITY;\n\t\t}else if(angle <= -Math.PI/2){\n\t\t\t//slog(channel, \"Cannot compute exact plane intersect, ray will not intersect plane\");\n\t\t\tdisplacement =  Number.NEGATIVE_INFINITY;\n\t\t}else{\n\t\t\tdisplacement = Math.tan(angle) * internalDistanceToCenter;\n\t\t}\n\n\t\tif(visHelper !== null && visHelper.shouldDraw(this)){\n\n\t\t\tvar localTarget = transform.worldToLocal(new THREE.Vector3().copy(targetPosWorld));\n\n\t\t\tvisHelper.drawLineLocal(this, \"PlaneIntersectFromRear:InternalToTarget\", transform, internalOrigin, localTarget, new THREE.Color(1, 1, 0));\n\t\t}\n\n\t\treturn displacement;\n\n\t}else{\n\t\tslog(channel, \"Plane intersect error, could not get angle\");\n\t\treturn null;\n\t}\n};\n\n\n/**\n *\n * @param {RotationControl} rotationControl\n * @param {THREE.Object3D} transform\n * @param {THREE.Vector3} forward\n * @param {THREE.Vector3} targetPosWorld\n * @param {PointReport} [pointReport] - inplace arg to return metadata about computation\n * @return {number} closest dof value or null if cannot be computed (singularity)\n */\nPointADOF.pointDOF = function(rotationControl, transform, forward, targetPosWorld, pointReport){\n\tvar localTarget = transform.worldToLocal(new THREE.Vector3().copy(targetPosWorld));\n\tvar localRotation = new THREE.Quaternion().copy(transform.quaternion);\n\n\t//take current rotation out of localTarget\n\tlocalTarget.applyQuaternion(localRotation);\n\n\t//rotate axis by initial so we have local-space axis\n\tvar initialRotation = rotationControl.getInitialRotation(new THREE.Quaternion());\n\tvar axis = rotationControl.getRotationalAxis(new THREE.Vector3());\n\taxis.applyQuaternion(initialRotation);\n\n\t//rotate forward so angles will reflect difference between \"forward after initial-rot\" and target\n\tvar forwardRotated = new THREE.Vector3().copy(forward).applyQuaternion(initialRotation);\n\n\tif(pointReport){\n\t\tpointReport._angleToAxis = minAngleToLine(localTarget.angleTo(axis));\n\t\tpointReport._distanceToTarget = localTarget.length();\n\t}\n\n\t//remove non-axial components of directions\n\tvar forwardProjected = new THREE.Vector3().copy(forwardRotated).projectOnPlane(axis);\n\tvar localProjected = new THREE.Vector3().copy(localTarget).projectOnPlane(axis);\n\n\t//check for degenerate cases\n\tif(forwardProjected.lengthSq() < epsilonSquared || localProjected.lengthSq() < epsilonSquared){\n\t\tslog(channel, \"Error pointing DOF, Forward length:\"+forwardProjected.length()+\" local length:\"+localProjected.length());\n\t\treturn null;\n\t}\n\n\tforwardProjected.normalize();\n\tlocalProjected.normalize();\n\n\t//find out how much rotation this quaternion represents around our given axis\n\tvar rotationNeededQuaternion = new THREE.Quaternion().setFromUnitVectors(forwardProjected, localProjected);\n\tvar axisAngleV4 = new THREE.Vector4().setAxisAngleFromQuaternion(rotationNeededQuaternion);\n\tvar dofValue = correctAngleSign(axisAngleV4, axis);\n\n\tif(visHelper !== null && visHelper.shouldDraw(this)){\n\n\t\tvisHelper.drawRayLocal(this, \"PointAt:CurForwardDir\", transform, null, forward, new THREE.Color(1, 0, 0));\n\n\t\tvar axisRaw = rotationControl.getRotationalAxis(new THREE.Vector3());\n\t\t//ok to draw axis using current transform internal rotation since it is initial + axis-angle, and axis-angle portion won't affect axis\n\t\tvisHelper.drawRayLocal(this, \"PointAt:AxisOfRotation\", transform, null, axisRaw, new THREE.Color(1, 1, 0));\n\t\tvisHelper.drawPlaneLocal(this, \"PointAt:PlaneOfRotation\", transform, null, axisRaw, new THREE.Color(1, 0, 1));\n\n\t\tvar forwardInitial = new THREE.Vector3().copy(forward);\n\t\tforwardInitial.applyQuaternion(initialRotation);\n\t\tforwardInitial.applyQuaternion(new THREE.Quaternion().copy(localRotation).inverse()); //undo the current frame influence when going local to world\n\t\tvisHelper.drawRayLocal(this, \"PointAt:InitForwardDir\", transform, null, forwardInitial, new THREE.Color(0, 1, 1));\n\n\t\tvar dofValueRotation = new THREE.Quaternion().setFromAxisAngle(axis, dofValue);\n\t\tvar dofDir = new THREE.Vector3().copy(forwardRotated).applyQuaternion(dofValueRotation);\n\t\tdofDir.applyQuaternion(new THREE.Quaternion().copy(localRotation).inverse()); //undo the current frame influence when going local to world\n\t\tvisHelper.drawRayLocal(this, \"PointAt:FlatTargetVec\", transform, null, dofDir, new THREE.Color(0,1,1));\n\t}\n\n\treturn dofValue;\n};\n\n\n\n/**\n *\n * @param {RotationControl} rotationControl\n * @param {THREE.Object3D} transform\n * @param {THREE.Vector3} planeNormal - would be plane normal if angleAbovePlaneForIntersection == 0, otherwise axis of cone\n * @param {number} distanceAlongDOFAxisToPlane - cone/plane is mounted this far along dof axis\n * @param {THREE.Vector3} targetPosWorld\n * @param {number} angleAbovePlaneForIntersection - angle of cone; 0 means a flat plane, positive values \"raise\" plane where up is the axis of control.\n * @param {boolean} approximateVerticalToLinear - if true, instead of \"true\" angle, imagine that linear axis rotation created linear vertical angle change\n * @param {PointReport} [pointReport] - inplace arg to return metadata about computation\n * @return {number[]} 1 or 2 points that cause cone to touch target or come as close as possible\n */\nPointADOF.pointDOFToIntersectConeWithPoint = function(rotationControl, transform, planeNormal,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdistanceAlongDOFAxisToPlane, targetPosWorld,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tangleAbovePlaneForIntersection, approximateVerticalToLinear,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpointReport){\n\tvar localTarget = transform.worldToLocal(new THREE.Vector3().copy(targetPosWorld));\n\tvar localRotation = new THREE.Quaternion().copy(transform.quaternion);\n\n\t//take current rotation out of localTarget\n\tlocalTarget.applyQuaternion(localRotation);\n\n\t//rotate axis by initial so it's in true local space\n\tvar initialRotation = rotationControl.getInitialRotation(new THREE.Quaternion());\n\tvar axis = rotationControl.getRotationalAxis(new THREE.Vector3());\n\tvar rotatedAxis = new THREE.Vector3().copy(axis).applyQuaternion(initialRotation);\n\n\tif(planeNormal.angleTo(axis) > Math.PI/2.0){\n\t\t//same plane, but makes trig assumptions simpler\n\t\tplaneNormal = new THREE.Vector3().copy(planeNormal).multiplyScalar(-1);\n\t}\n\n\t//move localTarget to account for distanceAlongDOFAxisToPlane\n\tif(distanceAlongDOFAxisToPlane !== 0){\n\t\tvar transVec = new THREE.Vector3().copy(rotatedAxis);\n\t\ttransVec.multiplyScalar(distanceAlongDOFAxisToPlane/transVec.length());\n\t\tlocalTarget.sub(transVec);\n\t}\n\n\t//move localTarget to account for cone angle above plane\n\tif(angleAbovePlaneForIntersection !== 0){\n\t\tvar bendForPlaneModAxis = new THREE.Vector3().crossVectors(rotatedAxis, localTarget).normalize();\n\t\t//applyAxisAngle REQUIRES normalize angle!!\n\t\tlocalTarget.applyAxisAngle(bendForPlaneModAxis, angleAbovePlaneForIntersection);\n\t}\n\n\tif(visHelper !== null && visHelper.shouldDraw(this)){\n\t\t//these will draw on \"current\" rotation of transform, before\n\t\tvar normalStart = new THREE.Vector3().copy(axis).setLength(distanceAlongDOFAxisToPlane);\n\n\t\tvisHelper.drawRayLocal(this, \"Plane:Normal\", transform, normalStart, planeNormal, new THREE.Color(1, 1, 1));\n\n\t\tvar planeStart = new THREE.Vector3().copy(axis).setLength(distanceAlongDOFAxisToPlane);\n\n\t\tvisHelper.drawConeLocal(this, \"Plane:Surface\", transform, planeStart, planeNormal, angleAbovePlaneForIntersection, new THREE.Color(1, 0, 1));\n\t}\n\n\t//we want the normal after the initial rot, ready to be rotated around axis\n\tvar normalPostInitialRot = new THREE.Vector3().copy(planeNormal).applyQuaternion(initialRotation);\n\n\t//angle between axis and normal, after initial rotation on both\n\tvar axisToNormalAngle = rotatedAxis.angleTo(normalPostInitialRot);\n\n\tif(axisToNormalAngle < epsilon){\n\t\t//planeNormal has already been replaced with opposite vector to be close to axis if necessary (above)\n\t\t//thus, angle should be between 0 and PI/2, don't need to also check against angles near PI for degeneracy\n\t\tslog(channel, \"Error, plane normal (\"+planeNormal.x+\", \"+planeNormal.y+\", \"+planeNormal.z+\") too close to axis (\"+axis.x+\", \"+axis.y+\", \"+axis.z+\")\");\n\t\treturn null;\n\t}\n\n\t//what the normal would be, if the plane did intersect the target, projected onto the plane defined by axis and localTarget\n\tvar normalAngleProjected = Math.PI/2.0 - rotatedAxis.angleTo(localTarget);\n\n\t//the top side of a triangle on above plane defined by axis (length 1) and a hypotenuse starting at axis origin and with angle normalAngleProjected\n\tvar dTopProjected = Math.tan(normalAngleProjected);\n\n\t//same style triangle, but with angle for actual normal\n\tvar dTopNormal = Math.tan(axisToNormalAngle);\n\n\t//how far we need to rotate the normal from it's start so its projection would line up with normalAngleProjected(in the \"back\", behind the axis, looking at the plane above)\n\tvar rBackPosToProjected = null;\n\tif(approximateVerticalToLinear){\n\t\trBackPosToProjected = (Math.PI/2.0)*(Math.max(-1, Math.min(1, dTopProjected / dTopNormal)));\n\t}else{\n\t\trBackPosToProjected = Math.asin(Math.max(-1, Math.min(1, dTopProjected / dTopNormal)));\n\t}\n\n\tif(pointReport){\n\t\tpointReport._angleToAxis = minAngleToLine(localTarget.angleTo(rotatedAxis));\n\t\tpointReport._distanceToTarget = localTarget.length();\n\t}\n\n\n\tif(minAngleToLine(localTarget.angleTo(rotatedAxis)) < epsilon){\n\t\tslog(channel, \"Error, Lookat Target local:(\"+localTarget.x+\", \"+localTarget.y+\", \"+localTarget.z+\"), world:(\"+targetPosWorld.x+\", \"+targetPosWorld.y+\", \"+targetPosWorld.z+\") too close to rotated axis (\"+rotatedAxis.x+\", \"+rotatedAxis.y+\", \"+rotatedAxis.z+\")\");\n\t\treturn null;\n\t}\n\n\t//now we need to know how far we need to rotate actual normal vector to reach \"back\" position\n\tvar backVec = new THREE.Vector3().crossVectors(rotatedAxis, localTarget).normalize();\n\n\n\tvar flatNormal = new THREE.Vector3().copy(normalPostInitialRot).projectOnPlane(rotatedAxis).normalize();\n\n\tvar normToBack = new THREE.Quaternion().setFromUnitVectors(flatNormal, backVec);\n\tvar normToBackAxisAngleV4 = new THREE.Vector4().setAxisAngleFromQuaternion(normToBack);\n\tvar rNormalToBackPos = correctAngleSign(normToBackAxisAngleV4, rotatedAxis);\n\n\tvar otherRBackPosToProjected = -(rBackPosToProjected - (-Math.PI/2.0)) + -Math.PI/2.0;\n\n\tvar total1 = rNormalToBackPos + rBackPosToProjected;\n\tvar total2 = rNormalToBackPos + otherRBackPosToProjected;\n\n\t//return [replaceWithInLimitEquivalentIfPossible(total1, rotationControl.getMin(), rotationControl.getMax()),\n\t//\treplaceWithInLimitEquivalentIfPossible(total2, rotationControl.getMin(), rotationControl.getMax())];\n\treturn [total1, total2];\n\n};\n\nmodule.exports = PointADOF;\n\n\n"],"sourceRoot":"/source/"}