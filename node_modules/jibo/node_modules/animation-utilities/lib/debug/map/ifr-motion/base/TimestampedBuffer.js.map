{"version":3,"sources":["ifr-motion/base/TimestampedBuffer.js"],"names":[],"mappings":"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","file":"ifr-motion/base/TimestampedBuffer.js","sourcesContent":["/**\n * @author mattb\n * Copyright 2015 IF Robots LLC\n */\n\n\n\"use strict\";\n\n/**\n * @constructor\n */\nvar TimestampedBuffer = function()\n{\n\t/** @type {Array.<number>} */\n\tthis.timestampList = [];\n\t/** @type {Array.<*>} */\n\tthis.dataList = [];\n\n\t/** @type {number} */\n\tthis._lastReturnedLeftIndex = 0;\n};\n\nTimestampedBuffer.prototype.clone = function(){\n\tvar newBuffer = new TimestampedBuffer();\n\t//ok to shallow copy arrays since contents are numbers (immutable)\n\tnewBuffer.timestampList = this.timestampList.slice(0);\n\tnewBuffer.dataList = this.dataList.slice(0);\n\tnewBuffer._lastReturnedLeftIndex = this._lastReturnedLeftIndex;\n\treturn newBuffer;\n};\n\n/**\n * @return {number}\n */\nTimestampedBuffer.prototype.size = function()\n{\n\treturn this.timestampList.length;\n};\n\n/**\n * @return {number}\n */\nTimestampedBuffer.prototype.getStartTime = function()\n{\n\treturn this.timestampList[0];\n};\n\n/**\n * @return {number}\n */\nTimestampedBuffer.prototype.getEndTime = function()\n{\n\treturn this.timestampList[this.timestampList.length-1];\n};\n\n/**\n * Append a sample to the buffer. This method assumes that the new sample is after (in time)\n * all samples already added; only use it when adding data in time-order.\n *\n * @param {number} timestamp\n * @param {*} data\n */\nTimestampedBuffer.prototype.append = function(timestamp, data)\n{\n\tif (this.size() > 0)\n\t{\n\t\tif (timestamp < this.getEndTime())\n\t\t{\n\t\t\tthrow new Error(\"new timestamp \"+timestamp+\" is out of sequence with previous timestamp \"+this.getEndTime());\n\t\t}\n\t}\n\n\tthis.timestampList.push(timestamp);\n\tthis.dataList.push(data);\n};\n\n/**\n * @param {number} index\n * @return {number} timestamp at the specified index\n */\nTimestampedBuffer.prototype.getTimestamp = function(index)\n{\n\treturn this.timestampList[index];\n};\n\n/**\n * @param {number} index\n * @return {*} data sample at the specified index\n */\nTimestampedBuffer.prototype.getData = function(index)\n{\n\treturn this.dataList[index];\n};\n\n/**\n * @param {number} index\n * @return {*} data sample that was removed\n */\nTimestampedBuffer.prototype.remove = function(index)\n{\n\tthis.timestampList.splice(index, 1);\n\treturn this.dataList.splice(index, 1)[0];\n};\n\n/**\n * @param {number} time\n * @return {*} data\n */\nTimestampedBuffer.prototype.getDataForTime = function(time)\n{\n\tvar index = this.getLeftIndexForTime(time);\n\tif (index > -1)\n\t{\n\t\treturn this.dataList[index];\n\t}\n\telse\n\t{\n\t\treturn null;\n\t}\n};\n\n/**\n * Get all data for the provided time range.\n * @param {number} startTime start time of the range\n * @param {boolean} inclusiveStart true if data exactly at start time should be included\n * @param {number} endTime end time of the range\n * @param {boolean} inclusiveEnd true if data exactly at end time should be included\n * @return {Array} the data for the time range, in order, or null if no data in range\n */\nTimestampedBuffer.prototype.getDataForRange = function(startTime, inclusiveStart, endTime, inclusiveEnd)\n{\n\tvar rangedData = null;\n\tvar startIndex = this.getLeftIndexForTime(startTime);\n\tvar endIndex = this.getLeftIndexForTime(endTime)+1;\n\n\tfor (var i=startIndex; i<=endIndex; i++)\n\t{\n\t\tif (i >= 0 && i < this.size()) // exclude indices indicating out of range values\n\t\t{\n\t\t\tvar ts = this.getTimestamp(i);\n\t\t\tvar startOK = ts > startTime || (ts === startTime && inclusiveStart);\n\t\t\tvar endOK = ts < endTime || (ts === endTime && inclusiveEnd);\n\t\t\tif (startOK && endOK)\n\t\t\t{\n\t\t\t\tif (rangedData === null)\n\t\t\t\t{\n\t\t\t\t\trangedData = [];\n\t\t\t\t}\n\t\t\t\trangedData.push(this.getData(i));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rangedData;\n};\n\n/**\n * Insert unordered data.  If data already exists at the exact specified timestamp, it will be replaced with this data.\n * Otherwise, this data will be added in the correct place, associated with the specified timestamp.\n * @param timestamp time stamp to add or alter\n * @param data data to set\n */\nTimestampedBuffer.prototype.insert = function(timestamp, data)\n{\n\tvar leftIndex = this.getLeftIndexForTime(timestamp);\n\tif (leftIndex >= 0 && this.timestampList[leftIndex] === timestamp)\n\t{\n\t\tthis.dataList[leftIndex] = data;\n\t}\n\telse\n\t{\n\t\tvar insertAt = leftIndex+1;\n\t\tthis.timestampList.splice(insertAt, 0, timestamp);\n\t\tthis.dataList.splice(insertAt, 0, data);\n\t}\n};\n\n/**\n * find index of timestamp s.t. stamps[index] <= time && stamps[index+1] > time\n * OR -1 if buffer is empty or time < startTime\n * OR last index if time >= endTime\n *\n * @param time time to search for\n * @return {number} index\n */\nTimestampedBuffer.prototype.getLeftIndexForTime = function(time)\n{\n\tif (this.size() === 0 || time < this.getStartTime())\n\t{\n\t\treturn -1;\n\t}\n\tif (time >= this.getEndTime())\n\t{\n\t\treturn this.size()-1;\n\t}\n\n\t// check the last returned left index\n\tif (this._lastReturnedLeftIndex < this.size()-1 &&\n\t\tthis.timestampList[this._lastReturnedLeftIndex] <= time &&\n\t\tthis.timestampList[this._lastReturnedLeftIndex+1] > time)\n\t{\n\t\treturn this._lastReturnedLeftIndex;\n\t}\n\n\t// then, check the next one\n\tthis._lastReturnedLeftIndex++;\n\tif (this._lastReturnedLeftIndex < this.size()-1 &&\n\t\tthis.timestampList[this._lastReturnedLeftIndex] <= time &&\n\t\tthis.timestampList[this._lastReturnedLeftIndex+1] > time)\n\t{\n\t\treturn this._lastReturnedLeftIndex;\n\t}\n\n\t// no match yet, so find via binary search\n\tvar leftIndex = 0;\n\tvar rightIndex = this.size()-1;\n\tvar middleIndex;\n\twhile (rightIndex !== leftIndex+1)\n\t{\n\t\tmiddleIndex = Math.floor((leftIndex + rightIndex) / 2);\n\t\tif (this.timestampList[middleIndex] <= time)\n\t\t{\n\t\t\tleftIndex = middleIndex;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trightIndex = middleIndex;\n\t\t}\n\t}\n\n\tthis._lastReturnedLeftIndex = leftIndex;\n\treturn leftIndex;\n};\n\nmodule.exports = TimestampedBuffer;\n"],"sourceRoot":"/source/"}