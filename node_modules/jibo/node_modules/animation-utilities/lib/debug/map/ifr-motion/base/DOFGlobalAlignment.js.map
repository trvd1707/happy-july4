{"version":3,"sources":["ifr-motion/base/DOFGlobalAlignment.js"],"names":[],"mappings":"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","file":"ifr-motion/base/DOFGlobalAlignment.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar CyclicDOFTargetSelector = require(\"./CyclicDOFTargetSelector\");\n\n/**\n * Collection of tools to help alignment of DOFs accounting\n * for their global-space (world space) positions.\n *\n * @param {KinematicGroup} kinematicGroup\n * @param {Object.<string,CyclicDOFTargetSelector>} [customGlobalSelectors]\n * @constructor\n */\nvar DOFGlobalAlignment = function(kinematicGroup, customGlobalSelectors){\n\tvar i;\n\n\t/** @type {Object.<string,CyclicDOFTargetSelector>} */\n\tvar globalTargetSelectors = {};\n\tvar localTargetSelectors = {};\n\tvar dofNames = kinematicGroup.getDOFNames();\n\n\n\t//////////init ancestor sort ordering/////////////\n\t/** @type {Object.<string,number>} */\n\tvar dofDepth = {};\n\tvar dofDepthComparator = function(dofName1, dofName2){\n\t\tvar d1 = dofDepth[dofName1];\n\t\tvar d2 = dofDepth[dofName2];\n\t\tif(d1 != null && d2 != null){ //null or undefined (eqnull)\n\t\t\treturn d1 - d2;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t};\n\n\tfor(i = 0; i < dofNames.length; i++){\n\t\tvar depth = 0;\n\t\tvar control = kinematicGroup.getModelControlGroup().getControlForDOF(dofNames[i]);\n\t\tif(control != null){ //null of undefined (eqnull)\n\t\t\tif(control.getControlType() === \"ROTATION\" || control.getControlType() === \"TRANSLATION\"){\n\t\t\t\tvar transformName = control.getTransformName();\n\t\t\t\tvar transform = kinematicGroup.getTransform(transformName);\n\t\t\t\tif(transform != null){ //null or undefined (eqnull)\n\t\t\t\t\twhile(transform.parent != null){ //null or undefined (eqnull)\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\ttransform = transform.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdofDepth[dofNames[i]] = depth;\n\t}\n\t///////////////////////////////////////////////////\n\n\n\n\t///////////init target selectors///////////////\n\tfor(i = 0; i < dofNames.length; i++){\n\t\tvar dofName = dofNames[i];\n\t\tif(kinematicGroup.getModelControlGroup().getDOFInfo(dofName).isCyclic()){\n\t\t\tif(customGlobalSelectors && customGlobalSelectors.hasOwnProperty(dofName)){\n\t\t\t\tglobalTargetSelectors[dofName] = customGlobalSelectors[dofName];\n\t\t\t}else{\n\t\t\t\tglobalTargetSelectors[dofName] = new CyclicDOFTargetSelector(dofName);\n\t\t\t}\n\t\t\tlocalTargetSelectors[dofName] = new CyclicDOFTargetSelector(dofName);\n\t\t}\n\t}\n\t///////////////////////////////////////////////\n\n\t/**\n\t * Sort the provided list of dof names inplace by the order of the hierarchical location of\n\t * their corresponding transforms, from root to leaves.  Each node will precede\n\t * its children, and order amongst same-level nodes is arbitrary.  DOFs with no corresponding\n\t * transforms will be at the beginning of the list in an arbitrary order.\n\t *\n\t * @param {string[]} dofNames - inplace list of dofnames to be sorted\n\t * @return {string[]} the inplace dofNames list is sorted (modified) and also returned for convenience\n\t */\n\tthis.sortDOFsByDepth = function(dofNames){\n\t\treturn dofNames.sort(dofDepthComparator);\n\t};\n\n\t/**\n\t * Get the target selector for this DOF.  May be the default CyclicDOFTargetSelector,\n\t * or a custom implementation for this joint that takes into account parent motion\n\t * to find a better preferred direction.\n\t *\n\t * @param {string} dofName\n\t * @returns {CyclicDOFTargetSelector}\n\t */\n\tthis.getGlobalTargetSelector = function(dofName){\n\t\treturn globalTargetSelectors[dofName];\n\t};\n\n\t/**\n\t * Get the target selector for this DOF.\n\t *\n\t * @param {string} dofName\n\t * @returns {CyclicDOFTargetSelector}\n\t */\n\tthis.getLocalTargetSelector = function(dofName){\n\t\treturn localTargetSelectors[dofName];\n\t};\n\n\t/**\n\t * Modifies toPose inplace to represent an equivalent orientation for each dof, but with the values\n\t * potentially modified to cyclically equivalent values to represent less global motion between\n\t * fromPose and toPose.\n\t *\n\t * @param {Pose} fromPose - starting position\n\t * @param {Pose} toPose - target position, will be modified to have the same orientation but less rotation\n\t * @param {string[]} [onDOFs] - computed for these dofs.  dofs from fomPose used if null or undefined\n\t */\n\tthis.refineToGloballyClosestTargetPose = function(fromPose, toPose, onDOFs){\n\t\tif(onDOFs == null){ //null or undefined (eqnull)\n\t\t\tonDOFs = fromPose.getDOFNames();\n\t\t}\n\n\t\tvar sortedOnDOFs = this.sortDOFsByDepth(onDOFs.slice(0));\n\n\t\tfor (var di = 0; di < sortedOnDOFs.length; di++) {\n\t\t\tvar targetSelector = this.getGlobalTargetSelector(sortedOnDOFs[di]);\n\t\t\tif(targetSelector) {\n\t\t\t\tvar t = targetSelector.closestEquivalentRotation(fromPose, toPose);\n\t\t\t\ttoPose.set(sortedOnDOFs[di], t, 0); //update pose for children computation\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Modifies toPose inplace to represent an equivalent orientation for each dof, with the values\n\t * computed to have each DOF have the least local motion to get to target.\n\t *\n\t * @param {Pose} fromPose - starting position\n\t * @param {Pose} toPose - target position, will be modified to have the same orientation but less rotation\n\t * @param {string[]} [onDOFs] - computed for these dofs.  dofs from fomPose used if null or undefined\n\t */\n\tthis.refineToLocallyClosestTargetPose = function(fromPose, toPose, onDOFs){\n\t\tif(onDOFs == null){ //null or undefined (eqnull)\n\t\t\tonDOFs = fromPose.getDOFNames();\n\t\t}\n\n\t\t//don't need to sort for local computations\n\n\t\tfor (var di = 0; di < onDOFs.length; di++) {\n\t\t\tvar targetSelector = this.getLocalTargetSelector(onDOFs[di]);\n\t\t\tif(targetSelector) {\n\t\t\t\tvar t = targetSelector.closestEquivalentRotation(fromPose, toPose);\n\t\t\t\ttoPose.set(onDOFs[di], t, 0); //save result in inplace output\n\t\t\t}\n\t\t}\n\n\t};\n\n\n};\n\n\n\nmodule.exports = DOFGlobalAlignment;"],"sourceRoot":"/source/"}