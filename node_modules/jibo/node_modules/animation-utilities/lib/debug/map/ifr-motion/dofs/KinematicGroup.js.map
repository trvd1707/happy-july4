{"version":3,"sources":["ifr-motion/dofs/KinematicGroup.js"],"names":[],"mappings":"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","file":"ifr-motion/dofs/KinematicGroup.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\n/**\n *\n * @param {ModelControlGroup} modelControlGroup\n * @param {THREE.Object3D} hierarchyRoot\n * @constructor\n */\nvar KinematicGroup = function(modelControlGroup, hierarchyRoot){\n\tthis._modelControlGroup = modelControlGroup;\n\tthis._hierarchyRoot = hierarchyRoot;\n\n\t/** @type {Object<string, THREE.Object3D>} */\n\tthis._modelMap = null;\n};\n\n/**\n * Copy tree, but only nodes in map.  Assumes that \"node\" is in map\n *\n * @param node\n * @param {Object.<string,boolean>} includeNamesMap - map of boolean values, true to include.  assumed to be continuous and touch root.\n */\nvar copyTree = function(node, includeNamesMap){\n\tvar n = node.clone(undefined, false);\n\tfor(var i = 0; i < node.children.length; i++){\n\t\tvar c = node.children[i];\n\t\tif(c.name != null && includeNamesMap[c.name]){\n\t\t\tn.add(copyTree(c, includeNamesMap));\n\t\t}\n\t}\n\treturn n;\n};\n\n\nvar printTree = function(node, tabs){\n\tif(tabs==null){\n\t\ttabs = \"\";\n\t}\n\tconsole.log(tabs+node.name);\n\tfor(var i = 0; i < node.children.length; i++){\n\t\tprintTree(node.children[i], tabs+\"\\t\");\n\t}\n};\n\n/**\n * Get a copy of this KinematicGroup, including a copy of the transform hierarchy and a copy of the ModelControls,\n * bound to the new hierarchy.  If requiredTransforms is present, the copy will include a sub-tree of the original\n * hierarchy, with only transforms required to connect the required transforms to the root.  Only ModelControls\n * associated with those branches will be included.\n *\n * If kinematicOnly is true, the copy will only include controls that are associated with the motion of transforms,\n * not any render-only controls (e.g, texture, color, etc.).\n *\n * @param {string[]} [requiredTransforms] - if present, only include chains connecting root to required transforms\n * @param {boolean} [kinematicOnly=true] - if true, only include ModelControls that represent kinematic motions\n * @returns {KinematicGroup}\n */\nKinematicGroup.prototype.getCopy = function(requiredTransforms, kinematicOnly){ // eslint-disable-line no-unused-vars\n\t//TODO: support requiredTransforms and kinematicOnly\n\t//TODO: get meshes out of here!\n\n\tvar copiedHierarchy;\n\n\tif(requiredTransforms!=null && this._hierarchyRoot!=null){\n\t\tvar toInclude = {};\n\t\tvar modelMap = this.getModelMap();\n\t\tfor(var i = 0; i < requiredTransforms.length; i++){\n\t\t\tvar t = modelMap[requiredTransforms[i]];\n\t\t\twhile(t!=null){\n\t\t\t\tif(!toInclude.hasOwnProperty(t.name)) {\n\t\t\t\t\ttoInclude[t.name] = true;\n\t\t\t\t\tt = t.parent;\n\t\t\t\t}else{\n\t\t\t\t\tt = null; //met up with already traversed root\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(toInclude[this._hierarchyRoot.name]) {\n\t\t\tcopiedHierarchy = copyTree(this._hierarchyRoot, toInclude);\n\t\t}else{\n\t\t\tconsole.log(\"Warning, none of required dofs (\"+(requiredTransforms==null?\"null\":requiredTransforms.toString())+\")present in hierarchy!\");\n\t\t\tcopiedHierarchy = null;\n\t\t}\n\t}else {\n\t\tcopiedHierarchy = this._hierarchyRoot ? this._hierarchyRoot.clone() : null;\n\t}\n\tvar copiedGroup = this._modelControlGroup?this._modelControlGroup.getCopy():null;\n\tcopiedGroup.attachToModelAndPrune(copiedHierarchy);\n\t//if(requiredTransforms!=null) {\n\t//\tconsole.log(\"MADE TREE! for trans \" + requiredTransforms.toString());\n\t//\tprintTree(copiedHierarchy);\n\t//}\n\treturn new KinematicGroup(copiedGroup, copiedHierarchy);\n};\n\n/**\n *\n * @param {Pose} inplacePose\n * @return {Pose}\n */\nKinematicGroup.prototype.getPose = function(inplacePose){ // eslint-disable-line no-unused-vars\n\n};\n\n/**\n *\n * @param {Pose} pose\n */\nKinematicGroup.prototype.setFromPose = function(pose){\n\tthis._modelControlGroup.updateFromPose(pose);\n};\n\n/**\n * @return {string[]}\n */\nKinematicGroup.prototype.getDOFNames = function(){\n\treturn this._modelControlGroup.getDOFNames();\n};\n\n/**\n * @return {ModelControlGroup}\n */\nKinematicGroup.prototype.getModelControlGroup = function(){\n\treturn this._modelControlGroup;\n};\n\n/**\n * @return {THREE.Object3D}\n */\nKinematicGroup.prototype.getRoot = function(){\n\treturn this._hierarchyRoot;\n};\n\n/**\n * @param {THREE.Vector3} hierarchyRoot\n * @returns {Object.<string, THREE.Object3D>}\n */\nKinematicGroup.generateTransformMap = function(hierarchyRoot){\n\t/** @type {Object.<string, THREE.Object3D>} */\n\tvar modelMap = {};\n\n\t// flatten model tree\n\t/** @type {Array.<THREE.Object3D>} */\n\tvar nodesToVisit = [hierarchyRoot];\n\twhile (nodesToVisit.length > 0){\n\t\tvar node = nodesToVisit.shift();\n\t\tif (node.name){\n\t\t\tmodelMap[node.name] = node;\n\t\t}\n\t\tif (node.children) {\n\t\t\tfor (var c=0; c<node.children.length; c++){\n\t\t\t\tnodesToVisit.push(node.children[c]);\n\t\t\t}\n\t\t}\n\t}\n\treturn modelMap;\n};\n\n/**\n * @return {Object<string, THREE.Object3D>}\n */\nKinematicGroup.prototype.getModelMap = function(){\n\tif(!this._modelMap){\n\t\tthis._modelMap = KinematicGroup.generateTransformMap(this._hierarchyRoot);\n\t}\n\treturn this._modelMap;\n};\n\n/**\n * @param {string} transformName\n * @return {THREE.Object3D}\n */\nKinematicGroup.prototype.getTransform = function(transformName){\n\tif(!this._modelMap){\n\t\tthis._modelMap = KinematicGroup.generateTransformMap(this._hierarchyRoot);\n\t}\n\treturn this._modelMap[transformName];\n};\n\n\nmodule.exports = KinematicGroup;"],"sourceRoot":"/source/"}