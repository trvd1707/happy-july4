{"version":3,"sources":["ifr-motion/lookat/MotionLookat.js"],"names":[],"mappings":"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","file":"ifr-motion/lookat/MotionLookat.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar Pose = require(\"../base/Pose\");\n\n/**\n *\n * @param {LookatMotionNode[]} lookatNodes - assumed to be in order root to leaf\n * @param {KinematicGroup} kinematicGroupPrototype\n * @constructor\n */\nvar MotionLookat = function(lookatNodes, kinematicGroupPrototype){\n\tvar allRequiredDOFs = [];\n\tvar i,j;\n\n\t/** @type {LookatMotionNode[]} */\n\tthis._lookatNodes = lookatNodes;\n\tfor(i = 0; i < this._lookatNodes.length; i++){\n\t\tvar localGroup = kinematicGroupPrototype.getCopy(kinematicGroupPrototype.getModelControlGroup().getRequiredTransformNamesForDOFs(this._lookatNodes[i].getDOFs()), true);\n\t\tthis._lookatNodes[i].connectToGroup(localGroup);\n\n\t\t//local group will include all required ancestor dofs\n\t\tvar dofsForThisLook = localGroup.getDOFNames();\n\t\tfor(j = 0; j < dofsForThisLook.length; j++){\n\t\t\tif(allRequiredDOFs.indexOf(dofsForThisLook[j]) < 0){\n\t\t\t\tallRequiredDOFs.push(dofsForThisLook[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Pose} */\n\tthis._internalPose = new Pose(\"LookPose\", allRequiredDOFs);\n\n\t/** @type {Object.<string,LookatMotionNode>} */\n\tthis._dofToLookatNodeMap = {};\n\t/** @type {Object.<string,string[]>} */\n\tthis._lookatNodeToDOFsMap = {};\n\tfor(i = 0; i < this._lookatNodes.length; i++){\n\t\tvar lookatNode = this._lookatNodes[i];\n\t\tvar lookatNodeDOFs = this._lookatNodes[i].getDOFs();\n\t\tif(this._lookatNodeToDOFsMap.hasOwnProperty(lookatNode.getName())){\n\t\t\tthrow new Error(\"Error, multiple lookat nodes named \"+lookatNode.getName());\n\t\t}\n\t\tthis._lookatNodeToDOFsMap[lookatNode.getName()] = lookatNodeDOFs;\n\t\tfor(j = 0; j < lookatNodeDOFs.length; j++){\n\t\t\tvar dofName = lookatNodeDOFs[j];\n\t\t\tif(this._dofToLookatNodeMap.hasOwnProperty(dofName)){\n\t\t\t\tthrow new Error(\"Error, multiple lookat nodes use DOF \"+dofName+\": \"+this._dofToLookatNodeMap[dofName].getName()+\" and \"+lookatNode.getName());\n\t\t\t}\n\t\t\tthis._dofToLookatNodeMap[dofName] = lookatNode;\n\t\t}\n\t}\n};\n\n/**\n * Updates state to time, tracking target.\n *\n * @param {Pose} poseCurrentPose - should contain at least nodes of relevance to the computation, e.g. ancestor nodes (and lookat node, if we are initializing after reset)\n * @param {Pose} poseInplaceOut - output values will be stored here (output values set to \"poseCurrentPose\" for unused dofs)\n * @param {THREE.Vector3} target - target in world space\n * @param {Time} time - time to generate pose for\n */\nMotionLookat.prototype.generatePose = function(poseCurrentPose, poseInplaceOut, target, time){\n\tif(poseCurrentPose!==poseInplaceOut) {\n\t\tposeInplaceOut.setPose(poseCurrentPose);\n\t}\n\n\t//use _internalPose instead of poseInplaceOutput in case it doesn't have required \"state\" dofs\n\tthis._internalPose.setPose(poseCurrentPose);\n\n\tfor(var i = 0; i < this._lookatNodes.length; i++){\n\t\tthis._lookatNodes[i].update(this._internalPose, this._internalPose, target, time);\n\t}\n\tposeInplaceOut.setPose(this._internalPose);\n};\n\n\n/**\n * Updates state to time, tracking target.  Only updates the lookat node related to the dof provided.\n * For lookat nodes that control multiple dofs, we rely on the the underlying LookatMotionNodes\n * to cache results and return the same computation again for 2 calls at the same \"time\".  poseInplaceOut\n * will have results of all dofs for that multi-dof node when any of it's nodes are specified (unless\n * the Pose does not contain those dofs)\n *\n * Caller must take care to update dofs in order (base to leaf), and to not skip dofs that\n * will later be used again before the next reset, as their state tracking will become out\n * of sync.  They must also take care to update all DOFs in use before calling status calls\n * like getDistanceRemaining().\n *\n * @param {Pose} poseCurrentPose - should contain at least nodes of relevance to the computation, e.g. ancestor nodes (and lookat node, if we are initializing after reset)\n * @param {Pose} poseInplaceOut - output values will be stored here (output values set to \"poseCurrentPose\" for unused dofs)\n * @param {THREE.Vector3} target - target in world space\n * @param {Time} time - time to generate pose for\n * @param {string} dofName - only generate state for this dof (if we have no node for this dof, poseInplaceOut will just be poseCurrentPose)\n */\nMotionLookat.prototype.generatePoseIncremental = function(poseCurrentPose, poseInplaceOut, target, time, dofName){\n\tif(poseCurrentPose!==poseInplaceOut) {\n\t\tposeInplaceOut.setPose(poseCurrentPose);\n\t}\n\n\tif(this._dofToLookatNodeMap.hasOwnProperty(dofName)){\n\t\tvar node = this._dofToLookatNodeMap[dofName];\n\t\tnode.update(poseCurrentPose, poseInplaceOut, target, time);\n\t}\n};\n\n/**\n * Get the most recently computed pose, without updating any state.  This is only valid once initialized\n * via generatePoseIncremental or generatePose have been called (after initial construction or any reset).\n *\n * @param {Pose} poseInplaceOut\n */\nMotionLookat.prototype.getPose = function(poseInplaceOut){\n\tfor(var i = 0; i < this._lookatNodes.length; i++){\n\t\tvar lookatNode = this._lookatNodes[i];\n\t\t//only ask nodes that are in our poseInplaceOut\n\t\tvar dofsForNode = this._lookatNodeToDOFsMap[lookatNode.getName()];\n\t\tfor(var j = 0; j < dofsForNode.length; j++){\n\t\t\tif(poseInplaceOut.get(dofsForNode[j])!==null){\n\t\t\t\tlookatNode.getPose(poseInplaceOut);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n/**\n * Produces the optimal lookat pose, regardless of current state/time.  Does not update state.\n *\n * @param {Pose} poseCurrentPose - should contain at least nodes of relevance to the computation, e.g. ancestor nodes\n * @param {Pose} poseInplaceOut - output values will be stored here\n * @param {THREE.Vector3} target - target in world space\n */\nMotionLookat.prototype.getOptimalPose = function(poseCurrentPose, poseInplaceOut, target){\n\tif(poseCurrentPose!==poseInplaceOut) {\n\t\tposeInplaceOut.setPose(poseCurrentPose);\n\t}\n\n\t//use _internalPose instead of poseInplaceOutput in case it doesn't have required state dofs\n\tthis._internalPose.setPose(poseCurrentPose);\n\n\tfor(var i = 0; i < this._lookatNodes.length; i++){\n\t\tthis._lookatNodes[i].getOptimalPose(this._internalPose, this._internalPose, target);\n\t}\n\n\tposeInplaceOut.setPose(this._internalPose);\n};\n\n/**\n * Get the distance remaining for this lookat to travel to the current target.  Does not advance (use update())\n * This value is computed from the data calculated in the last generatePose() call.  The value is the maximum\n * distance remaining for any DOF used in this lookat.\n *\n * @param {string[]} [dofNames] - only count distance on lookats that contain at least one of these dofs.  all nodes checked if omitted/null\n * @return {number} distance of dof with largest remaining distance (as ratio of current distance of total range of LookatDOF)\n */\nMotionLookat.prototype.getDistanceRemaining = function(dofNames){\n\tvar i;\n\tvar d;\n\tvar maxD = 0;\n\tif(dofNames == null) { //null of undefined (eqnull)\n\t\tfor (i = 0; i < this._lookatNodes.length; i++) {\n\t\t\td = this._lookatNodes[i].getDistanceRemaining();\n\t\t\tif (d > maxD) {\n\t\t\t\tmaxD = d;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tvar processed = {};\n\t\tfor(i = 0; i < dofNames.length; i++){\n\t\t\tvar dofName = dofNames[i];\n\t\t\tif(this._dofToLookatNodeMap.hasOwnProperty(dofName)){\n\t\t\t\tvar node = this._dofToLookatNodeMap[dofName];\n\t\t\t\tif(processed[node.getName()] !== true){\n\t\t\t\t\td = node.getDistanceRemaining();\n\t\t\t\t\tif(d > maxD){\n\t\t\t\t\t\tmaxD = d;\n\t\t\t\t\t}\n\t\t\t\t\tprocessed[node.getName()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn maxD;\n};\n\n/**\n * @return {string[]} dof names that can be affected by this lookat\n */\nMotionLookat.prototype.getDOFs = function(){\n\tvar dofNames = [];\n\tfor(var i = 0; i < this._lookatNodes.length; i++) {\n\t\tdofNames = dofNames.concat(this._lookatNodes[i].getDOFs());\n\t}\n\treturn dofNames;\n};\n\n/**\n * @returns {Array.<string>} all dof names that this lookat affects, or that can affect this lookat (ancestors)\n */\nMotionLookat.prototype.getStateDOFs = function(){\n\treturn this._internalPose.getDOFNames();\n};\n\nMotionLookat.prototype.reset = function(){\n\tfor(var i = 0; i < this._lookatNodes.length; i++){\n\t\tthis._lookatNodes[i].reset();\n\t}\n};\n\nmodule.exports = MotionLookat;"],"sourceRoot":"/source/"}