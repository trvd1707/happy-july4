{"version":3,"sources":["ifr-motion/lookat/RotationalPlaneAlignmentLookatDOF.js"],"names":[],"mappings":"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","file":"ifr-motion/lookat/RotationalPlaneAlignmentLookatDOF.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar THREE = require(\"three\");\nvar PointADOF = require(\"./PointADOF\");\nvar LookatDOF = require(\"./LookatDOF\");\nvar ExtraMath = require(\"../../ifr-geometry/ExtraMath\");\n\n/**\n *\n * @param {string} name\n * @param {string} controlledDOFName\n * @param {THREE.Vector3} planeNormal\n * @param {number} distanceAlongDOFAxisToPlane\n * @param {number} angleAbovePlane\n * @extends LookatDOF\n * @constructor\n */\nvar RotationalPlaneAlignmentLookatDOF = function(name, controlledDOFName, planeNormal,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdistanceAlongDOFAxisToPlane, angleAbovePlane){\n\tLookatDOF.call(this, name, controlledDOFName);\n\n\t/** @type {RotationControl} */\n\tthis._control = null;\n\n\t/**\t@type {THREE.Vector3} */\n\tthis._planeNormal = planeNormal;\n\n\t/**\t@type {number} */\n\tthis._distanceAlongDOFAxisToPlane = distanceAlongDOFAxisToPlane;\n\n\t/**\t@type {number} */\n\tthis._angleAbovePlane = angleAbovePlane;\n\n\t/** @type {THREE.Object3D} */\n\tthis._transform = null;\n};\n\nRotationalPlaneAlignmentLookatDOF.prototype = Object.create(LookatDOF.prototype);\nRotationalPlaneAlignmentLookatDOF.prototype.constructor = RotationalPlaneAlignmentLookatDOF;\n\n/**\n * @param {KinematicGroup} kinematicGroup group to use for kinematic math (assumed to be configured as desired before valToPointAtTarget calls)\n */\nRotationalPlaneAlignmentLookatDOF.prototype.connectToGroup = function(kinematicGroup){\n\tLookatDOF.prototype.connectToGroup.call(this, kinematicGroup);\n\tif(kinematicGroup) {\n\t\tthis._control = this._kinematicGroup.getModelControlGroup().getControlForDOF(this._controlledDOFName);\n\t\tthis._transform = this._kinematicGroup.getTransform(this._control.getTransformName());\n\t}else{\n\t\tthis._transform = null;\n\t\tthis._control = null;\n\t}\n};\n\n\n/**\n * Compute value is relative to current setup of the hierarchy that this._transform is part of.\n *\n * @param {THREE.Vector2} target\n * @return {number} Value to cause this._control to point local this._forwardDir at the target\n * @param {PointReport} [pointReport] - inplace arg to return metadata about computation\n * @override\n */\nRotationalPlaneAlignmentLookatDOF.prototype.valToPointAtTarget = function(target, pointReport){\n\tvar values = PointADOF.pointDOFToIntersectConeWithPoint(this._control, this._transform,\n\t\tthis._planeNormal, this._distanceAlongDOFAxisToPlane, target, this._angleAbovePlane, true, pointReport);\n\tif(values && values.length > 0){\n\t\treturn values[0]; //TODO: return both, choose in caller?\n\t}\n};\n\n/**\n * Provide the ratio that this error represents for the range of motion of this LookatDOF.\n * For cyclic dofs, range is considered one revolution.\n *\n * @param errorAbsolute absolute error\n * @return {number} ratio that absoluteError represents of the total range of this LookatDOF\n * @override\n */\nRotationalPlaneAlignmentLookatDOF.prototype.errorRatio = function(errorAbsolute){\n\tif(this._control.isCyclic()){\n\t\treturn Math.abs(errorAbsolute / (Math.PI*2));\n\t}else{\n\t\treturn Math.abs(errorAbsolute / (this._control.getMax()-this._control.getMin()));\n\t}\n};\n\n/**\n * provide a suggestion for a target that is forward for this lookat (node is already looking at this point)\n * @param {THREE.Vector3} inplaceVec\n * @return {THREE.Vector3}\n * @override\n */\nRotationalPlaneAlignmentLookatDOF.prototype.suggestForwardTarget = function(inplaceVec){\n\tif(this._transform == null){\n\t\treturn null;\n\t}else{\n\t\t//TODO: cache results and variables\n\t\tvar origin = new THREE.Vector3();\n\t\tthis._control.getRotationalAxis(origin);\n\t\tvar perp = new THREE.Vector3();\n\t\tExtraMath.findOrthogonal(this._planeNormal, perp);\n\n\t\tvar coneItAxis = new THREE.Vector3();\n\t\tconeItAxis.crossVectors(perp, this._planeNormal);\n\t\tvar coneItRot = new THREE.Quaternion();\n\t\tExtraMath.quatFromAxisAngle(coneItAxis, this._angleAbovePlane, coneItRot);\n\t\tperp.applyQuaternion(coneItRot);\n\n\t\torigin.setLength(this._distanceAlongDOFAxisToPlane);\n\t\tperp.setLength(10);\n\t\tinplaceVec.copy(perp);\n\t\tinplaceVec.add(origin);\n\n\t\tthis._transform.localToWorld(perp);\n\t\treturn inplaceVec;\n\t}\n};\n\n\nmodule.exports = RotationalPlaneAlignmentLookatDOF;\n"],"sourceRoot":"/source/"}