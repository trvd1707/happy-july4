{"version":3,"sources":["ifr-motion/lookat/OcularStabilizationTracker.js"],"names":[],"mappings":"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","file":"ifr-motion/lookat/OcularStabilizationTracker.js","sourcesContent":["/**\n * @author jg\n * Copyright 2015 IF Robots LLC\n */\n\n\"use strict\";\n\nvar slog = require(\"../../ifr-core/SLog\");\nvar Pose = require(\"../base/Pose\");\nvar THREE = require(\"three\");\nvar LookatNode = require(\"./LookatNode\");\n\n/**\n *\n * @param {LookatNode} lookatNode\n * @param {DOFGlobalAlignment} dofAligner\n * @constructor\n */\nvar OcularStabilizationTracker = function(lookatNode, dofAligner){\n\t/** @type {boolean} */\n\tvar initialized = false;\n\n\t/** @type {THREE.Vector3} */\n\tvar lastTargetWorldSpace = new THREE.Vector3();\n\n\t/** @type {string[]} */\n\tvar dofNamesInUse = lookatNode.getDOFs();\n\n\t/** @type {Pose} */\n\tvar lastOptimalPoseForLastTarget = new Pose(lookatNode.getName()+\" Last Optimal\", dofNamesInUse);\n\n\t/** @type {Pose} */\n\tvar newOptimalPoseForLastTarget = new Pose(lookatNode.getName()+\" Stepped Pose\", dofNamesInUse);\n\n\t/** @type {Pose} */\n\tvar deltaPoseFromLastTime = new Pose(lookatNode.getName()+\" OST Delta\", dofNamesInUse);\n\n\t/** @type {Pose} */\n\tvar decompLastPoseOptimal = new Pose(lookatNode.getName()+\" Temp Last Pose Optimal\", dofNamesInUse);\n\n\t/** @type {Pose} */\n\tvar decompLastPose = null; //init with correct nodes when first used.\n\n\t/**\n\t *\n\t * @param {Pose} currentPose\n\t * @param {Pose} optimalPoseForCurrentTarget\n\t * @param {THREE.Vector3} currentTarget\n\t * @returns {Pose}\n\t */\n\tthis.computeStabilizationDelta = function(currentPose, optimalPoseForCurrentTarget, currentTarget){\n\n\t\tif(initialized){\n\t\t\tvar report = new LookatNode.PointNodeReport();\n\t\t\tlookatNode.getPose(currentPose, newOptimalPoseForLastTarget, lastTargetWorldSpace, null, report);\n\t\t\tif(report._pointSucceeded){\n\t\t\t\tif(dofAligner!=null){\n\t\t\t\t\tdofAligner.refineToLocallyClosestTargetPose(lastOptimalPoseForLastTarget, newOptimalPoseForLastTarget);\n\t\t\t\t}\n\t\t\t\tPose.subtract(newOptimalPoseForLastTarget, lastOptimalPoseForLastTarget, true, deltaPoseFromLastTime);\n\t\t\t}else{\n\t\t\t\t//can't do anything with newOptimal; we'll report zero delta\n\t\t\t\tfor(var r = 0; r < deltaPoseFromLastTime.getDOFNames(); r++){\n\t\t\t\t\tdeltaPoseFromLastTime.set(deltaPoseFromLastTime.getDOFNames()[r],0,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tdeltaPoseFromLastTime.clear();\n\t\t\tfor(var f = 0; f < dofNamesInUse.length; f++){\n\t\t\t\tdeltaPoseFromLastTime.set(dofNamesInUse[f], 0, 0); //start off with zero delta\n\t\t\t}\n\t\t}\n\n\t\tlastTargetWorldSpace.copy(currentTarget);\n\t\tif(optimalPoseForCurrentTarget == null){\n\t\t\t//if it is not provided, we must calculate it here.\n\t\t\tlookatNode.getPose(currentPose, lastOptimalPoseForLastTarget, currentTarget);\n\t\t}else{\n\t\t\tlastOptimalPoseForLastTarget.setPose(optimalPoseForCurrentTarget);\n\t\t}\n\t\tinitialized = true;\n\t\treturn deltaPoseFromLastTime;\n\t};\n\n\t/**\n\t * This function computes the portion of each node's velocity that is used to stabilize it against\n\t * parent motion (e.g., the portion that would be produced by computeStabilizationDelta).  It then subtracts\n\t * that portion off, and returns the remainder which represents the post-stabilized motion of the node.  These\n\t * velocities are computed for each dof used by this node, and provided through the inplacePostStabilizationPose\n\t * argument.\n\t *\n\t * @param {Pose} currentPose - current pose and velocities (can be same as inplacePostStabilizationPose)\n\t * @param {Pose} inplacePostStabilizationPose - inplace argument to receive computed velocities (other values unchanged)\n\t * @param {THREE.Vector3} target - stabilize with respect to this target\n\t * @param {number} [rejectionDeltaThreshold=0] - limit the delta component (represented as raw distance over 1/50s) related to stabilization to this value (0 means no limit)\n\t */\n\tthis.decomposeVelocity = function(currentPose, inplacePostStabilizationPose, target, rejectionDeltaThreshold){\n\n\t\tif(rejectionDeltaThreshold == null){ //null or undefined (eqnull)\n\t\t\trejectionDeltaThreshold = 0;\n\t\t}\n\n\t\tif(decompLastPose === null){\n\t\t\tdecompLastPose = new Pose(lookatNode.getName()+\" Decomp Last Pose\");\n\t\t}\n\n\t\tPose.advanceByTime(currentPose, true, decompLastPose, -1/50.0);\n\n\t\tlookatNode.getPose(currentPose, newOptimalPoseForLastTarget, target);\n\t\tlookatNode.getPose(decompLastPose, decompLastPoseOptimal, target);\n\n\t\tif(dofAligner!=null){\n\t\t\tdofAligner.refineToLocallyClosestTargetPose(decompLastPoseOptimal, newOptimalPoseForLastTarget);\n\t\t}\n\n\t\tPose.subtract(newOptimalPoseForLastTarget, decompLastPoseOptimal, true, deltaPoseFromLastTime);\n\n\t\tvar dofNames = deltaPoseFromLastTime.getDOFNames();\n\t\tfor(var i = 0; i < dofNames.length; i++){\n\t\t\tvar dofName = dofNames[i];\n\t\t\tvar originalVelocity = currentPose.get(dofName,1);\n\t\t\tvar deltaComponent = deltaPoseFromLastTime.get(dofName, 0);\n\t\t\tif(rejectionDeltaThreshold!==0 && Math.abs(deltaComponent) > rejectionDeltaThreshold){\n\t\t\t\tslog.error(\"Clamping OST application of unfiltered offset of \"+deltaPoseFromLastTime+\" to \"+dofName+\" as it is greater than \"+rejectionDeltaThreshold);\n\t\t\t\tif(deltaComponent < 0){\n\t\t\t\t\tdeltaComponent = -rejectionDeltaThreshold;\n\t\t\t\t}else{\n\t\t\t\t\tdeltaComponent = rejectionDeltaThreshold;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar stabilizationVelocity = deltaComponent * 50;\n\t\t\tinplacePostStabilizationPose.set(dofName, originalVelocity-stabilizationVelocity, 1);\n\t\t}\n\t};\n\n\t/**\n\t * Reset between tracking sessions, so the first frame of a new track isn't treated\n\t * as part of the last tracking (with a large jump).  When computeStabilizationDelta is\n\t * called multiple times in a row with no intervening reset, it is assumed to be part of\n\t * a single stabilization session.\n\t */\n\tthis.reset = function(){\n\t\tinitialized = false;\n\t};\n};\n\nmodule.exports = OcularStabilizationTracker;"],"sourceRoot":"/source/"}