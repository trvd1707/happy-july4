/**
 * @author mattb
 * Copyright 2014 IF Robots LLC
 */

"use strict";

var BasicMesh = require("../BasicMesh");
var BasicFrame = require("../BasicFrame");
var FileTools = require("../../ifr-core/FileTools");
var THREE = require("three");

/**
 * @constructor
 */
var ModelLoadResult = function ModelLoadResult() {
	/** @type {string} */
	this.url = null;
	/** @type {!boolean} */
	this.success = false;
	/** @type {string} */
	this.message = "";

	/** @type {Array.<BasicMesh>} */
	this.meshes = null;
};

/**
 * @param {THREE.MeshPhongMaterial} defaultMaterial
 * @constructor
 */
var ModelLoader = function ModelLoader(defaultMaterial) {
	/** @type {THREE.MeshPhongMaterial} */
	this.defaultMaterial = defaultMaterial;
	if (!this.defaultMaterial) {
		this.defaultMaterial = new THREE.MeshPhongMaterial();
	}

	/** @type {string} */
	this.baseTextureURL = null;

	/** @type {ModelLoadResult} */
	this._result = null;
};

/**
 * @return {ModelLoadResult}
 */
ModelLoader.prototype.getResult = function () {
	return this._result;
};

/**
 * @param {string} url
 * @param callback
 */
ModelLoader.prototype.load = function (url, callback) {
	var self = this;
	FileTools.loadJSON(url, function (error, data) {
		if (error === null) {
			self.parseData(data, url);
			if (callback) {
				callback();
			}
		} else {
			var result = new ModelLoadResult();
			result.url = url;
			result.success = false;
			result.message = error;
			self._result = result;
			if (callback) {
				callback();
			}
		}
	});
};

/**
 * @param {Object} jsonData
 * @param {string} dataUrl
 */
ModelLoader.prototype.parseData = function (jsonData, dataUrl) {
	this._result = new ModelLoadResult();
	this._result.url = dataUrl;

	if (jsonData.header.fileType !== "Meshes") {
		this._result.success = false;
		this._result.message = "don't know how to handle file type: " + jsonData.header.fileType;
		return;
	}

	var parentDir = dataUrl.substring(0, dataUrl.lastIndexOf('/') + 1);

	this._result.meshes = [];
	for (var meshIndex = 0; meshIndex < jsonData.content.meshes.length; meshIndex++) {
		var meshData = jsonData.content.meshes[meshIndex];

		var mesh = new BasicMesh();
		mesh.name = meshData.name;
		mesh.skeletonFrameName = meshData.skeletonFrameName;

		var geom = new THREE.BufferGeometry();

		var positionData = new Float32Array(meshData.position);
		geom.addAttribute("position", new THREE.BufferAttribute(positionData, 3));

		if (meshData.normal) {
			var normalData = new Float32Array(meshData.normal);
			geom.addAttribute("normal", new THREE.BufferAttribute(normalData, 3));
		}

		if (meshData.textureCoordinates) {
			var textureData = new Float32Array(meshData.textureCoordinates);
			geom.addAttribute("uv", new THREE.BufferAttribute(textureData, 2));
		}

		if (meshData.triangles) {
			var faceData = new Uint32Array(meshData.triangles);
			geom.addAttribute("index", new THREE.BufferAttribute(faceData, 3));
		}

		if (meshData.color) {
			var colorData = new Float32Array(meshData.color.length / 4 * 3);
			for (var i = 0; i < meshData.color.length / 4; i++) {
				colorData[i * 3] = meshData.color[i * 4];
				colorData[i * 3 + 1] = meshData.color[i * 4 + 1];
				colorData[i * 3 + 2] = meshData.color[i * 4 + 2];
			}
			geom.addAttribute("color", new THREE.BufferAttribute(colorData, 3));
		}

		/** @type {THREE.MeshPhongMaterial} */
		var meshMaterial = this.defaultMaterial.clone();
		meshMaterial.vertexColors = meshData.color ? THREE.VertexColors : THREE.NoColors;

		if (meshData.material) {
			var mat = meshData.material;
			if (mat.ambient) {
				meshMaterial.ambient = new THREE.Color(mat.ambient[0], mat.ambient[1], mat.ambient[2]);
			}
			if (mat.diffuse) {
				meshMaterial.color = new THREE.Color(mat.diffuse[0], mat.diffuse[1], mat.diffuse[2]);
			}
			if (mat.specular) {
				meshMaterial.specular = new THREE.Color(mat.specular[0], mat.specular[1], mat.specular[2]);
			}
			if (mat.emissive) {
				meshMaterial.emissive = new THREE.Color(mat.emissive[0], mat.emissive[1], mat.emissive[2]);
			}
			if (mat.shininess) {
				meshMaterial.shininess = mat.shininess;
			}
			if (mat.texture) {
				var textureURL = this.baseTextureURL ? this.baseTextureURL + mat.texture : parentDir + mat.texture;
				var texture = THREE.ImageUtils.loadTexture(textureURL);
				texture.minFilter = THREE.LinearFilter;
				meshMaterial.map = texture;
			}
		}

		if (!meshData.skin) {
			mesh.mesh = new THREE.Mesh(geom, meshMaterial);
			mesh.mesh.name = meshData.name;
		} else {
			mesh.mesh = new THREE.SkinnedMesh(geom, meshMaterial);
			mesh.mesh.name = meshData.name;

			var skinData = meshData.skin;
			mesh.boneFrameNames = skinData.skeletonTotalInfluences;
			var numBones = mesh.boneFrameNames.length;

			var bindFrame = new BasicFrame().setFromJson(skinData.skinBindFrame);
			var bindMatrix = bindFrame.toMatrix4();

			mesh.bones = [];
			var boneInverses = [];
			for (var b = 0; b < numBones; b++) {
				var boneFrame = new BasicFrame().setFromJson(skinData.skinBindInverses[b]);
				boneInverses.push(boneFrame.toMatrix4());
				var bone = new THREE.Bone(mesh.mesh);
				mesh.bones.push(bone);
			}

			var skeleton = new THREE.Skeleton(mesh.bones, boneInverses, false);

			mesh.mesh.bindMode = "detached";
			mesh.mesh.bind(skeleton, bindMatrix);

			var numVertices = positionData.length / 3;
			var skinWeights = new Float32Array(skinData.skeletonWeightsByVertex);
			var skinIndices = new Float32Array(skinData.skeletonInfluencesByVertex);

			if (skinWeights.length !== numVertices * 4) {
				this._result.success = false;
				this._result.message = "expected " + numVertices * 4 + " skeleton weights for mesh " + mesh.name + ", but got: " + skinWeights.length;
				return;
			}
			if (skinIndices.length !== numVertices * 4) {
				this._result.success = false;
				this._result.message = "expected " + numVertices * 4 + " skeleton influences for mesh " + mesh.name + ", but got: " + skinIndices.length;
				return;
			}

			geom.addAttribute("skinWeight", new THREE.BufferAttribute(skinWeights, 4));
			geom.addAttribute("skinIndex", new THREE.BufferAttribute(skinIndices, 4));
		}

		this._result.meshes.push(mesh);
	}

	this._result.success = true;
};

module.exports = ModelLoader;
//# sourceMappingURL=../../map/ifr-geometry/loaders/ModelLoader.js.map
