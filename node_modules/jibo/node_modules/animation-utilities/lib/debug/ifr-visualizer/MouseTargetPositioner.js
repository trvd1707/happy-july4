/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var THREE = require("three");
var MouseCoordinateWrangler = require("./MouseCoordinateWrangler");
var ViewportTargetPositioner = require("./ViewportTargetPositioner");
var slog = require("../ifr-core/SLog");

var channel = "UI_TARGET";

/**
 * @callback MouseEventSelectionFilter
 * @param {MouseEvent}
 * @return {boolean}
 */

/**
 *
 * @param {Element} element - the gl element
 * @param {THREE.PerspectiveCamera} camera - camera that is projecting this scene
 * @param {THREE.Vector3} defaultInitialPosition - initial position, (0,0,0) will be used if omitted
 * @param {THREE.Vector3} pointOnGroundPlane - any point on the ground plane, (0,0,0) will be used if omitted
 * @param {THREE.Vector3} groundPlaneNormal - normal of the ground plane, (0,1,0) will be used if omitted
 * @param {string[]} [initialTargetNames] - names of initial target positioners.  defaults to ["default"].  pass [] to start with no positioners.
 * @constructor
 */
var MouseTargetPositioner = function MouseTargetPositioner(element, camera, defaultInitialPosition, pointOnGroundPlane, groundPlaneNormal, initialTargetNames) {

	if (defaultInitialPosition == null) {
		//null or undefined (eqnull)
		defaultInitialPosition = new THREE.Vector3(0, 0, 0);
	}
	if (pointOnGroundPlane == null) {
		//null or undefined (eqnull)
		pointOnGroundPlane = new THREE.Vector3(0, 0, 0);
	}
	if (groundPlaneNormal == null) {
		//null or undefined (eqnull)
		groundPlaneNormal = new THREE.Vector3(0, 1, 0);
	}
	if (initialTargetNames == null) {
		//null or undefined (eqnull)
		initialTargetNames = ["default"];
	}

	/** positionChangedCallback[] */
	var positionChangedListeners = [];

	/** @type{Map<string,ViewportTargetPositioner>} */
	var targetPositioners = new Map();

	/** @type{string} */
	var selectedPositionerName = null;

	var capture = true;

	/** @type {MouseEventSelectionFilter} */
	var isForMe = null;
	/** @type {MouseEventSelectionFilter} */
	var isForGroundPlane = null;
	/** @type {MouseEventSelectionFilter} */
	var isForCameraPlane = null;

	/** @type {BasicScene} */
	var renderInScene = null;

	/**
  * @param {MouseEvent} event
  */
	var processEvent = function processEvent(event) {
		event.preventDefault();
		event.stopPropagation();
		var local = MouseCoordinateWrangler.getLocalCoordinatesNDCCentered(event, element);
		if (selectedPositionerName != null) {
			var currentVTP = targetPositioners.get(selectedPositionerName);
			if (currentVTP != null) {
				if (isForGroundPlane(event)) {
					currentVTP.moveToNDCPoint(local.x, local.y, true);
				} else if (isForCameraPlane(event)) {
					currentVTP.moveToNDCPoint(local.x, local.y, false);
				}
			}
		}
	};

	/**
  * @param {MouseEvent} event
  */
	var mouseMoved = function mouseMoved(event) {
		if (isForMe(event)) {
			processEvent(event);
		}
	};

	var acceptOutOfWindowMotions = true;
	/**
  * @param {MouseEvent} event
  */
	var mouseUp = function mouseUp(event) {
		// eslint-disable-line no-unused-vars
		if (acceptOutOfWindowMotions) {
			document.removeEventListener("mousemove", mouseMoved, capture);
			document.removeEventListener("mouseup", mouseUp, capture);
		} else {
			element.removeEventListener("mousemove", mouseMoved, capture);
			element.removeEventListener("mouseup", mouseUp, capture);
			element.removeEventListener("mouseleave", mouseUp, capture);
		}
	};

	element.addEventListener('mousedown', function (event) {
		if (isForMe(event)) {
			processEvent(event);
			if (acceptOutOfWindowMotions) {
				document.addEventListener('mousemove', mouseMoved, capture);
				document.addEventListener('mouseup', mouseUp, capture);
			} else {
				element.addEventListener('mousemove', mouseMoved, capture);
				element.addEventListener('mouseup', mouseUp, capture);
				element.addEventListener('mouseleave', mouseUp, capture);
			}
		}
	}, capture);

	/**
  * Set mouse filters for this positioner.  The "isForMeFilter" is first applied, and only
  * events that match this filter will be processed at all.  "isForGroupPlane" and "isForCamera"
  * filters will only be run on events that already passed the "isForMeFilter".  "isForGroundPlane"
  * is evaluated first, points will not be used for camera plane if they match for ground plane.
  *
  * @param {MouseEventSelectionFilter} [isForMeFilter] - specify filter for this positioner (default is NONE of alt, meta, ctrl down)
  * @param {MouseEventSelectionFilter} [isForGroundPlaneFilter] - specify filter for ground plane clicks (default is shift down)
  * @param {MouseEventSelectionFilter} [isForCameraPlaneFilter] - specify filter for camera plane clicks (default is shift up)
  */
	this.setMouseFilters = function (isForMeFilter, isForGroundPlaneFilter, isForCameraPlaneFilter) {
		if (isForMeFilter != null) {
			//null or undefined
			isForMe = isForMeFilter;
		} else {
			isForMe = function isForMe(event) {
				return !event.altKey && !event.metaKey && !event.ctrlKey;
			};
		}
		if (isForGroundPlaneFilter != null) {
			//null or undefined
			isForGroundPlane = isForGroundPlaneFilter;
		} else {
			isForGroundPlane = function isForGroundPlane(event) {
				return event.shiftKey;
			};
		}
		if (isForCameraPlaneFilter != null) {
			//null or undefined
			isForCameraPlane = isForCameraPlaneFilter;
		} else {
			isForCameraPlane = function isForCameraPlane(event) {
				return !event.shiftKey;
			};
		}
	};

	/**
  * @param {positionChangedCallback} cb
  */
	this.addPositionChangedCallback = function (cb) {
		var cbIndex = positionChangedListeners.indexOf(cb);
		if (cbIndex < 0) {
			positionChangedListeners.push(cb);
		}
	};

	/**
  * @param {positionChangedCallback} cb
  */
	this.removePositionChangedCallback = function (cb) {
		var cbIndex = positionChangedListeners.indexOf(cb);
		if (cbIndex > -1) {
			positionChangedListeners.splice(cbIndex, 1);
		}
	};

	/**
  * @param {THREE.Vector3} position
  * @param {string} name
  */
	this.notifyPositionChangedCallbacks = function (position, name) {
		for (var i = 0; i < positionChangedListeners.length; i++) {
			positionChangedListeners[i](position, name);
		}
	};

	/**
  * @param {string} name
 	 * @param {THREE.Vector3} [initialPosition] defaults to value passed to MouseTargetPositioner constructor.
  */
	this.addTargetPositioner = function (name, initialPosition) {
		if (!targetPositioners.has(name)) {
			if (initialPosition == null) {
				//null or undefined (eqnull)
				initialPosition = defaultInitialPosition;
			}
			var vtp = new ViewportTargetPositioner(name, camera, initialPosition, pointOnGroundPlane, groundPlaneNormal);
			vtp.addPositionChangedCallback(this.notifyPositionChangedCallbacks);
			if (renderInScene !== null) {
				vtp.installRendererIntoScene(renderInScene);
			}
			targetPositioners.set(name, vtp);
			if (selectedPositionerName === null) {
				selectedPositionerName = name;
				vtp.setHighlighted(true);
			} else {
				vtp.setHighlighted(false);
			}
		} else {
			slog(channel, "Not adding MouseTargetPositioner target " + name + ", already have target with that name");
		}
	};

	this.removeTargetPositioner = function (name) {
		if (targetPositioners.has(name)) {
			var vtp = targetPositioners.get(name);
			if (renderInScene !== null) {
				vtp.removeRendererFromScene(renderInScene);
			}
			vtp.removePositionChangedCallback(this.notifyPositionChangedCallbacks);
			targetPositioners.delete(name);
			if (selectedPositionerName === name) {
				selectedPositionerName = null;
			}
		}
	};

	this.getTargetPositionerNames = function () {
		var names = [];
		var nameIter = targetPositioners.keys();
		var nextName;
		while (!(nextName = nameIter.next()).done) {
			names.push(nextName.value);
		}
		return names;
	};

	/**
  * @param {?string} name - name of target to select, null to deselect all
  */
	this.selectTarget = function (name) {
		if (selectedPositionerName != null) {
			var currentlySelected = targetPositioners.get(selectedPositionerName);
			if (currentlySelected != null) {
				currentlySelected.setHighlighted(false);
			}
		}
		if (name != null) {
			var newlySelected = targetPositioners.get(name);
			if (newlySelected != null) {
				newlySelected.setHighlighted(true);
			}
		}
		selectedPositionerName = name;
	};

	this.installRendererIntoScene = function (scene) {
		if (renderInScene !== null) {
			throw new Error("Remove MTP renderer from existing scene before installing in another!");
		}
		for (var vtp of targetPositioners.values()) {
			vtp.installRendererIntoScene(scene);
		}
		renderInScene = scene;
	};

	this.removeRendererFromScene = function (scene) {
		for (var vtp of targetPositioners.values()) {
			vtp.removeRendererFromScene(scene);
		}
		renderInScene = null;
	};

	//set to default
	this.setMouseFilters();

	for (var installName of initialTargetNames) {
		this.addTargetPositioner(installName);
	}
};

module.exports = MouseTargetPositioner;
//# sourceMappingURL=../map/ifr-visualizer/MouseTargetPositioner.js.map
