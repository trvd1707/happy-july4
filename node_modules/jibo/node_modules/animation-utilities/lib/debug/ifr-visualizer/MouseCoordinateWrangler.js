/**
 * @author jg
 * Copyright 2015 IF Robots LLC
 */

"use strict";

var THREE = require("three");
var slog = require("../ifr-core/SLog");

var channel = "MOUSE_COORD_WRANGLER";

var MouseCoordinateWrangler = {};

/**
 * Get the offset rect of an element on the page. Rect will be relative to page top left, scroll-invariant
 * @param {Element} elem
 * @returns {{top: number, left: number, width: number, height: number}} rect of elem on entire page in pixels, from top-left, scroll-invariant
 */
MouseCoordinateWrangler.getOffsetRect = function (elem) {
	var box = elem.getBoundingClientRect();
	var body = document.body;
	var docElem = document.documentElement;

	var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
	var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

	var clientTop = docElem.clientTop || body.clientTop || 0;
	var clientLeft = docElem.clientLeft || body.clientLeft || 0;

	var top = box.top + scrollTop - clientTop;
	var left = box.left + scrollLeft - clientLeft;
	return { top: Math.round(top), left: Math.round(left), width: Math.round(box.width), height: Math.round(box.height) };
};

/**
 *
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {THREE.Camera} camera
 * @returns {{x:number, y:number}} ndc 2D (-1 to 1) location for this 3d location
 */
MouseCoordinateWrangler.projectToScreenNDC = function (x, y, z, camera) {
	var projected = new THREE.Vector3(x, y, z).project(camera);
	return { x: projected.x, y: projected.y };
};

/**
 *
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @param {THREE.Camera} camera
 * @param {Element} container
 * @param {boolean} [dropOutOfBounds] = false
 * @returns {?{x:number, y:number}} pixel location for this 3d location
 */
MouseCoordinateWrangler.projectToScreenPixels = function (x, y, z, camera, container, dropOutOfBounds) {
	var projected = new THREE.Vector3(x, y, z).project(camera);
	if (projected.z < 0 || projected.z > 1) {
		//behind camera or past far plane
		//console.log("Clipping:"+projected.z);
		return null;
	}
	if (dropOutOfBounds === true && (Math.abs(projected.x) > 1 || Math.abs(projected.y) > 1)) {
		return null;
	}
	var rect = container.getBoundingClientRect();
	var width = rect.width;
	var height = rect.height;
	return { x: projected.x * width / 2 + width / 2, y: -projected.y * height / 2 + height / 2 };
};

/**
 *
 * @param {UIEvent} event
 * @param {Element} element
 * @returns {{x: number, y: number}} pixel location of the event relative to the top left of the element
 */
MouseCoordinateWrangler.getLocalCoordinates = function (event, element) {
	var bounds = MouseCoordinateWrangler.getOffsetRect(element);
	return { x: event.pageX - bounds.left, y: event.pageY - bounds.top };
};

/**
 *
 * @param {UIEvent} event
 * @param {Element} element
 * @returns {{x: number, y: number}} NDC location of the event relative to the bottom left of the element (0-1 from bottom left)
 */
MouseCoordinateWrangler.getLocalCoordinatesNDC = function (event, element) {
	var bounds = MouseCoordinateWrangler.getOffsetRect(element);
	return { x: (event.pageX - bounds.left) / bounds.width, y: 1 - (event.pageY - bounds.top) / bounds.height };
};

/**
 *
 * @param {UIEvent} event
 * @param {Element} element
 * @returns {{x: number, y: number}} NDC location of the event relative to the center of the element (-1 to 1, cartesian)
 */
MouseCoordinateWrangler.getLocalCoordinatesNDCCentered = function (event, element) {
	var bounds = MouseCoordinateWrangler.getOffsetRect(element);
	return { x: (event.pageX - bounds.left) / bounds.width * 2 - 1, y: (1 - (event.pageY - bounds.top) / bounds.height) * 2 - 1 };
};

/**
 *
 * @param {number} ndcCenteredScreenX - screen location x in centered NDC (-1 to 1)
 * @param {number} ndcCenteredScreenY - screen location y in centered NDC (-1 to 1)
 * @param {THREE.PerspectiveCamera} camera - camera that is projecting this scene
 * @param {THREE.Vector3} pointOnPlane - any point on the target plane, (0,0,0) will be used if omitted
 * @param {THREE.Vector3} planeNormal - normal of the target plane, (0,1,0) will be used if omitted
 * @returns {THREE.Vector3} the point where the screen point intersects the given plane, or undefined if it doesn't intersect
 */
MouseCoordinateWrangler.unprojectScreenToPlane = function (ndcCenteredScreenX, ndcCenteredScreenY, camera, pointOnPlane, planeNormal) {

	var screenVecNear = new THREE.Vector3(ndcCenteredScreenX, ndcCenteredScreenY, 0);
	var screenVecFar = new THREE.Vector3(ndcCenteredScreenX, ndcCenteredScreenY, 1);
	screenVecNear.unproject(camera);
	screenVecFar.unproject(camera);

	var lineDirection = screenVecFar.sub(screenVecNear);
	var lineAnchor = screenVecNear;

	lineDirection.normalize();
	var lineAnchorToPlaneAnchor = new THREE.Vector3().copy(pointOnPlane).sub(lineAnchor);
	var denominator = lineDirection.dot(planeNormal);
	if (Math.abs(denominator) < 0.0001) {
		slog(channel, "un-project error, no intersection");
		return undefined;
	} else {
		var dist = lineAnchorToPlaneAnchor.dot(planeNormal) / lineDirection.dot(planeNormal);
		if (dist < 0) {
			slog(channel, "error, intersection behind camera");
			return undefined;
		} else {
			return lineAnchor.add(lineDirection.multiplyScalar(dist));
		}
	}
};

/**
 *
 * @param {UIEvent} event - event to project the location of
 * @param {Element} element - the gl element
 * @param {THREE.PerspectiveCamera} camera - camera that is projecting this scene
 * @param {THREE.Vector3} pointOnPlane - any point on the target plane, (0,0,0) will be used if omitted
 * @param {THREE.Vector3} planeNormal - normal of the target plane, (0,1,0) will be used if omitted
 * @returns {THREE.Vector3} the point where the screen point intersects the given plane, or undefined if it doesn't intersect
 */
MouseCoordinateWrangler.unprojectEventToPlane = function (event, element, camera, pointOnPlane, planeNormal) {
	var local = MouseCoordinateWrangler.getLocalCoordinatesNDCCentered(event, element);
	if (pointOnPlane === undefined) {
		pointOnPlane = new THREE.Vector3(0, 0, 0);
	}
	if (planeNormal === undefined) {
		planeNormal = new THREE.Vector3(0, 1, 0);
	}
	return MouseCoordinateWrangler.unprojectScreenToPlane(local.x, local.y, camera, pointOnPlane, planeNormal);
};

module.exports = MouseCoordinateWrangler;
//# sourceMappingURL=../map/ifr-visualizer/MouseCoordinateWrangler.js.map
