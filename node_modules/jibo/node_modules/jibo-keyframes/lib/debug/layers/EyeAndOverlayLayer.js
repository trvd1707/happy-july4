'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _DOFBaseLayer2 = require('../bases/DOFBaseLayer');

var _DOFBaseLayer3 = _interopRequireDefault(_DOFBaseLayer2);

var _Conversion = require('../utils/Conversion');

var _Conversion2 = _interopRequireDefault(_Conversion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Eye/Overlays
var centerX = 0;
var centerY = 0;
var eyeRadiusX = 300;
var eyeRadiusY = 300;

var values = [{
    display: 'linear',
    label: 'Linear Tween',
    value: 'linear'
}, {
    display: 'sine in',
    label: 'Sine Ease In',
    value: 'sineIn'
}, {
    display: 'sine out',
    label: 'Sine Ease Out',
    value: 'sineOut'
}, {
    display: 'sine in out',
    label: 'Sine Ease In Out',
    value: 'sineInOut'
}, {
    display: 'cubic in',
    label: 'Cubic Ease In',
    value: 'cubicIn'
}, {
    display: 'cubic out',
    label: 'Cubic Ease Out',
    value: 'cubicOut'
}, {
    display: 'cubic in out',
    label: 'Cubic Ease In Out',
    value: 'cubicInOut'
}];

var Tween = {
    type: {
        name: 'enum',
        values: values
    },
    defaultValue: values[3],
    blendOperation: 'none'
};

var VertexType = function VertexType(xRelativeToCenter, yRelativeToCenter) {
    return {
        type: "vector2",
        defaultValue: {
            x: xRelativeToCenter,
            y: yRelativeToCenter
        },
        blendOperation: "add"
    };
};

var Info = {
    properties: {
        Rotate: {
            type: "float",
            defaultValue: 0.0,
            blendOperation: "add"
        },
        Scale: {
            type: "vector2",
            defaultValue: {
                x: 1,
                y: 1
            },
            blendOperation: "multiply"
        },
        Translate: {
            type: "vector2",
            defaultValue: {
                x: centerX,
                y: centerY
            },
            blendOperation: "add"
        },
        Visible: {
            type: "bool",
            defaultValue: true,
            blendOperation: "lastOneWins"
        },
        Alpha: {
            type: "float",
            defaultValue: 1.0,
            blendOperation: "multiply"
        },
        Tween: Tween,
        "Vertex 1": VertexType(-eyeRadiusX, -eyeRadiusY),
        "Vertex 2": VertexType(0, -eyeRadiusY),
        "Vertex 3": VertexType(eyeRadiusX, -eyeRadiusY),
        "Vertex 4": VertexType(-eyeRadiusX, 0),
        "Vertex 5": VertexType(0, 0),
        "Vertex 6": VertexType(eyeRadiusX, 0),
        "Vertex 7": VertexType(-eyeRadiusX, eyeRadiusY),
        "Vertex 8": VertexType(0, eyeRadiusY),
        "Vertex 9": VertexType(eyeRadiusX, eyeRadiusY)
    }
};

var EyeAndOverlayLayer = function (_DOFBaseLayer) {
    _inherits(EyeAndOverlayLayer, _DOFBaseLayer);

    function EyeAndOverlayLayer() {
        _classCallCheck(this, EyeAndOverlayLayer);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(EyeAndOverlayLayer).apply(this, arguments));
    }

    _createClass(EyeAndOverlayLayer, null, [{
        key: '_generateDofs',
        value: function _generateDofs(props, nameStem) {
            var _ref;

            return _ref = {}, _defineProperty(_ref, nameStem + "vertexJoint1_t", _Conversion2.default.toMetersX(props['Vertex 1'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint1_t_2", _Conversion2.default.toMetersY(props['Vertex 1'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint2_t", _Conversion2.default.toMetersX(props['Vertex 2'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint2_t_2", _Conversion2.default.toMetersY(props['Vertex 2'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint3_t", _Conversion2.default.toMetersX(props['Vertex 3'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint3_t_2", _Conversion2.default.toMetersY(props['Vertex 3'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint4_t", _Conversion2.default.toMetersX(props['Vertex 4'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint4_t_2", _Conversion2.default.toMetersY(props['Vertex 4'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint5_t", _Conversion2.default.toMetersX(props['Vertex 5'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint5_t_2", _Conversion2.default.toMetersY(props['Vertex 5'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint6_t", _Conversion2.default.toMetersX(props['Vertex 6'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint6_t_2", _Conversion2.default.toMetersY(props['Vertex 6'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint7_t", _Conversion2.default.toMetersX(props['Vertex 7'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint7_t_2", _Conversion2.default.toMetersY(props['Vertex 7'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint8_t", _Conversion2.default.toMetersX(props['Vertex 8'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint8_t_2", _Conversion2.default.toMetersY(props['Vertex 8'].y) * props.Scale.y), _defineProperty(_ref, nameStem + "vertexJoint9_t", _Conversion2.default.toMetersX(props['Vertex 9'].x) * props.Scale.x), _defineProperty(_ref, nameStem + "vertexJoint9_t_2", _Conversion2.default.toMetersY(props['Vertex 9'].y) * props.Scale.y), _ref;
        }
    }, {
        key: 'extend',
        value: function extend(input) {
            return _lodash2.default.extend({}, Info, input);
        }
    }]);

    return EyeAndOverlayLayer;
}(_DOFBaseLayer3.default);

exports.default = EyeAndOverlayLayer;
//# sourceMappingURL=../map/layers/EyeAndOverlayLayer.js.map
