{"version":3,"sources":["Runtime.js"],"names":[],"mappings":"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","file":"Runtime.js","sourcesContent":["/**\n * Class responsible for\n *   - saving and loading files\n *   - manipulating the animation and notifying views of changes\n *   - computing the values of animation at any given point in time\n */\nimport fs from \"fs\";\nimport _ from \"lodash\";\nimport Tweening from \"./utils/Tweening\";\nimport IDUtils from \"./utils/IDUtils\";\nimport Search from \"./utils/Search\";\nimport BlendOperations from './utils/BlendOperations';\n\nexport default class Runtime {\n\n    /**\n     * Create a new keyframes object.\n     *\n     * @param keyframeInfo {Object} Meta data that includes supported layer types,\n     *                              default values, and etc\n     * @returns {Object} The newly created keyframes object with default layers created\n     *\n     */\n    static create(keyframeInfo) {\n        let keyframes = {\n                version: keyframeInfo.defaults.version,\n                framerate: keyframeInfo.defaults.framerate,\n                duration: keyframeInfo.defaults.duration,\n                scale: keyframeInfo.defaults.scale,\n                layers: []\n            };\n\n        keyframeInfo.defaults.layers.forEach( (defaultLayer) => {\n            keyframes.layers.push({\n                id: IDUtils.create(),\n                name: defaultLayer.name,\n                type: defaultLayer.type,\n                visible: true,\n                locked: false,\n                keyframes: []\n            });\n        });\n\n        return keyframes;\n    }\n\n    /**\n     * Load an animation file into this instance\n     *\n     * @param uri {String} Filepath to load the keyframes file from\n     * @param keyframeInfo {Object} Meta data that includes supported layer types,\n     *                              default values, and etc\n     * @returns {Object} Keyframes file content\n     *\n     * TODO: Write validation code at some point to catch issues like a file that merged incorrectly,\n     * was corrupted, or is just the wrong file format/type. Ensure invariants such as:\n     *   - That keys are time ordered\n     *   - That key values are valid\n     *   - That all required fields exist and no extra ones do\n     */\n    static load(uri, keyframeInfo) {\n        let keyframes = JSON.parse(fs.readFileSync(uri, 'utf8'));\n\n        if(keyframeInfo.onLoad){\n            keyframeInfo.onLoad(keyframes);\n        }\n\n        return keyframes;\n    }\n\n    /**\n     * Save the keyframes to disk\n     *\n     * @param uri {String} Filepath to save to\n     * @param keyframes {Object} Keyframe object to serialize to disk\n     */\n    static save(uri, keyframes){\n        // Save the current animation state to disk with four spaces for indentation\n        fs.writeFileSync(uri, JSON.stringify(keyframes, null, '    '), 'utf8');\n    }\n\n    static _isEventLayer(layer, keyframeInfo) {\n        if (layer) {\n            let layerClass = keyframeInfo.layerTypes[layer.type];\n            return layerClass.isEvent();\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the dof values generated from all the DOF layers at a point in time\n     * @param keyframes {Object} Keyframes data we'll be evaluating the layers of\n     * @param keyframeInfo {Object} Meta data that includes supported layer types,\n     *                              default values, and etc\n     * @param timeInSeconds {number} The time to compute the final dof values at\n     * @param overrides {Object} If provided each field in this object includes a set of properties\n     *                           to override the usually calculated interpolated keyframed properties.\n     *                           This is useful in tools for interactively changing\n     *                           the properties of a layer at a point in time without\n     *                           committing a new keyframe as a user tries out different jibo poses\n     * @return {Object} An object who's fields are each dof and it's value after all\n     *                  interpolation and layer blending\n     */\n    static evaluateAllDOFLayers(keyframes, keyframeInfo, timeInSeconds, overrides){\n\n        let accumulatedProps = Runtime.evaluateAllLayersFiltered(\n                                    keyframes,\n                                    keyframeInfo,\n                                    timeInSeconds,\n                                    (layer) => {\n                                        return !Runtime._isEventLayer(layer, keyframeInfo); // only care about non-event layers (DOF)\n                                    },\n                                    false,\n                                    overrides);\n\n        // Now that all props have been accumulated, pass them to\n        // the layer types generateDofs() function to get our final dof values\n        let dofs = {};\n\n        for(let layerType in accumulatedProps) {\n            let layerClass = keyframeInfo.layerTypes[layerType];\n            let generatedDofs = layerClass.generateDofs(accumulatedProps[layerType]);\n\n            // Copy These\n            // TODO: Eventually multiple types of layers will be generating dof values\n            // so blending operations will need to occur here as well.\n            for(let dofName in generatedDofs) {\n                dofs[dofName] = generatedDofs[dofName];\n            }\n        }\n\n        return dofs;\n    }\n\n    static evaluateAllLayersFiltered(keyframes, keyframeInfo, timeInSeconds, includeFilter, provideDefaults, overrides){\n        // This will hold each layers blended props as they accumulate\n        let accumulatedProps = {};\n\n        // Blend layers from top to bottom\n        for(let i = keyframes.layers.length-1; i>=0; i--) {\n\n            // Locked, invisible, or filtered layers don't have any affect on the final props/dofs\n            if( !includeFilter(keyframes.layers[i]) || !keyframes.layers[i].visible ){\n                continue;\n            }\n\n            let override = overrides === undefined ? undefined: overrides[keyframes.layers[i].id],\n                props = Runtime.evaluateLayer(keyframes.layers[i], keyframes, keyframeInfo, timeInSeconds, override );\n\n            // Is this the first instance of a particular layer type\n                // If so initialize the accumulated props to this layer's computed values\n            if( typeof accumulatedProps[keyframes.layers[i].type] === \"undefined\"){\n                accumulatedProps[keyframes.layers[i].type] = props;\n            }\n                // If more than one layer exists, the values of layers are blended\n                // according to blend operation of each layer's property types\n            else {\n                let layerProps = accumulatedProps[keyframes.layers[i].type],\n                    layerInfo = keyframeInfo.layerTypes[keyframes.layers[i].type].getInfo();\n\n                // Blend each property based on it's type/blendOperation\n                for(let propName in props){\n                    let propInfo = layerInfo.properties[propName];\n\n                    try{\n                        layerProps[propName] = BlendOperations.normal(propInfo.blendOperation, propInfo.type)(layerProps[propName], props[propName], propInfo.defaultValue);\n                    } catch(error){\n                        i = 0;\n                    }\n                }\n            }\n        }\n\n        // Make sure that each type of layer that exists, regardless of their visible or locked flags are\n        // included set to their default values if they weren't accumulated via some other pathway.\n        // NOTE: Only if hte provideDefaults flag was set of course\n        /*if(0){//provideDefaults){\n            for(let i = keyframes.layers.length-1; i>=0; i--) {\n                if( typeof accumulatedProps[keyframes.layers[i].id] === \"undefined\" ) {\n\n                    accumulatedProps[keyframes.layers[i].id] = {};\n\n                    let layerInfo = keyframeInfo.layerTypes[keyframes.layers[i].type].getInfo();\n\n                    for(let propName in layerInfo.properties){\n                        accumulatedProps[keyframes.layers[i].id][propName] = _.cloneDeep(layerInfo.properties[propName].defaultValue);\n                    }\n                }\n            }\n        }*/\n        return accumulatedProps;\n    }\n\n    /*\n    *   Used by the editor's animation model.\n    * */\n    static computeRelativePropValues(excludedLayer, keyframes, keyframeInfo, timeInSeconds, absoluteProps, overrides){\n        let props = Runtime.evaluateAllLayersFiltered(keyframes, keyframeInfo, timeInSeconds, (layer) => {\n            if(layer.type !== excludedLayer.type || layer.id === excludedLayer.id){\n                return false;\n            } else {\n                return true;\n            }\n        }, true, overrides);\n\n        // Return absolute props as is if there were no other layers of it's type\n        if( typeof props[excludedLayer.type] === \"undefined\"){\n            return absoluteProps;\n        }\n\n        let layerInfo = keyframeInfo.layerTypes[excludedLayer.type].getInfo(),\n            relativeProps = {};\n        for(let propName in absoluteProps){\n            let propInfo = layerInfo.properties[propName];\n\n            relativeProps[propName] = BlendOperations.inverse(propInfo.blendOperation, propInfo.type)(props[excludedLayer.type][propName], absoluteProps[propName], propInfo.defaultValue);\n        }\n\n        return relativeProps;\n    }\n\n    /**\n     * Get the property values generated from a single layer at a point in time\n     *\n     * @param layer {Object} The layer that we need to evaluate\n     * @param keyframes {Object} Keyframes data that this layer is a part of\n     * @param keyframeInfo {Object} Meta data that includes supported layer types,\n     *                              default values, and etc\n     * @param timeInSeconds {number} The time to compute the properties values at\n     * @param override {Object}  If provided this object includes a set of properties\n     *                           to override the usually calculated keyframed properties.\n     *                           This is useful in tools for interactively changing\n     *                           the properties of a layer at a point in time without\n     *                           committing a new keyframe as a user tries out different jibo poses\n     * @return {Object} An object who's fields are each dof and it's value after all\n     *                  interpolation and layer blending\n     */\n    static evaluateLayer(layer, keyframes, keyframeInfo, timeInSeconds, override){\n\n        if (Runtime._isEventLayer(layer, keyframeInfo)) {\n            // do not interpolate for event types\n            return Runtime._evaluateEventLayer(layer, keyframes, keyframeInfo, timeInSeconds);\n        }\n\n        let props = {};\n\n        if(override) {\n            for(let propName in override) {\n                props[propName] = override[propName];\n            }\n            return props;\n        }\n\n        let layerTypeInfo = keyframeInfo.layerTypes[layer.type].getInfo();\n\n        // If there are no keyframes, return the defaults\n        if( layer.keyframes.length === 0 ){\n\n            for(let propName in layerTypeInfo.properties) {\n                props[propName] = _.cloneDeep(layerTypeInfo.properties[propName].defaultValue);\n            }\n        }\n        // There are keyframes, calculate the properties at the supplied time\n        else {\n            // Calculate the keyframe index this time is equivalent to.\n            // NOTE: We don't floor it, we just want to have a number in frame counts\n            // instead of in seconds so that we can compare times and interpolate between\n            // times\n            if(keyframes.scale === undefined) {\n                keyframes.scale = keyframeInfo.defaults.scale;\n            }\n            let keyframeTime = timeInSeconds * keyframes.framerate;\n            // Return the first keyframe's values if the time is before or equal\n            // to the first keyframes or if there is only one keyframe\n            if( layer.keyframes.length === 1 ||\n                layer.keyframes[0].time >= keyframeTime ) {\n                return _.cloneDeep(layer.keyframes[0].value);\n            }\n            // Is the current time past the time of the last keyframe? If so grab that\n            // keyframe's value\n            else if( layer.keyframes[layer.keyframes.length-1].time <= keyframeTime ) {\n                return _.cloneDeep(layer.keyframes[layer.keyframes.length-1].value);\n            }\n            // The current time is between keyframes, interpolate between them\n            else {\n                // Scan from the last to first keyframe, stop on the first keyframe\n                // further back in time than us\n                let {start, end} = Search.keyframeSearch(layer.keyframes, keyframeTime);\n                start = layer.keyframes[start];\n                end = layer.keyframes[end];\n                // Now that we have our two closest keyframes, interpolate their values\n                let timeStart = start.time,\n                    timeEnd = end.time,\n                    timeNormalized = (keyframeTime - timeStart) / (timeEnd - timeStart);\n\n                let easingFunction = 'cubicInOut';\n                if(start.value.Tween) {\n                    easingFunction = start.value.Tween.value;\n                }\n\n                //if(layer.type === 'Body') {\n                //    debugger;\n                //    easingFunction = 'body';\n                //}\n\n                for(let propName in start.value) {\n                    if(typeof layerTypeInfo.properties[propName].type === 'string') {\n                        props[propName] = Tweening[layerTypeInfo.properties[propName].type](\n                            start.value[propName],\n                            end.value[propName],\n                            timeNormalized,\n                            easingFunction\n                        );\n                    }\n                    else {\n                        props[propName] = Tweening[layerTypeInfo.properties[propName].type.name](\n                            start.value[propName],\n                            end.value[propName],\n                            timeNormalized,\n                            easingFunction\n                        );\n                    }\n\n                }\n            }\n        }\n        return props;\n    }\n\n    static _evaluateEventLayer(layer, keyframes, keyframeInfo, timeInSeconds) {\n        let keyframeTime = timeInSeconds*keyframes.framerate;\n\n        // if we have a keyframe at the given keyframeTime, then return it;\n        // otherwise, return the default values\n        let frame = Search.keyframeSearchAbsolute(layer.keyframes, keyframeTime);\n        if (frame !== undefined) {\n            return _.cloneDeep(layer.keyframes[frame].value);\n        }\n\n        let layerTypeInfo = keyframeInfo.layerTypes[layer.type].getInfo();\n        let props = {};\n        for(let propName in layerTypeInfo.properties) {\n            props[propName] = _.cloneDeep(layerTypeInfo.properties[propName].defaultValue);\n        }\n\n        return props;\n    }\n\n    /**\n     * Get the event values (payloads) generated from all the event layers at a point in time\n     * @param keyframes {Object} Keyframes data we'll be evaluating the layers of\n     * @param keyframeInfo {Object} Meta data that includes supported layer types,\n     *                              default values, and etc\n     * @param timeInSeconds {number} The time to check\n     *\n     * @return {array} An array of all accumulated event layers and their payloads.\n     */\n    static evaluateAllEventLayers(keyframes, keyframeInfo, timeInSeconds) {\n\n        let events = [];\n\n        // Find all our event layers\n        let layersLen = keyframes.layers.length;\n        for(let i = 0; i < layersLen; i++) {\n\n            let layer = keyframes.layers[i];\n\n            // if not visible or not an event layer, move along\n            if (!Runtime._isEventLayer(layer, keyframeInfo) || !layer.visible) {\n                continue;\n            }\n\n            let props = Runtime.evaluateLayer(layer, keyframes, keyframeInfo, timeInSeconds);\n\n            if (props) {\n                let layerClass = keyframeInfo.layerTypes[layer.type];\n                let generatedEvent = layerClass.generateEvent(props, i);\n                let eventType = (typeof generatedEvent);\n\n                if ((eventType === 'object') && (layerClass.isValid(generatedEvent))) {\n                    // check if we returned an object and make sure it has stuff in it\n                    //if (Object.keys(generatedEvent).length !== 0) {\n                        events.push(generatedEvent);\n                    //}\n                }\n                //else if (payloadType === 'string') {\n                //\n                //    // only push string if there is something in it\n                //    if (generatedEvent.length > 0) {\n                //        events.push(generatedEvent);\n                //    }\n                //}\n                //else {\n                //    // push it anyways? see what breaks!\n                //    events.push(generatedEvent);\n                //}\n            }\n        }\n        return events;\n    }\n}"],"sourceRoot":"/source/"}