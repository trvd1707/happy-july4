"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Operations per property type for blending layers of properties together
 */

var operations = {
    lastOneWins: {
        texture: function texture(accumulated, newValue) {
            return newValue;
        },
        bool: function bool(accumulated, newValue) {
            return newValue;
        }
    },

    add: {
        float: function float(accumulated, newValue, defaultValue) {
            return accumulated + (newValue - defaultValue);
        },
        vector2: function vector2(accumulated, newValue, defaultValue) {
            return {
                x: accumulated.x + (newValue.x - defaultValue.x),
                y: accumulated.y + (newValue.y - defaultValue.y)
            };
        },
        rgb: function rgb(accumulated, newValue, defaultValue) {
            return {
                r: accumulated.h + (newValue.r - defaultValue.r),
                g: accumulated.s + (newValue.g - defaultValue.g),
                b: accumulated.v + (newValue.b - defaultValue.b)
            };
        }
    },
    multiply: {
        float: function float(accumulated, newValue) {
            return accumulated * newValue;
        },
        vector2: function vector2(accumulated, newValue) {
            return {
                x: accumulated.x * newValue.x,
                y: accumulated.y * newValue.y
            };
        },
        rgb: function rgb(accumulated, newValue) {
            return {
                r: accumulated.r * newValue.r,
                g: accumulated.g * newValue.g,
                b: accumulated.b * newValue.b
            };
        }
    },
    singleton: {
        video: function video(accumulated, newValue) {
            return newValue;
        }
    },
    inverse: {
        lastOneWins: {
            texture: function texture(accumulated) {
                return accumulated;
            },
            bool: function bool(accumulated) {
                return accumulated;
            }
        },
        singleton: {
            video: function video(accumulated) {
                return accumulated;
            }
        },
        add: {
            float: function float(accumulated, newValue, defaultValue) {
                return newValue + defaultValue - accumulated;
            },
            vector2: function vector2(accumulated, newValue, defaultValue) {
                return {
                    x: newValue.x + defaultValue.x - accumulated.x,
                    y: newValue.y + defaultValue.y - accumulated.y
                };
            },
            rgb: function rgb(accumulated, newValue, defaultValue) {
                return {
                    r: newValue.r + defaultValue.r - accumulated.r,
                    g: newValue.g + defaultValue.g - accumulated.g,
                    b: newValue.b + defaultValue.b - accumulated.b
                };
            }
        },
        multiply: {
            float: function float(accumulated, newValue) {
                return accumulated / newValue;
            },
            vector2: function vector2(accumulated, newValue) {
                return {
                    x: newValue.x / accumulated.x,
                    y: newValue.y / accumulated.y
                };
            },
            rgb: function rgb(accumulated, newValue) {
                return {
                    r: newValue.h / accumulated.r,
                    g: newValue.s / accumulated.g,
                    b: newValue.v / accumulated.b
                };
            }
        }
    }
};

var BlendOperations = function () {
    function BlendOperations() {
        _classCallCheck(this, BlendOperations);
    }

    _createClass(BlendOperations, null, [{
        key: "inverse",
        value: function inverse(operation, type) {
            return operations.inverse[operation][type];
        }
    }, {
        key: "normal",
        value: function normal(operation, type) {
            return operations[operation][type];
        }
    }]);

    return BlendOperations;
}();

exports.default = BlendOperations;
//# sourceMappingURL=../map/utils/BlendOperations.js.map
