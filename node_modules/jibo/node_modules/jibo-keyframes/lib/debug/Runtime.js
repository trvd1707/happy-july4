"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Class responsible for
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   - saving and loading files
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   - manipulating the animation and notifying views of changes
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   - computing the values of animation at any given point in time
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _Tweening = require("./utils/Tweening");

var _Tweening2 = _interopRequireDefault(_Tweening);

var _IDUtils = require("./utils/IDUtils");

var _IDUtils2 = _interopRequireDefault(_IDUtils);

var _Search = require("./utils/Search");

var _Search2 = _interopRequireDefault(_Search);

var _BlendOperations = require("./utils/BlendOperations");

var _BlendOperations2 = _interopRequireDefault(_BlendOperations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Runtime = function () {
    function Runtime() {
        _classCallCheck(this, Runtime);
    }

    _createClass(Runtime, null, [{
        key: "create",


        /**
         * Create a new keyframes object.
         *
         * @param keyframeInfo {Object} Meta data that includes supported layer types,
         *                              default values, and etc
         * @returns {Object} The newly created keyframes object with default layers created
         *
         */
        value: function create(keyframeInfo) {
            var keyframes = {
                version: keyframeInfo.defaults.version,
                framerate: keyframeInfo.defaults.framerate,
                duration: keyframeInfo.defaults.duration,
                scale: keyframeInfo.defaults.scale,
                layers: []
            };

            keyframeInfo.defaults.layers.forEach(function (defaultLayer) {
                keyframes.layers.push({
                    id: _IDUtils2.default.create(),
                    name: defaultLayer.name,
                    type: defaultLayer.type,
                    visible: true,
                    locked: false,
                    keyframes: []
                });
            });

            return keyframes;
        }

        /**
         * Load an animation file into this instance
         *
         * @param uri {String} Filepath to load the keyframes file from
         * @param keyframeInfo {Object} Meta data that includes supported layer types,
         *                              default values, and etc
         * @returns {Object} Keyframes file content
         *
         * TODO: Write validation code at some point to catch issues like a file that merged incorrectly,
         * was corrupted, or is just the wrong file format/type. Ensure invariants such as:
         *   - That keys are time ordered
         *   - That key values are valid
         *   - That all required fields exist and no extra ones do
         */

    }, {
        key: "load",
        value: function load(uri, keyframeInfo) {
            var keyframes = JSON.parse(_fs2.default.readFileSync(uri, 'utf8'));

            if (keyframeInfo.onLoad) {
                keyframeInfo.onLoad(keyframes);
            }

            return keyframes;
        }

        /**
         * Save the keyframes to disk
         *
         * @param uri {String} Filepath to save to
         * @param keyframes {Object} Keyframe object to serialize to disk
         */

    }, {
        key: "save",
        value: function save(uri, keyframes) {
            // Save the current animation state to disk with four spaces for indentation
            _fs2.default.writeFileSync(uri, JSON.stringify(keyframes, null, '    '), 'utf8');
        }
    }, {
        key: "_isEventLayer",
        value: function _isEventLayer(layer, keyframeInfo) {
            if (layer) {
                var layerClass = keyframeInfo.layerTypes[layer.type];
                return layerClass.isEvent();
            }

            return false;
        }

        /**
         * Get the dof values generated from all the DOF layers at a point in time
         * @param keyframes {Object} Keyframes data we'll be evaluating the layers of
         * @param keyframeInfo {Object} Meta data that includes supported layer types,
         *                              default values, and etc
         * @param timeInSeconds {number} The time to compute the final dof values at
         * @param overrides {Object} If provided each field in this object includes a set of properties
         *                           to override the usually calculated interpolated keyframed properties.
         *                           This is useful in tools for interactively changing
         *                           the properties of a layer at a point in time without
         *                           committing a new keyframe as a user tries out different jibo poses
         * @return {Object} An object who's fields are each dof and it's value after all
         *                  interpolation and layer blending
         */

    }, {
        key: "evaluateAllDOFLayers",
        value: function evaluateAllDOFLayers(keyframes, keyframeInfo, timeInSeconds, overrides) {

            var accumulatedProps = Runtime.evaluateAllLayersFiltered(keyframes, keyframeInfo, timeInSeconds, function (layer) {
                return !Runtime._isEventLayer(layer, keyframeInfo); // only care about non-event layers (DOF)
            }, false, overrides);

            // Now that all props have been accumulated, pass them to
            // the layer types generateDofs() function to get our final dof values
            var dofs = {};

            for (var layerType in accumulatedProps) {
                var layerClass = keyframeInfo.layerTypes[layerType];
                var generatedDofs = layerClass.generateDofs(accumulatedProps[layerType]);

                // Copy These
                // TODO: Eventually multiple types of layers will be generating dof values
                // so blending operations will need to occur here as well.
                for (var dofName in generatedDofs) {
                    dofs[dofName] = generatedDofs[dofName];
                }
            }

            return dofs;
        }
    }, {
        key: "evaluateAllLayersFiltered",
        value: function evaluateAllLayersFiltered(keyframes, keyframeInfo, timeInSeconds, includeFilter, provideDefaults, overrides) {
            // This will hold each layers blended props as they accumulate
            var accumulatedProps = {};

            // Blend layers from top to bottom
            for (var i = keyframes.layers.length - 1; i >= 0; i--) {

                // Locked, invisible, or filtered layers don't have any affect on the final props/dofs
                if (!includeFilter(keyframes.layers[i]) || !keyframes.layers[i].visible) {
                    continue;
                }

                var override = overrides === undefined ? undefined : overrides[keyframes.layers[i].id],
                    props = Runtime.evaluateLayer(keyframes.layers[i], keyframes, keyframeInfo, timeInSeconds, override);

                // Is this the first instance of a particular layer type
                // If so initialize the accumulated props to this layer's computed values
                if (typeof accumulatedProps[keyframes.layers[i].type] === "undefined") {
                    accumulatedProps[keyframes.layers[i].type] = props;
                }
                // If more than one layer exists, the values of layers are blended
                // according to blend operation of each layer's property types
                else {
                        var layerProps = accumulatedProps[keyframes.layers[i].type],
                            layerInfo = keyframeInfo.layerTypes[keyframes.layers[i].type].getInfo();

                        // Blend each property based on it's type/blendOperation
                        for (var propName in props) {
                            var propInfo = layerInfo.properties[propName];

                            try {
                                layerProps[propName] = _BlendOperations2.default.normal(propInfo.blendOperation, propInfo.type)(layerProps[propName], props[propName], propInfo.defaultValue);
                            } catch (error) {
                                i = 0;
                            }
                        }
                    }
            }

            // Make sure that each type of layer that exists, regardless of their visible or locked flags are
            // included set to their default values if they weren't accumulated via some other pathway.
            // NOTE: Only if hte provideDefaults flag was set of course
            /*if(0){//provideDefaults){
                for(let i = keyframes.layers.length-1; i>=0; i--) {
                    if( typeof accumulatedProps[keyframes.layers[i].id] === "undefined" ) {
                         accumulatedProps[keyframes.layers[i].id] = {};
                         let layerInfo = keyframeInfo.layerTypes[keyframes.layers[i].type].getInfo();
                         for(let propName in layerInfo.properties){
                            accumulatedProps[keyframes.layers[i].id][propName] = _.cloneDeep(layerInfo.properties[propName].defaultValue);
                        }
                    }
                }
            }*/
            return accumulatedProps;
        }

        /*
        *   Used by the editor's animation model.
        * */

    }, {
        key: "computeRelativePropValues",
        value: function computeRelativePropValues(excludedLayer, keyframes, keyframeInfo, timeInSeconds, absoluteProps, overrides) {
            var props = Runtime.evaluateAllLayersFiltered(keyframes, keyframeInfo, timeInSeconds, function (layer) {
                if (layer.type !== excludedLayer.type || layer.id === excludedLayer.id) {
                    return false;
                } else {
                    return true;
                }
            }, true, overrides);

            // Return absolute props as is if there were no other layers of it's type
            if (typeof props[excludedLayer.type] === "undefined") {
                return absoluteProps;
            }

            var layerInfo = keyframeInfo.layerTypes[excludedLayer.type].getInfo(),
                relativeProps = {};
            for (var propName in absoluteProps) {
                var propInfo = layerInfo.properties[propName];

                relativeProps[propName] = _BlendOperations2.default.inverse(propInfo.blendOperation, propInfo.type)(props[excludedLayer.type][propName], absoluteProps[propName], propInfo.defaultValue);
            }

            return relativeProps;
        }

        /**
         * Get the property values generated from a single layer at a point in time
         *
         * @param layer {Object} The layer that we need to evaluate
         * @param keyframes {Object} Keyframes data that this layer is a part of
         * @param keyframeInfo {Object} Meta data that includes supported layer types,
         *                              default values, and etc
         * @param timeInSeconds {number} The time to compute the properties values at
         * @param override {Object}  If provided this object includes a set of properties
         *                           to override the usually calculated keyframed properties.
         *                           This is useful in tools for interactively changing
         *                           the properties of a layer at a point in time without
         *                           committing a new keyframe as a user tries out different jibo poses
         * @return {Object} An object who's fields are each dof and it's value after all
         *                  interpolation and layer blending
         */

    }, {
        key: "evaluateLayer",
        value: function evaluateLayer(layer, keyframes, keyframeInfo, timeInSeconds, override) {

            if (Runtime._isEventLayer(layer, keyframeInfo)) {
                // do not interpolate for event types
                return Runtime._evaluateEventLayer(layer, keyframes, keyframeInfo, timeInSeconds);
            }

            var props = {};

            if (override) {
                for (var propName in override) {
                    props[propName] = override[propName];
                }
                return props;
            }

            var layerTypeInfo = keyframeInfo.layerTypes[layer.type].getInfo();

            // If there are no keyframes, return the defaults
            if (layer.keyframes.length === 0) {

                for (var _propName in layerTypeInfo.properties) {
                    props[_propName] = _lodash2.default.cloneDeep(layerTypeInfo.properties[_propName].defaultValue);
                }
            }
            // There are keyframes, calculate the properties at the supplied time
            else {
                    // Calculate the keyframe index this time is equivalent to.
                    // NOTE: We don't floor it, we just want to have a number in frame counts
                    // instead of in seconds so that we can compare times and interpolate between
                    // times
                    if (keyframes.scale === undefined) {
                        keyframes.scale = keyframeInfo.defaults.scale;
                    }
                    var keyframeTime = timeInSeconds * keyframes.framerate;
                    // Return the first keyframe's values if the time is before or equal
                    // to the first keyframes or if there is only one keyframe
                    if (layer.keyframes.length === 1 || layer.keyframes[0].time >= keyframeTime) {
                        return _lodash2.default.cloneDeep(layer.keyframes[0].value);
                    }
                    // Is the current time past the time of the last keyframe? If so grab that
                    // keyframe's value
                    else if (layer.keyframes[layer.keyframes.length - 1].time <= keyframeTime) {
                            return _lodash2.default.cloneDeep(layer.keyframes[layer.keyframes.length - 1].value);
                        }
                        // The current time is between keyframes, interpolate between them
                        else {
                                // Scan from the last to first keyframe, stop on the first keyframe
                                // further back in time than us

                                var _Search$keyframeSearc = _Search2.default.keyframeSearch(layer.keyframes, keyframeTime);

                                var start = _Search$keyframeSearc.start;
                                var end = _Search$keyframeSearc.end;

                                start = layer.keyframes[start];
                                end = layer.keyframes[end];
                                // Now that we have our two closest keyframes, interpolate their values
                                var timeStart = start.time,
                                    timeEnd = end.time,
                                    timeNormalized = (keyframeTime - timeStart) / (timeEnd - timeStart);

                                var easingFunction = 'cubicInOut';
                                if (start.value.Tween) {
                                    easingFunction = start.value.Tween.value;
                                }

                                //if(layer.type === 'Body') {
                                //    debugger;
                                //    easingFunction = 'body';
                                //}

                                for (var _propName2 in start.value) {
                                    if (typeof layerTypeInfo.properties[_propName2].type === 'string') {
                                        props[_propName2] = _Tweening2.default[layerTypeInfo.properties[_propName2].type](start.value[_propName2], end.value[_propName2], timeNormalized, easingFunction);
                                    } else {
                                        props[_propName2] = _Tweening2.default[layerTypeInfo.properties[_propName2].type.name](start.value[_propName2], end.value[_propName2], timeNormalized, easingFunction);
                                    }
                                }
                            }
                }
            return props;
        }
    }, {
        key: "_evaluateEventLayer",
        value: function _evaluateEventLayer(layer, keyframes, keyframeInfo, timeInSeconds) {
            var keyframeTime = timeInSeconds * keyframes.framerate;

            // if we have a keyframe at the given keyframeTime, then return it;
            // otherwise, return the default values
            var frame = _Search2.default.keyframeSearchAbsolute(layer.keyframes, keyframeTime);
            if (frame !== undefined) {
                return _lodash2.default.cloneDeep(layer.keyframes[frame].value);
            }

            var layerTypeInfo = keyframeInfo.layerTypes[layer.type].getInfo();
            var props = {};
            for (var propName in layerTypeInfo.properties) {
                props[propName] = _lodash2.default.cloneDeep(layerTypeInfo.properties[propName].defaultValue);
            }

            return props;
        }

        /**
         * Get the event values (payloads) generated from all the event layers at a point in time
         * @param keyframes {Object} Keyframes data we'll be evaluating the layers of
         * @param keyframeInfo {Object} Meta data that includes supported layer types,
         *                              default values, and etc
         * @param timeInSeconds {number} The time to check
         *
         * @return {array} An array of all accumulated event layers and their payloads.
         */

    }, {
        key: "evaluateAllEventLayers",
        value: function evaluateAllEventLayers(keyframes, keyframeInfo, timeInSeconds) {

            var events = [];

            // Find all our event layers
            var layersLen = keyframes.layers.length;
            for (var i = 0; i < layersLen; i++) {

                var layer = keyframes.layers[i];

                // if not visible or not an event layer, move along
                if (!Runtime._isEventLayer(layer, keyframeInfo) || !layer.visible) {
                    continue;
                }

                var props = Runtime.evaluateLayer(layer, keyframes, keyframeInfo, timeInSeconds);

                if (props) {
                    var layerClass = keyframeInfo.layerTypes[layer.type];
                    var generatedEvent = layerClass.generateEvent(props, i);
                    var eventType = typeof generatedEvent === "undefined" ? "undefined" : _typeof(generatedEvent);

                    if (eventType === 'object' && layerClass.isValid(generatedEvent)) {
                        // check if we returned an object and make sure it has stuff in it
                        //if (Object.keys(generatedEvent).length !== 0) {
                        events.push(generatedEvent);
                        //}
                    }
                    //else if (payloadType === 'string') {
                    //
                    //    // only push string if there is something in it
                    //    if (generatedEvent.length > 0) {
                    //        events.push(generatedEvent);
                    //    }
                    //}
                    //else {
                    //    // push it anyways? see what breaks!
                    //    events.push(generatedEvent);
                    //}
                }
            }
            return events;
        }
    }]);

    return Runtime;
}();

exports.default = Runtime;
//# sourceMappingURL=map/Runtime.js.map
