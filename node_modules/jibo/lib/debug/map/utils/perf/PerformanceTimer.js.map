{"version":3,"sources":["utils/perf/PerformanceTimer.js"],"names":[],"mappings":"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","file":"utils/perf/PerformanceTimer.js","sourcesContent":["/*\n * Basic timer timing functions.\n */\nconst assert = require('assert');\n\n/*\n * Fallback to using Date.now if performance object doesn't exist. This makes it easier\n * to test this module in pure node which doesn't have the performance API.\n */\nconst TimerTypes = {\n    SERIAL: \"SERIAL\",\n    PARALLEL: \"PARALLEL\"\n};\n\n/**\n * Base Timer for measuring performance.\n * @class PerformanceTimer\n * @memberof module:jibo/utils/perf\n * @private\n */\nclass PerformanceTimer {\n    constructor(name, type, parent){\n        this.name = name;\n        this.type = type;\n        this.parent = parent;\n        this.start = this.now();\n        this.children = [];\n\n        // Add our selves to the parent if one was provided\n        if( this.parent ){\n            this.parent.children.push(this);\n        }\n    }\n\n    static get TimerTypes() {\n        return TimerTypes;\n    }\n\n    stop(){\n        assert( !this.end, \"PerformanceTimer.stop() was called twice.\");\n        this.end = this.now();\n    }\n\n    getTimings(){\n        assert(this !== null, \"PerformanceTimer.printTimings() called without there being any timing data\");\n\n        // Defer string build up to recursive private function\n        return _getTimings(this, \"\");\n    }\n\n    /*\n     * Get a reference to the performance timer API or it's fallback. We do this\n     * this dynamically to make it easier to mockup the timer in the matching tests\n     * for this module which uses sinon for mocks, which doesn't have support for replacing\n     * the performance.* APIs, but does for the Date.now() function. The performance API\n     * doesn't exist in pure node, so we have to replace performance.now with Date.now anyway.\n     */\n    now(){\n        return typeof performance !== 'undefined' ?\n            performance.now(): Date.now();\n    }\n}\n\nfunction _getTimings(parentTimer, indentLevel){\n    // To help know which type a timer is we mark them as following:\n        // SerialTimer      = \"-\"\n        // ParallelTimer    = \"~\"\n        // TopLevelTimer    = \" \"\n    let timerTypeSymbol = '-';\n    if( !parentTimer.parent ){\n        timerTypeSymbol = \" \";\n    }\n    else if( parentTimer.parent.type === TimerTypes.PARALLEL ){\n        timerTypeSymbol = \"~\";\n    }\n\n    let output = \"\";\n    output += `${ indentLevel }${timerTypeSymbol} \"${ parentTimer.name }\" ${( parentTimer.end-parentTimer.start ).toFixed(1) }ms\\n`;\n\n    // Sort the children of parallel timers by their duration to make it easier\n    // to see the worst offenders that causes the overall completion time.\n    // We don't do the same for serial timers as their ordering is meaningful\n    if( parentTimer.type === TimerTypes.PARALLEL ) {\n        parentTimer.children.sort( (a, b) => {\n            return (a.end - a.start) < (b.end - b.start);\n        });\n    }\n\n    parentTimer.children.forEach( (childTimer) => {\n        output += _getTimings(childTimer, indentLevel + \"\\t\");\n    });\n    return output;\n}\n\nexport default PerformanceTimer;\n"],"sourceRoot":"/source/"}