{"version":3,"sources":["utils/DelayedCall.ts"],"names":[],"mappings":"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","file":"utils/DelayedCall.js","sourcesContent":["import Timer from './Timer';\n\ndeclare type UpdateCallback = (elapsed:number) => void;\nexport declare type CompleteCallback = (call:DelayedCall) => void;\n\n/**\n * A class for delaying a call through the application, instead of relying on setInterval() or\n * setTimeout().\n *\n * @class DelayedCall\n * @memberof module:jibo/timer\n * @constructor\n * @param {function} callback The function to call when the delay has completed.\n * @param {int} delay The time to delay the call, in milliseconds (or optionally frames).\n * @param {Object|Boolean} [options=false] The options to use or repeat value.\n * @param {Boolean} [options.repeat=false] `true` if the DelayedCall should automatically repeat itself when\n *                              completed.\n * @param {Boolean} [options.autoDestroy=true] `true` if the DelayedCall should clean itself up when completed.\n * @param {Boolean} [options.useFrames=false] `true` if the DelayedCall should use frames instead of\n *                                 milliseconds for the delay.\n */\nclass DelayedCall {\n\n    public parent:Timer;\n    private _callback:CompleteCallback;\n    private _delay:number;\n    private _timer:number;\n    private _repeat:boolean;\n    private _autoDestroy:boolean;\n    private _useFrames:boolean;\n    private _paused:boolean;\n    private _update:UpdateCallback;\n    private _enabled:boolean;\n\n    constructor(parent:Timer, callback: CompleteCallback, delay: number, options: any) {\n\n        // Set the default options\n        options = Object.assign({\n            repeat: false,\n            autoDestroy: true,\n            useFrames: false\n        }, options || {});\n\n        /**\n         * The root timer.\n         * @private\n         * @type {Timer}\n         * @name module:jibo/timer.DelayedCall#parent\n         */\n        this.parent = parent;\n\n        /**\n         * The function to call when the delay is completed.\n         * @private\n         * @type {function}\n         * @name module:jibo/timer.DelayedCall#_callback\n         */\n        this._callback = callback;\n\n        /**\n         * The delay time, in milliseconds.\n         * @private\n         * @type {int}\n         * @name module:jibo/timer.DelayedCall#_delay\n         */\n        this._delay = delay;\n\n        /**\n         * The timer counting down from _delay, in milliseconds.\n         * @private\n         * @type {int}\n         * @name module:jibo/timer.DelayedCall#_timer\n         */\n        this._timer = delay;\n\n        /**\n         * `true` if the DelayedCall should repeat itself automatically.\n         * @private\n         * @type {Boolean}\n         * @name module:jibo/timer.DelayedCall#_repeat\n         * @default false\n         */\n        this._repeat = !!options.repeat;\n\n        /**\n         * `true` if the DelayedCall should destroy itself after completing\n         * @private\n         * @type {Boolean}\n         * @name module:jibo/timer.DelayedCall#_autoDestroy\n         * @default true\n         */\n        this._autoDestroy = !!options.autoDestroy;\n\n        /**\n         * `true` if the DelayedCall should use frames instead of milliseconds for the delay.\n         * @private\n         * @type {Boolean}\n         * @name module:jibo/timer.DelayedCall#_useFrames\n         * @default false\n         */\n        this._useFrames = !!options.useFrames;\n\n        /**\n         * `true` if the DelayedCall is currently paused (not stopped).\n         * @private\n         * @type {Boolean}\n         * @name module:jibo/timer.DelayedCall#_paused\n         */\n        this._paused = false;\n\n        //save a bound version of the update function\n        this._update = this.update.bind(this);\n\n        //start the delay\n        this.enabled = true;\n    }\n\n    /**\n     * The callback supplied to the Application for an update each frame.\n     * @private\n     * @method module:jibo/timer.DelayedCall#update\n     * @param {int} elapsed The time elapsed since the previous frame.\n     */\n    update(elapsed) {\n        if (!this._callback) {\n            this.destroy();\n            return;\n        }\n        this._timer -= this._useFrames ? 1 : elapsed;\n        if (this._timer <= 0) {\n            this._callback(this);\n            if (this._repeat) {\n                this._timer += this._delay;\n            }\n            else if (this._autoDestroy) {\n                this.destroy();\n            }\n            else {\n                this.enabled = false;\n            }\n        }\n    };\n\n    /**\n     * Restarts the DelayedCall, whether it is running or not.\n     * @method module:jibo/timer.DelayedCall#restart\n     */\n    restart() {\n        if (!this._callback)\n        {\n            return;\n        }\n        if (!this.enabled) {\n            this.enabled = true;\n        }\n        this._timer = this._delay;\n        this._paused = false;\n    }\n\n    /**\n     * Stops the DelayedCall, without destroying it.\n     * @method module:jibo/timer.DelayedCall#stop\n     */\n    stop() {\n        this.enabled = false;\n        this._paused = false;\n    }\n\n    /**\n     * `true` if enabled for updates, `false` otherwise.\n     * @private\n     * @type {Boolean}\n     * @name module:jibo/timer.DelayedCall#enabled\n     */\n    set enabled(value:boolean){\n        this._enabled = value;\n        this.parent.removeListener('update', this._update);\n        if (value) {\n            this.parent.on('update', this._update);\n        }\n    }\n    get enabled():boolean {\n        return this._enabled;\n    }\n\n    /**\n     * `true` if the DelayedCall is paused, `false` otherwise.\n     * @type {Boolean}\n     * @name module:jibo/timer.DelayedCall#paused\n     */\n    get paused():boolean {\n        return this._paused;\n    }\n    set paused(value:boolean) {\n        if (!this._callback)\n        {\n            return;\n        }\n        if (this._paused && !value) {\n            this._paused = false;\n            if (!this.enabled) {\n                this.enabled = true;\n            }\n        }\n        else if (value) {\n            if (this.enabled) {\n                this._paused = true;\n                this.enabled = false;\n            }\n        }\n    }\n\n    /**\n     * Stops and cleans up the DelayedCall. Do not use it after calling.\n     * destroy().\n     * @method module:jibo/timer.DelayedCall#destroy\n     */\n    destroy() {\n        this.stop();\n        this._callback = null;\n    };\n}\n\nexport default DelayedCall;\n"],"sourceRoot":"/source/"}