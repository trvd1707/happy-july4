"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var events_1 = require('events');
var path = require("path");
var semver = require("semver");
var PathUtils_1 = require("../utils/PathUtils");
/**
 * The various event types that system manager's notification system emits.
 * @alias module:jibo/systemManager~NotificationEvents
 * @enum {String}
 */
var NotificationEvents = {
    SHUTDOWN: 'shutdown'
};
/**
 * @class SystemManager
 * @memberof module:jibo.services
 * @private
 */
var SystemManager = (function (_super) {
    __extends(SystemManager, _super);
    function SystemManager() {
        _super.call(this);
        this.notifications = {
            type: "",
            channel: "",
            ts: [0, 0],
            data: {} // type-specific notification data
        };
        // Provide external access to these enums
        this.NotificationEvents = NotificationEvents;
    }
    Object.defineProperty(SystemManager, "NotificationEvents", {
        get: function () {
            return NotificationEvents;
        },
        enumerable: true,
        configurable: true
    });
    SystemManager.prototype.init = function (service, cb) {
        var _this = this;
        this.httpInterface = "http://" + service.host + ":" + service.port;
        this.socketUrl = "ws:" + service.host + ":" + service.port;
        this.loggingEnabled = false;
        this.getVersion(function (error, currentVersion) {
            if (error) {
                // couldn't retrieve version? hmm...
                cb(error);
                return;
            }
            // Use semver version check
            var dir = PathUtils_1.default.findRoot(__dirname);
            var jiboVersion = require(path.resolve(dir, 'package.json')).platform;
            if (!semver.satisfies(currentVersion, jiboVersion)) {
                var errorMsg = "Platform version check failed! Skill allows version " + jiboVersion + " but your current version is " + currentVersion + ".";
                cb(errorMsg);
            }
            else {
                // create out notification socket
                _this._createNotificationSocket(cb);
            }
        });
    };
    SystemManager.prototype.setLogging = function (logging) {
        this.loggingEnabled = logging;
    };
    SystemManager.prototype._createNotificationSocket = function (cb) {
        var _this = this;
        this.NotificationSocket = new WebSocket(this.socketUrl + "/system_notifications");
        this.NotificationSocket.onerror = function () {
            console.error("Error opening system notifications socket at " + _this.socketUrl + "/system_notifications");
        };
        this.NotificationSocket.onmessage = function (event) {
            try {
                _this.notifications = JSON.parse(event.data);
                // @TODO - check for shutdown type here
                _this.emit(NotificationEvents.SHUTDOWN, _this.notifications);
            }
            catch (e) {
                console.error('System notification event data is not JSON format.');
            }
        };
        cb();
    };
    /**
     * getVersion - Gets current version of platform build if connected to robot (raw numbers xx.xx.xx).
     * @function module:jibo/systemManager~getVersion
     *
     * @param {function} cb Callback that notifies the caller that the
     *                      version was retrieved; If successful, returns version; otherwise, error string.
     **/
    SystemManager.prototype.getVersion = function (callback) {
        this.getDisplayVersion(function (error, version) {
            // parse out number
            if (version) {
                var verMatch = version.trim().match('(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)');
                callback(null, verMatch[0]);
            }
            else {
                callback("Could not retrieve platform version from " + version, null);
            }
        });
    };
    /**
     * getDisplayVersion - Gets current display-friendly version of platform build if connected to robot.
     * @function module:jibo/systemManager~getDisplayVersion
     *
     * @param {function} cb Callback that notifies the caller that the
     *                      version was retrieved; If successful, returns version; otherwise, error string.
     **/
    SystemManager.prototype.getDisplayVersion = function (callback) {
        this._handleGET("/version", "version", callback);
    };
    // @TODO - document and mark @private
    SystemManager.prototype.getCredentials = function (callback) {
        this._handleGET("/credentials", undefined, callback);
    };
    // @TODO- document and mark @private
    SystemManager.prototype.setCredentials = function (creds, callback) {
        if (!creds) {
            callback("No credentials given");
            return;
        }
        var request = new XMLHttpRequest();
        var body = "";
        try {
            body = JSON.stringify(creds);
        }
        catch (e) {
            callback("Credentials are not valid JSON");
            return;
        }
        request.open("POST", this.httpInterface + "/credentials", true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 204) {
                    callback(); // success!
                }
                else {
                    // failure if anything else
                    var msg = 'System Manager is unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    callback(msg);
                }
            }
        };
        if (this.loggingEnabled) {
            console.log("credentials requested");
            console.log(body);
        }
        request.send(body);
    };
    // @TODO - document and mark @private
    SystemManager.prototype.getMode = function (callback) {
        this._handleGET("/mode", "mode", callback);
    };
    // @TODO- document and mark @private
    SystemManager.prototype.setMode = function (_mode, callback) {
        if (!_mode) {
            callback("No mode given");
            return;
        }
        var request = new XMLHttpRequest();
        var body = "";
        try {
            body = JSON.stringify({
                mode: _mode
            });
        }
        catch (e) {
            callback("Mode request is not valid JSON");
            return;
        }
        request.open("POST", this.httpInterface + "/mode", true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 204) {
                    callback(); // success!
                }
                else {
                    // failure if anything else
                    var msg = 'System Manager is unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    callback(msg);
                }
            }
        };
        if (this.loggingEnabled) {
            console.log("mode requested");
            console.log(body);
        }
        request.send(body);
    };
    /**
     * checkForUpdates - Returns a current list of available platform updates.
     * @function module:jibo/systemManager~checkForUpdates
     *
     * @param {function} cb Callback that notifies the caller of any updates; If successful,
     *                      returns the metadata associated with each update (if any exist); otherwise, error string.
     *
     * @private
     **/
    SystemManager.prototype.checkForUpdates = function (callback) {
        this._handleGET("/update", "updates", callback);
    };
    /**
     * @private
     **/
    SystemManager.prototype.downloadUpdates = function (data, callback) {
        if (!data || !data.hasOwnProperty('ids') || data.ids.length === 0) {
            callback('No IDs given.');
            return;
        }
        var request = new XMLHttpRequest();
        request.open("PUT", this.httpInterface + "/update", true); // true == async
        // the download callback will be a stream of update statuses (we may change this to websocket later)
        // so we have to keep track of the previous statuses that we want to parse out of the newer stream
        request.previousText = "";
        request.onreadystatechange = function () {
            if (request.readyState > 2) {
                if (request.status === 200) {
                    if (request.responseText) {
                        // strip off the last bit from the previous bit
                        var newResponse = request.responseText.substring(request.previousText.length);
                        // now make sure we have the last '{}' entry (some can be cut off at the end so some ugly
                        // parsing is necessary here)
                        var lastIdx = newResponse.lastIndexOf('}');
                        if (lastIdx !== -1) {
                            lastIdx += 1; // need the closing curly bracket
                            var firstIdx = newResponse.lastIndexOf('{', lastIdx);
                            newResponse = newResponse.substring(firstIdx, lastIdx);
                            //console.log("new response = " + newResponse);
                            var cbData = JSON.parse(newResponse);
                            //if (cbData.status === "finished") {
                            //    console.log("responseText");
                            //    console.log(request.responseText);
                            //    console.log("previousText");
                            //    console.log(request.previousText);
                            //    console.log(cbData);
                            //}
                            callback(null, cbData);
                        }
                        // save off for next time
                        request.previousText = request.responseText;
                    }
                    else {
                        callback('No data received from OTA service', null);
                    }
                }
                else {
                    // failure if anything else
                    var msg = 'System Manager is unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    callback(msg, null);
                }
            }
        };
        this.getVersion(function (error, version) {
            if (error) {
                callback("Cannot retrieve platform version to check compatibility. Download aborted.", null);
            }
            else {
                var body = {};
                if (version === "0.12.1") {
                    // for build 0.12.1, we could only send one update at a time
                    body = {
                        "id": data.ids[0]
                    };
                }
                else {
                    body = {
                        "ids": data.ids
                    };
                }
                request.send(JSON.stringify(body));
            }
        });
    };
    /**
     * @private
     **/
    SystemManager.prototype.installUpdates = function (data, callback) {
        var _this = this;
        if (!data || !data.hasOwnProperty('ids') || data.ids.length === 0) {
            callback('No IDs given.');
            return;
        }
        var request = new XMLHttpRequest();
        request.open("POST", this.httpInterface + "/update", true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 204) {
                    callback(); // success!
                }
                else {
                    // failure if anything else
                    var msg = 'System Manager is unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    callback(msg);
                }
            }
        };
        this.getVersion(function (error, version) {
            if (error) {
                callback("Cannot retrieve platform version to check compatibility. Download aborted.", null);
            }
            else {
                var body = {};
                if (version === "0.12.1") {
                    // for build 0.12.1, we could only send one update at a time
                    body = {
                        "id": data.ids[0]
                    };
                }
                else {
                    body = {
                        "ids": data.ids
                    };
                }
                if (_this.loggingEnabled) {
                    console.log("install requested");
                    console.log(body);
                }
                request.send(JSON.stringify(body));
            }
        });
    };
    //
    // private http GET helper; assumes return status code is 200 (OK)
    SystemManager.prototype._handleGET = function (url, property, callback) {
        var _this = this;
        var request = new XMLHttpRequest();
        request.open("GET", this.httpInterface + url, true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 200) {
                    var response = JSON.parse(request.response);
                    var data = (property ? response[property] : response);
                    if (_this.loggingEnabled) {
                        console.log(property);
                        console.log(data);
                    }
                    callback(null, data);
                }
                else {
                    // failure if anything else
                    var msg = 'System Manager is unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    callback(msg, null);
                }
            }
        };
        request.send();
    };
    /**
     * getIdentity - Gets the identity of the robot if connected.
     * @function module:jibo/systemManager~getIdentity (object containing name and WiFi MAC address)
     *
     * @param {function} cb Callback that notifies the caller that the
     *                      identity was retrieved; If successful, returns object containing name and MAC
     *                      address; otherwise, error string.
     **/
    SystemManager.prototype.getIdentity = function (callback) {
        this._handleGET("/identity", undefined, function (error, response) {
            if (error) {
                callback("Could not retrieve identity from Jibo", null);
            }
            else {
                callback(null, { "name": response.name, "wifi_mac": response.wifi_mac });
            }
        });
    };
    return SystemManager;
}(events_1.EventEmitter));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SystemManager;

//# sourceMappingURL=../map/services/SystemManager.js.map
