"use strict";
var async = require('async');
/**
 * Enum of photo types.
 * @alias module:jibo/lps~PhotoType
 * @enum {String}
 */
var PhotoType = {
    /** Debug: 1/2-scale grayscale. */
    DEBUG: 0,
    /** Preview: 1/2-scale color.*/
    PREVIEW: 1,
    /**  Full: full-scale color. */
    FULL: 2
};
/**
 * Enum of cameras.
 * @alias module:jibo/lps~CameraID
 * @enum {String}
 */
var CameraID = {
    /** Left camera. */
    LEFT: 0,
    /** Right camera (coming soon). */
    RIGHT: 1
};
/**
 * Enum of photo resolutions.
 * @alias module:jibo/lps~PhotoRes
 * @enum {String}
 */
var PhotoRes = {
    /** Small: 672x380 (coming soon).**/
    SMALL: 1,
    /** Medium: 1280x720. **/
    MEDIUM: 2,
    /** Large: 1920x1080 (coming soon). **/
    LARGE: 3,
    /** X-Large: 2688x1520 (coming soon). **/
    XLARGE: 4
};
var _resData = [
    {
        "width": 672,
        "height": 380
    },
    {
        "width": 1280,
        "height": 720
    },
    {
        "width": 1920,
        "height": 1080
    },
    {
        "width": 2688,
        "height": 1520
    }
];
/**
 * @description
 * Local Perceptual Space
 *
 * ```
 * var jibo = require("jibo");
 * jibo.lps.takePhoto();
 * ```
 * @module jibo/lps
 */
var LPSService = (function () {
    function LPSService() {
        this.lps = {};
        // visual awareness data
        this.lps.motionData = {
            cameras: [],
            entities: [] // List of entity objects
        };
        // audible awareness data
        this.lps.audioData = {
            entities: [] // List of entity objects
        };
        this.PhotoType = PhotoType;
        this.PhotoRes = PhotoRes;
        this.CameraID = CameraID;
    }
    Object.defineProperty(LPSService.prototype, "motionData", {
        /**
         * Returns the full state of the Jibo's local perceptual space.
         * @name module:jibo/lps~motionData
         * @type {*|{cameras: Array, entities: Array}}
         * @readOnly
         */
        get: function () {
            return this.lps.motionData;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the visual entity closest to Jibo.
     * @method module:jibo/lps~getClosestVisualEntity
     *
     * @return The closest visual entity to Jibo. If one does not exist, returns undefined.
     */
    LPSService.prototype.getClosestVisualEntity = function () {
        var entity;
        if (this.lps.motionData !== undefined &&
            this.lps.motionData.entities !== undefined &&
            this.lps.motionData.entities.length > 0) {
            entity = this.lps.motionData.entities[0]; // @TODO - get real "closest" entity when multi-track is in
        }
        return entity;
    };
    /**
     * Gets a visual entity by specified ID.
     * @method module:jibo/lps~getVisualEntityById
     *
     * @return The specified visual entity. If it does not exist, returns undefined.
     */
    LPSService.prototype.getVisualEntityById = function (id) {
        var entity;
        for (var i = 0; i < this.lps.motionData.entities.length; i++) {
            var itr = this.lps.motionData.entities[i];
            if (itr && (itr.id === id)) {
                entity = itr;
                break;
            }
        }
        return entity;
    };
    /**
     * Gets the closest audible entity to Jibo.
     * @method module:jibo/lps~getClosestAudibleEntity
     *
     * @return The closest audible entity to Jibo. If one does not exist, returns undefined.
     */
    LPSService.prototype.getClosestAudibleEntity = function () {
        var entity;
        if (this.lps.audioData !== undefined &&
            this.lps.audioData.entities !== undefined &&
            this.lps.audioData.entities.length > 0) {
            entity = this.lps.audioData.entities[0]; // @TODO - get real "closest" entity when multi-track is in
        }
        return entity;
    };
    /**
     * Gets an audible entity by specified ID.
     * @method module:jibo/lps~getAudibleEntityById
     *
     * @return The specified audible entity. If it does not exist, returns undefined.
     */
    LPSService.prototype.getAudibleEntityById = function (id) {
        var entity;
        for (var i = 0; i < this.lps.audioData.entities.length; i++) {
            var itr = this.lps.audioData.entities[i];
            if (itr && (itr.id === id)) {
                entity = itr;
                break;
            }
        }
        return entity;
    };
    /**
     * Gets the current state of the viewfinder preview.
     *
     * @return If request successful, returns timestamp, enabled, and window. If unsuccessful, returns error msg.
     */
    LPSService.prototype.getPreview = function (cb) {
        if (this.httpUrl === undefined) {
            cb('Preview service is not initialized', null);
            return;
        }
        var request = new XMLHttpRequest();
        request.open("GET", this.httpUrl + '/media/preview/control', true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 204) {
                    //if (request.response) {
                    //    // success!
                    //    let response = JSON.parse(request.response);
                    //    cb(null, response);
                    //}
                    //else {
                    //    cb('No data received from barcode service', null);
                    //}
                    cb(); // @NOTE: uncomment above when a response is returned
                }
                else {
                    // failure if anything else
                    var msg = 'Preview service unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    cb(msg, null);
                }
            }
        };
        request.send();
    };
    /**
     * Sets up a new Preview Request, that a window with camera preview be positioned at a given location on-screen.
     * @method module:jibo/lps~setPreview
     */
    LPSService.prototype.setPreview = function (data, cb) {
        if (this.httpUrl === undefined) {
            cb('Preview service is not initialized', null);
            return;
        }
        var params = {};
        // enable is a required parameter - if not present, return immediately
        if (!data.hasOwnProperty('enable')) {
            cb("Preview service data must have 'enable' property", null);
            return;
        }
        // these are NOT required parameters - if not present, use defaults
        if (!data.hasOwnProperty('width')) {
            data.width = 1280;
        }
        if (!data.hasOwnProperty('height')) {
            data.height = 720;
        }
        if (!data.hasOwnProperty('x')) {
            data.x = 0;
        }
        if (!data.hasOwnProperty('y')) {
            data.y = 0;
        }
        params.enable = data.enable;
        params.window = {
            width: data.width,
            height: data.height,
            x: data.x,
            y: data.y
        };
        var request = new XMLHttpRequest();
        request.open("POST", this.httpUrl + '/media/preview/control', true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 204) {
                    //if (request.response) {
                    //    // success!
                    //    let response = JSON.parse(request.response);
                    //    cb(null, response);
                    //}
                    //else {
                    //    cb('No data received from preview service', null);
                    //}
                    cb(); // @NOTE: uncomment above when a response is returned
                }
                else {
                    // failure if anything else
                    var msg = 'Preview service unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    cb(msg, null);
                }
            }
        };
        request.send(JSON.stringify(params));
    };
    LPSService.prototype.readBarcode = function (cb) {
        if (this.httpUrl === undefined) {
            cb('Barcode service is not initialized', null);
            return;
        }
        var request = new XMLHttpRequest();
        request.open("GET", this.httpUrl + '/lps/barcode', true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 200) {
                    if (request.response) {
                        // success!
                        var response = JSON.parse(request.response);
                        cb(null, response.barcodes);
                    }
                    else {
                        cb('No data received from barcode service', null);
                    }
                }
                else {
                    // failure if anything else
                    var msg = 'Barcode service unavailable';
                    if (request.statusText !== undefined && request.statusText !== "") {
                        msg = request.statusText;
                    }
                    cb(msg, null);
                }
            }
        };
        request.send();
    };
    /**
     * Callback for when Jibo takes a photo.
     * ```
     * jibo.lps.takePhoto((error, url) => {
     *     if(!error) {
     *         let img = new Image();
     *         img.src = url;
     *     }
     *     else {
     *         console.error(error);
     *     }
     * });
     * ```
     * @callback module:jibo/lps~OnPhoto
     * @param {String|null} error `null` if no error, otherwise a an error message.
     * @param {String} url The image URL.
     */
    /**
     * Takes a photo.
     * @method module:jibo/lps~takePhoto
     * @param {module:jibo/lps~PhotoRes} photoRes Enumerated value of the resolution of photo requested (672x380, 1280x720, etc.).
     * @param {boolean} noDistort If `false`, image appears with fish-eye distortion. If `true` (default), removes camera distortion.
     * @param {module:jibo/lps~CameraID} cameraID Enumerated value of the camera to use (1 = left, 2 = right).
     * @param {module:jibo/lps~PhotoType} photoType Enumerated value of the type of photo requested (debug, preview, full, etc.).
     *
     *
     * @param {module:jibo/lps~OnPhoto} cb Callback that will be used to notify the caller that the
     *                      photo was taken and received or if an error was encountered.
     */
    LPSService.prototype.takePhoto = function (photoRes, noDistort, cameraID, photoType, cb) {
        var _this = this;
        if (this.httpUrl === undefined) {
            cb('Photo service is not initialized', null);
            return;
        }
        // @TODO - uncomment when we support other resolutions
        //if (photoRes < this.PhotoRes.SMALL || photoRes > this.PhotoRes.XLARGE) {
        if (photoRes !== this.PhotoRes.MEDIUM) {
            photoRes = this.PhotoRes.MEDIUM; // default
        }
        var width = _resData[photoRes - 1].width;
        var height = _resData[photoRes - 1].height;
        // @TODO - uncomment when we support right camera
        //if (cameraID < this.CameraID.LEFT || cameraID > this.CameraID.RIGHT) {
        if (cameraID !== this.CameraID.LEFT) {
            cameraID = this.CameraID.LEFT; // default
        }
        if (photoType < this.PhotoType.DEBUG || photoType > this.PhotoType.FULL) {
            photoType = this.PhotoType.FULL; // default
        }
        var data = {
            "camera": cameraID,
            "width": width,
            "height": height,
            "type": photoType,
            "undistort": noDistort // Remove camera distortion from the photo
        };
        var url = this.httpUrl + '/media/photo';
        //if (0) {
        //    // !!!! COPIED FROM LPSSERVICE PAGE !!!!
        //    //console.log("Sending POST request (JQUERY)");
        //    let jqxhr = $.post(url, JSON.stringify(data), function (obj) {
        //        let mySrc = url+"?id="+obj.id;
        //        cb(null, mySrc);
        //       // console.log("Got response (JQUERY)");
        //    });
        //
        //    jqxhr.done(function (msg) {
        //    });
        //
        //    jqxhr.fail(function (msg) {
        //        console.log("Failed to get image");
        //    });
        //
        //    jqxhr.always(function (msg) {
        //    }, "json");
        //}
        //else
        {
            var request_1 = new XMLHttpRequest();
            request_1.open("POST", url, true); // true == async
            // force it to be form data type and accepts all media
            request_1.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
            request_1.setRequestHeader('Accept', '*/*');
            request_1.onreadystatechange = function () {
                // console.log("request.readyState|status = " + request.readyState + " | " + request.status);
                // request is complete
                if (request_1.readyState == 4) {
                    // "OK" status
                    if (request_1.status === 200) {
                        if (request_1.response) {
                            // success!
                            var response = JSON.parse(request_1.response);
                            _this._getPhoto(response.id, cb);
                        }
                        else {
                            cb('No data received from photo service', null);
                        }
                    }
                    else {
                        // failure if anything else
                        var msg = 'Photo service unavailable';
                        if (request_1.statusText !== undefined && request_1.statusText !== "") {
                            msg = request_1.statusText;
                        }
                        cb(msg, null);
                    }
                }
            };
            //console.log("Sending POST request (XMLHTTP)");
            request_1.send(JSON.stringify(data));
        }
    };
    LPSService.prototype._getPhoto = function (id, cb) {
        var src = this.httpUrl + '/media/photo?id=' + id;
        cb(null, src);
    };
    LPSService.prototype.init = function (service, cb) {
        this.lpsServiceUrl = "ws:" + service.host + ":" + service.port;
        this.httpUrl = "http://" + service.host + ":" + service.port;
        async.parallel([
            this._createMotionSocket.bind(this),
            this._createAudioSocket.bind(this)
        ], cb);
    };
    LPSService.prototype._createMotionSocket = function (cb) {
        var _this = this;
        this.motionSocket = new WebSocket(this.lpsServiceUrl + "/lps/visual_awareness");
        this.motionSocket.onerror = function () {
            console.error("Error opening visual awareness socket at " + _this.lpsServiceUrl + "/visual_awareness");
        };
        this.motionSocket.onmessage = function (event) {
            _this.lps.motionData = JSON.parse(event.data);
        };
        cb();
    };
    LPSService.prototype._createAudioSocket = function (cb) {
        var _this = this;
        this.audioSocket = new WebSocket(this.lpsServiceUrl + "/lps/audible_awareness");
        this.audioSocket.onerror = function () {
            console.error("Error opening audible awareness socket at " + _this.lpsServiceUrl + "/audible_awareness");
        };
        this.audioSocket.onmessage = function (event) {
            _this.lps.audioData = JSON.parse(event.data);
        };
        cb();
    };
    return LPSService;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LPSService;

//# sourceMappingURL=../map/services/LPSService.js.map
