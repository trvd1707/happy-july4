"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async = require('async');
var events_1 = require('events');
/**
 * Emitted when a word is spoken.
 * @event module:jibo/tts~word
 * @param {String} word The word that was just spoken.
 */
/**
 * Modes of TTS.
 * @alias module:jibo/tts~TTSMode
 * @enum {String}
 */
var TTSMode = {
    /** Option to generate TTS from SSML -- COMING SOON!!!*/
    SSML: 'ssml',
    /** Default mode for TTS */
    TEXT: 'text'
};
/**
 * TTS Server API paths.
 * {@link https://confluence.jibo.com/display/ENG/TTS+Service|TTS Service Docs}
 * @private
 * @enum {String}
 */
var APIPath = {
    TOKENS: '/tts_tokens',
    PHONES: '/tts_phones',
    STOP: '/tts_stop',
    SPEAK: '/tts_speak',
    TIMING: '/tts_token_times',
    EFFECTS: '/tts_effects',
    ANALYSIS: '/tts_analysis'
};
/**
 * The various event types that TTSService emits.
 * @alias module:jibo/tts~TTSEvents
 * @enum {String}
 */
var TTSEvents = {
    WORD: 'word',
    PHONE: 'phone',
    STOP: 'stop',
    EFFECT: 'effect',
    ANALYSIS: 'analysis'
};
/**
 * The various types of actions pedals can take.
 * @private
 * @enum {String}
 */
var PedalsActions = {
    START: 'START',
    STOP: 'STOP',
    UPDATE: 'UPDATE'
};
/**
 * The various events this service will emit.
 * @alias module:jibo/tts~PedalsEvents
 * @enum {String}
 */
//const PedalsEvents = {
//    CONNECT: 'connect',
//    DISCONNECT: 'disconnect',
//    CONNECT_FAIL: 'connect-fail',
//    ERROR: 'error'
//};
/**
 * The default settings for a TTS request body
 * @private
 */
var defaultTTSReqBody = {
    prompt: '',
    locale: 'en-us',
    voice: 'griffin',
    duration_stretch: 1,
    pitch: 1.0,
    pitchBandwidth: 0.55,
    mode: TTSMode.TEXT,
    outputMode: 'stream'
};
/**
 * @description
 * Text-to-Speech
 *
 * ```
 * var jibo = require("jibo");
 * jibo.tts.on('word', (word) => {
 *     //respond to words
 * });
 * jibo.tts.speak("Hello, my name is Jibo", (err) => {
 *
 * });
 * ```
 * @module jibo/tts
 * @extends {EventEmitter}
 */
var TTSService = (function (_super) {
    __extends(TTSService, _super);
    function TTSService() {
        _super.call(this);
        this.isInitialized = false;
        this.isTalking = false;
        this.isStopping = false;
        // Flip this on to have websocket messages logged to the console
        //this.logging = true;
        // Provide external access to these enums
        this.TTSEvents = TTSEvents;
        this.TTSMode = TTSMode;
    }
    Object.defineProperty(TTSService, "TTSMode", {
        get: function () {
            return TTSMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TTSService, "TTSEvents", {
        get: function () {
            return TTSEvents;
        },
        enumerable: true,
        configurable: true
    });
    TTSService.prototype.init = function (service, cb) {
        var _this = this;
        if (!service.host || typeof service.host !== 'string') {
            throw new Error("Missing required service.host");
        }
        this.httpInterface = "http://" + service.host + ":" + service.port;
        this.socketUrl = "ws:" + service.host + ":" + service.port;
        // Wrap effect socket call so we can extract socket and keep ref to it
        var effectsSocketCreator = function (cb) {
            var handler = function (socket) {
                _this.effectsSocket = socket;
                cb();
            };
            _this.createSocket(APIPath.EFFECTS, "tts sound effects", TTSEvents.EFFECT)(handler);
        };
        async.parallel([
            this.createSocket(APIPath.TOKENS, "tts tokens", TTSEvents.WORD).bind(this),
            this.createSocket(APIPath.PHONES, "tts phones", TTSEvents.PHONE).bind(this),
            this.createSocket(APIPath.ANALYSIS, "tts analysis", TTSEvents.ANALYSIS).bind(this),
            effectsSocketCreator
        ], function () {
            _this.isInitialized = true;
            cb();
        });
    };
    TTSService.prototype.getOptionsAndCallback = function (arg1, arg2) {
        var options = {};
        var callback;
        if (arg1 === undefined && arg2 === undefined) {
            options = {};
        }
        else if (typeof arg1 === 'object' && arg2 === undefined) {
            options = arg1;
        }
        else if (typeof arg1 === 'function' && arg2 === undefined) {
            callback = arg1;
        }
        else if (typeof arg1 === 'object' && typeof arg2 === 'function') {
            options = arg1;
            callback = arg2;
        }
        return {
            options: options, callback: callback
        };
    };
    TTSService.prototype.createSocket = function (path, socketDescription, emitterEventName) {
        var _this = this;
        return function (cb) {
            var socket = new WebSocket(_this.socketUrl + path);
            socket.onerror = function () {
                console.error("Error opening " + socketDescription + " socket at " + _this.socketUrl + path);
            };
            socket.onmessage = function (event) {
                // Log events to the console if logging is enabled
                if (_this.logging) {
                    console.log(event);
                }
                var word;
                try {
                    word = JSON.parse(event.data);
                }
                catch (err) {
                    // Work around to fix tts service's malformed (Failed ot JSON.parse()) payloads for the
                    // message when the token status is "STOP"
                    if (event.data === '{"token":"","timestamp":0.0,"status":"STOP","moreinfo":[]}') {
                        _this.emit(emitterEventName, { "token": "", "timestamp": 0.0, "status": "STOP", "moreinfo": [] });
                        return;
                    }
                    console.log("Could not JSON.parse() " + socketDescription + " event.data. Payload was: '" + event.data + "'");
                }
                if (word) {
                    _this.emit(emitterEventName, word);
                }
            };
            cb(socket);
        };
    };
    TTSService.prototype._dispatchWordSchedule = function (wordTimings) {
        var _this = this;
        var start = Date.now();
        var index = 0;
        wordTimings = wordTimings.tokentimes.tokens
            .filter(function (token) { return token.name !== '/pau/'; });
        var handleWord = function () {
            var wordObj = wordTimings[index];
            _this.emit('word', {
                token: wordObj.name,
                timestamp: wordObj.start,
                status: 'PLAY',
                moreinfo: []
            });
            index++;
            if (index < wordTimings.length) {
                var nextTime = 1000 * wordTimings[index].start;
                var current = Date.now() - start;
                setTimeout(handleWord, Math.max(nextTime - current, 0));
            }
        };
        if (wordTimings.length) {
            var nextTime = 1000 * wordTimings[index].start;
            setTimeout(handleWord, nextTime);
        }
    };
    TTSService.prototype._speak = function (text, options, callback) {
        var _this = this;
        if (!this.isInitialized) {
            callback("TTS Service is not initialized");
            return;
        }
        var doSpeak = function () {
            // We start by getting the word schedule
            _this._getWordTimings(text, options, function (err, timings) {
                if (err) {
                    callback(err);
                }
                else {
                    // We then start dispatching the word schedule
                    // asynchronously
                    _this._dispatchWordSchedule(timings);
                    var request_1 = new XMLHttpRequest();
                    var requestBody = JSON.parse(JSON.stringify(defaultTTSReqBody));
                    requestBody.prompt = text;
                    // Pass in optional parameters
                    requestBody.duration_stretch = options.duration_stretch ||
                        requestBody.duration_stretch;
                    requestBody.pitchBandwidth = options.pitchBandwidth ||
                        requestBody.pitchBandwidth;
                    requestBody.pitch = options.pitch || requestBody.pitch;
                    requestBody.mode = options.mode || requestBody.mode;
                    requestBody = JSON.stringify(requestBody);
                    request_1.open("POST", _this.httpInterface + APIPath.SPEAK, true);
                    request_1.onreadystatechange = function () {
                        if (request_1.readyState == 4) {
                            if (request_1.status === 204) {
                                _this.isTalking = false;
                                callback();
                            }
                            else {
                                // failure if anything else
                                var msg = 'TTS Service is unavailable';
                                if (request_1.statusText !== undefined && request_1.statusText !== "") {
                                    msg = request_1.statusText; // use "reason" if they gave it
                                }
                                callback(msg);
                            }
                        }
                    };
                    _this.isTalking = true;
                    request_1.send(requestBody);
                }
            });
        };
        if (this.isStopping) {
            var onStopped_1 = function () {
                _this.removeListener('stopped', onStopped_1);
                doSpeak();
            };
            this.on('stopped', onStopped_1);
        }
        else if (this.isTalking) {
            stop(doSpeak);
        }
        else {
            doSpeak();
        }
    };
    /**
     * Makes Jibo speak.
     * @method module:jibo/tts~speak
     * @param {String} text Text for Jibo to speak.
     * @param {Object} [options] Parameters to override default TTS behavior.
     * @param {number} [options.duration_stretch] Stretches the utterance. 1 = no stretch, 0.5 = halves the duration, 2 doubles the duration. There is no upper limit.
     *                                            Has no effect if `options.mode === jibo.tts.TTSMode.SSML`.
     * @param {number} [options.pitch]  Controls the overall pitch of the speaker. There is no SSML tag to override this.
     *                                  Recommended value is 0.42. The recommended range is [0.2, 0.8].
     * @param {number} [options.pitchBandwidth] Widens the pitch bandwidth. Recommended value is 1.
     *                                          The range is [0.0, 2.0]. A value of 0 makes Jibo sound robotic, while a value of 2.0
     *                                          makes Jibo sound more like a person.
     * @param {module:jibo/tts~TTSMode} [options.mode] In `jibo.tts.TTSMode.SSML` mode, the `text` argument to this function should contain valid SSML. In text mode, the prompt can contain any text.
     * @param {Function} [callback] Callback that notifies the caller that the speech has started. If no
     *                              callback is provided, a `Promise` is returned.
     * @return {Promise|undefined} If no callback is provided, a `Promise` is returned, which is resolved when done speaking.
     */
    TTSService.prototype.speak = function (text, arg1, arg2) {
        var _this = this;
        var _a = this.getOptionsAndCallback(arg1, arg2), callback = _a.callback, options = _a.options;
        if (!callback) {
            return new Promise(function (res, rej) {
                var cb = function (err) {
                    if (err)
                        rej(err);
                    else
                        res();
                };
                _this._speak(text, options, cb);
            });
        }
        else {
            this._speak(text, options, callback);
        }
    };
    TTSService.prototype._stop = function (callback) {
        var _this = this;
        if (!this.isInitialized) {
            callback();
            return;
        }
        this.isStopping = true;
        this.isTalking = false;
        var request = new XMLHttpRequest();
        request.timeout = 2000;
        request.onreadystatechange = function () {
            if (request.readyState === 4 && request.status === 200) {
                _this.isStopping = false;
                _this.emit('stopped');
                callback();
            }
        };
        request.open("GET", this.httpInterface + APIPath.STOP, true);
        request.send(null);
    };
    /**
     * Stops any speech Jibo is uttering.
     * @method module:jibo/tts~stop
     * @param {Function} [callback] Callback that notifies the caller that speech has stopped. If no callback is provided, a `Promise` is returned.
     * @return {Promise|undefined} If no callback is provided a `Promise`, which gets resolved when stopped, is returned.
     */
    TTSService.prototype.stop = function (callback) {
        var _this = this;
        if (callback) {
            this._stop(callback);
        }
        else {
            return new Promise(function (res) {
                _this._stop(res);
            });
        }
    };
    TTSService.prototype._getWordTimings = function (text, options, cb) {
        if (typeof text !== 'string') {
            throw new TypeError("Invalid params: " + text + ", " + TTSMode);
        }
        if (!this.isInitialized) {
            throw new Error('Not initialized. Use .init()');
        }
        var request = new XMLHttpRequest();
        var requestBody = JSON.parse(JSON.stringify(defaultTTSReqBody));
        requestBody.prompt = text;
        // Pass in optional parameters
        requestBody.duration_stretch = options.duration_stretch ||
            requestBody.duration_stretch;
        requestBody.pitchBandwidth = options.pitchBandwidth ||
            requestBody.pitchBandwidth;
        requestBody.pitch = options.pitch || requestBody.pitch;
        requestBody.mode = options.mode || requestBody.mode;
        // Create actual request body and subscribe response handler
        requestBody = JSON.stringify(requestBody);
        request.open('POST', this.httpInterface + APIPath.TIMING, true);
        request.onreadystatechange = function () {
            var requestIsDone = request.readyState == 4;
            var isErrorStatus = request.status < 200 || request.status >= 400;
            if (requestIsDone && request.status == 200) {
                // We attempt parsing the message
                var msg = void 0;
                try {
                    msg = JSON.parse(request.response);
                }
                catch (err) {
                    cb(err);
                }
                if (msg) {
                    if (msg.Status && msg.Status === 'ERROR') {
                        cb(msg);
                    }
                    else {
                        cb(null, msg);
                    }
                }
            }
            else if (requestIsDone && isErrorStatus) {
                cb(new Error("Request failed with status: " + request.status));
            }
        };
        request.send(requestBody);
    };
    /**
     * Asynchronously retrieves a word schedule for given text (SSML markup support coming soon!).
     * @method module:jibo/tts~getWordTimings
     * @param {String} text The utterance provided to TTS for speaking.
     * @param {Object} [options] Same options as {@link module:jibo/tts~speak}.
     * @param {Function} [callback] Callback. If none is provided, a `Promise` will be returned.
     * @return {Promise|undefined}
     */
    TTSService.prototype.getWordTimings = function (text, arg1, arg2) {
        var _this = this;
        var _a = this.getOptionsAndCallback(arg1, arg2), options = _a.options, callback = _a.callback;
        if (callback) {
            this._getWordTimings(text, options, callback);
        }
        else {
            return new Promise(function (res, rej) {
                var cb = function (err, schedule) {
                    if (err)
                        rej(err);
                    else
                        res(schedule);
                };
                _this._getWordTimings(text, options, cb);
            });
        }
    };
    TTSService.prototype._validateEffectNameParam = function (name) {
        if (typeof name !== 'string') {
            throw new TypeError("Invalid params, name must be string: " + name);
        }
        if (!this.isInitialized) {
            throw new Error('Not connected. Cannot send action.');
        }
        if (!this.effectsSocket) {
            throw new Error('Effect socket not initialized.');
        }
    };
    TTSService.prototype._validateEffectValueParam = function (value) {
        if (typeof value === 'number') {
            if (value < 0 || value > 1) {
                throw new TypeError("Value out of range [0, 1]: " + value);
            }
        }
        else if (typeof value !== 'string') {
            throw new TypeError("Value must either be a number or string: " + value);
        }
    };
    /**
     * Starts a sound effect.
     * @method module:jibo/tts~startEffect
     * @param {String} name The name of the effect.
     * @param {number | string} value Either a number between 0 and 1 or a
     * string parameter for the effect.
     */
    TTSService.prototype.startEffect = function (name, value) {
        this._validateEffectNameParam(name);
        this._validateEffectValueParam(value);
        var requestBody = {
            'name': name,
            'action': PedalsActions.START,
            'param': ("" + value)
        };
        this.effectsSocket.send(JSON.stringify(requestBody));
    };
    /**
     * Stops a sound effect.
     * @method module:jibo/tts~stopEffect
     * @param {String} name The name of the effect.
     */
    TTSService.prototype.stopEffect = function (name) {
        this._validateEffectNameParam(name);
        var requestBody = {
            'name': name,
            'action': PedalsActions.STOP,
            'param': "0"
        };
        this.effectsSocket.send(JSON.stringify(requestBody));
    };
    /**
     * Updates the value of a sound effect.
     * @method module:jibo/tts~updateEffect
     * @param {String} name The name of the effect.
     * @param {number | string} value Either a number between 0 and 1 or a
     * string parameter for the effect.
     */
    TTSService.prototype.updateEffect = function (name, value) {
        this._validateEffectNameParam(name);
        this._validateEffectValueParam(value);
        var requestBody = {
            'name': name,
            'action': PedalsActions.UPDATE,
            'param': ("" + value)
        };
        this.effectsSocket.send(JSON.stringify(requestBody));
    };
    return TTSService;
}(events_1.EventEmitter));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TTSService;

//# sourceMappingURL=../map/services/TTSService.js.map
