"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Behavior_1 = require('../Behavior');
var Status_1 = require('../Status');
var jibo_1 = require('../../jibo');
var PathUtils_1 = require('../../utils/PathUtils');
var KeysAnimation_1 = require('../../rendering/animation/KeysAnimation');
/**
 * @class PlayAnimation
 * @extends module:jibo/bt.Behavior
 * @memberof module:jibo/bt/behaviors
 * @description Plays the animation specified by `animPath`. Succeeds when the animation is finished playing. Playing an
 *              animation consists of two phases: the transition phase and the play phase. The transition phase will
 *              transition Jibo from his current position to the start position this the specified animation. The play
 *              phase, plays the animation with the current configuration.
 * @param {Object} options See {@link module:jibo/bt.Behavior|Behavior} for all options.
 * @param {String} options.animPath The path to the `.keys` file. This behaviuor assumes `${project}/animations` is the root for
 *                          all the animations.
 * @param {Function} options.config Called and passed a {@link AnimationBuilder} object for configuration purposes. Do not call
 *                          {@link AnimationBuilder#play}. This is done automatically by the behavior.
 * @param {Boolean} [options.cache=true] True to cache the animation. False to play once and destroy.
 */
var PlayAnimation = (function (_super) {
    __extends(PlayAnimation, _super);
    function PlayAnimation(options) {
        _super.call(this, options);
        //backward support
        if (typeof this.options.cache === 'undefined') {
            this.options.cache = true;
        }
        //backward support
        if (typeof this.options.upload === 'undefined') {
            this.options.upload = true;
        }
        //first default this asset to the 'animations' folder
        this.alias = PathUtils_1.default.setDefaultPath('animations', options.animPath);
        // Reference to the builder
        this.animation = null;
        // Bound function
        this.onEvent = this.onEvent.bind(this);
        this.status = Status_1.default.INVALID;
        this.cache = this.options.cache;
    }
    PlayAnimation.prototype.start = function () {
        this.status = Status_1.default.IN_PROGRESS;
        var animation = jibo_1.default.loader.cached(this.alias);
        // Don't reload the animation, it's already cached
        if (this.cache && animation) {
            animation.reset();
            this.onKeysLoaded(null, animation);
        }
        else {
            var src = PathUtils_1.default.getAssetUri(this.alias, this.assetPack);
            jibo_1.default.loader.load({
                id: this.alias,
                cache: true,
                src: src,
                upload: this.options.upload,
                root: PathUtils_1.default.findRoot(src),
                type: 'keys',
                complete: this.onKeysLoaded.bind(this)
            });
        }
        return true;
    };
    PlayAnimation.prototype.onKeysLoaded = function (err, animation) {
        var _this = this;
        if (err) {
            this.status = Status_1.default.FAILED;
            return;
        }
        // Add instances
        this.animation = animation;
        // Listen for stopped event
        this.animation.on(KeysAnimation_1.default.STOPPED, function () {
            _this.reset();
            _this.status = Status_1.default.SUCCEEDED;
        });
        // register for all events
        this.animation.on(KeysAnimation_1.default.EVENT, this.onEvent);
        if (this.options.config) {
            this.options.config(this.animation);
        }
        this.instance = this.animation.builder.play();
    };
    PlayAnimation.prototype.stop = function () {
        if (!this.instance) {
            this.instance.stop();
        }
        this.reset();
    };
    PlayAnimation.prototype.reset = function () {
        if (this.animation) {
            // de-register for these events if animation stopped
            this.animation.removeListener(KeysAnimation_1.default.EVENT, this.onEvent);
        }
        this.animation = null;
        if (!this.cache) {
            jibo_1.default.loader.unload(this.alias);
        }
    };
    PlayAnimation.prototype.onEvent = function (eventType, animInstance, payload) {
        jibo_1.default.behaviorEmitter.emit(payload.eventName, animInstance, payload.payload);
    };
    PlayAnimation.prototype.update = function () {
        return this.status;
    };
    return PlayAnimation;
}(Behavior_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PlayAnimation;

//# sourceMappingURL=../../map/bt/behaviors/PlayAnimation.js.map
