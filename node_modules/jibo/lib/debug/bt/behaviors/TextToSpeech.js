"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Behavior_1 = require('../Behavior');
var Status_1 = require('../Status');
var Runtime_1 = require('../../Runtime');
/**
 * @class TextToSpeech
 * @extends module:jibo/bt.Behavior
 * @memberof module:jibo/bt/behaviors
 * @description Makes Jibo speak.
 * @param {Object} options See {@link module:jibo/bt.Behavior|Behavior} for all options.
 * @param {String} options.words The words for Jibo to speak.
 * @param {Function} options.onWord Called each time a word is spoken. The word that is spoken is passed as an argument.
 */
var TextToSpeech = (function (_super) {
    __extends(TextToSpeech, _super);
    function TextToSpeech(options) {
        _super.call(this, options);
        this.onSpeakingStopped = this.onSpeakingStopped.bind(this);
        this.status = Status_1.default.INVALID;
    }
    // Create a callback that we can pass to the tts service to listen
    // for stopped events that indicate someone called tts.stop().
    // NOTE: We need to play well with others (aka calls to the low level API that
    // are implemented by other behaviors or regular app code)
    TextToSpeech.prototype.onSpeakingStopped = function () {
        this.status = Status_1.default.SUCCEEDED;
    };
    Object.defineProperty(TextToSpeech.prototype, "words", {
        set: function (words) {
            this.options.words = words;
        },
        enumerable: true,
        configurable: true
    });
    TextToSpeech.prototype.start = function () {
        var _this = this;
        var tts = Runtime_1.default.instance.tts;
        this.status = Status_1.default.IN_PROGRESS;
        tts.speak(this.options.words, function (err) {
            // the behavior will succeed (even if there's an error) once we get the response back from tts service
            _this.status = Status_1.default.SUCCEEDED;
            if (err) {
                console.log("tts.speak() error: " + err);
            }
        });
        // Remove the listeners
        this.cleanup();
        // Register for the relevant events
        tts.on("word", this.options.onWord);
        tts.on("stopped", this.onSpeakingStopped);
        return true;
    };
    TextToSpeech.prototype.cleanup = function () {
        var tts = Runtime_1.default.instance.tts;
        // Remove listeners from the tts service
        tts.removeListener('stopped', this.onSpeakingStopped);
        tts.removeListener('word', this.options.onWord);
    };
    TextToSpeech.prototype.stop = function () {
        this.cleanup();
    };
    TextToSpeech.prototype.update = function () {
        if (this.status !== Status_1.default.IN_PROGRESS) {
            this.cleanup();
        }
        return this.status;
    };
    return TextToSpeech;
}(Behavior_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TextToSpeech;

//# sourceMappingURL=../../map/bt/behaviors/TextToSpeech.js.map
