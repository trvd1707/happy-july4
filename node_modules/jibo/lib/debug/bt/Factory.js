"use strict";
var path = require('path');
var callsite = require('callsite');
var BehaviorEmitter_1 = require('./BehaviorEmitter');
var Blackboard_1 = require('./Blackboard');
var BehaviorTree_1 = require('./BehaviorTree');
var Status_1 = require('./Status');
/**
 * Utility methods for registering behaviors and creating behaviors trees.
 * @class Factory
 * @module jibo/bt
 */
var Factory = (function () {
    function Factory(bt) {
        /**
         * Map of behaviors
         * @name module:jibo/bt~_behaviors
         * @type {Object}
         * @private
         */
        this._behaviors = {};
        this.Status = Status_1.default;
        /**
         * The default blackboard
         * @name module:jibo/bt~blackboard
         * @type {module:jibo/bt.Blackboard}
         * @private
         */
        this.blackboard = new Blackboard_1.default();
        // Mixin the classes
        Object.assign(this, bt);
        // Register core behaviors and decorators
        this.registerCore();
    }
    /**
     * Register a behavior or decorator globally
     * @name module:jibo/bt~register
     * @method
     * @param {String} name The PascalCased name for the behavior
     * @param {String} namespace This behavior's namespace. Pass in a globally unique name for this namesapce.
     * @param {Module} classRef Class reference for the behavior or decorator
     */
    Factory.prototype.register = function (name, namespace, classRef) {
        var ns = this._behaviors[namespace];
        if (!ns) {
            ns = this._behaviors[namespace] = {};
        }
        ns[name] = classRef;
    };
    /**
     * Add all behaviors
     * @method module:jibo/bt~registerCore
     * @private
     */
    Factory.prototype.registerCore = function () {
        var namespace = 'core';
        var all = Object.assign({}, this.behaviors, this.decorators);
        // Add the core behaviors/decorators
        for (var name_1 in all) {
            this.register(name_1, namespace, all[name_1]);
        }
    };
    /**
     * Creates a runnable behavior tree from a bt file import.
     * ```
     * var jibo = require('jibo');
     * var Status = jibo.bt.Status;
     * var root = jibo.bt.create('../behaviors/main');
     * root.start();
     * let intervalId = setInterval(() => {
     *    if (root.status !== Status.IN_PROGRESS) {
     *        clearInterval(intervalId);
     *    }
     *    else {
     *        root.update();
     *    }
     * }, 33);
     * ```
     * @method module:jibo/bt~create
     * @param {String} uri Relative or absolute path to a `.bt` file.
     * @param {Object} [overrides] Options for populating behavior tree globals.
     * @param {module:jibo/bt.Blackboard} [overrides.blackboard] Override the default blackboard object for this behavior tree.
     * @param {Object} [overrides.notepad] Provide your own notepad object instead of the default one.
     * @param {String} [overrides.assetPack] The asset pack name to use for loading assets in this tree.
     * @returns {module:jibo/bt.BehaviorTree}
     */
    Factory.prototype.create = function (uri, overrides) {
        if (overrides === void 0) { overrides = {}; }
        var treePath;
        uri = uri.substr(0, uri.lastIndexOf(path.parse(uri).ext));
        if (!path.isAbsolute(uri)) {
            var calleeDirname = callsite()[1].getFileName();
            // Remove "file://" for callers included with <script> tags
            calleeDirname = calleeDirname.replace(/^file\:\/\//, '');
            treePath = path.join(calleeDirname, '..', uri);
        }
        else {
            treePath = uri;
        }
        var createTree;
        try {
            createTree = require(treePath);
        }
        catch (e) {
            console.error(e);
            throw new Error(uri + ' is not a valid behavior tree');
        }
        var blackboard = overrides.blackboard || this.blackboard;
        var notepad = overrides.notepad || {};
        var result = {};
        var emitter = new BehaviorEmitter_1.default();
        var tree = createTree(blackboard, notepad, result, emitter);
        var map = {};
        var i, j, node, id;
        var ids = Object.keys(tree);
        var namespace = "", ns;
        for (i = 0; i < ids.length; i++) {
            id = ids[i];
            node = tree[id];
            namespace = node['asset-pack'] || "core";
            if (namespace === "project" && overrides.assetPack) {
                namespace = overrides.assetPack;
            }
            ns = this._behaviors[namespace];
            if (!ns) {
                throw new Error("Namespace '" + namespace + "' is not registered with the behavior factory");
            }
            else if (!ns[node.class]) {
                throw new Error("Behavior '" + node.class + "' in namespace '" + namespace + "' is not registered with the behavior factory");
            }
            else if (Array.isArray(node.args)) {
                throw new Error("Behavior '" + node.class + "' options are invalid, re-run behaviorify");
            }
            var Constructor = ns[node.class];
            // let args = node.args ? [node.name].concat(node.args) : [node.name];
            // map[id] = Constructor.apply(null, args);
            var options = Object.assign({
                name: node.name,
                emitter: emitter,
                blackboard: blackboard,
                assetPack: overrides.assetPack || ""
            }, node.options || {});
            map[id] = new Constructor(options);
        }
        var possibleRoots = {};
        for (i = 0; i < ids.length; i++) {
            id = ids[i];
            node = tree[id];
            if (!node.parent) {
                possibleRoots[node.id] = true;
            }
            if (node.skipped) {
                delete possibleRoots[node.id];
                continue;
            }
            var behavior = map[node.id];
            if (node.children) {
                var children = [];
                for (j = 0; j < node.children.length; j++) {
                    var childId = node.children[j];
                    var child = map[childId];
                    if (!tree[childId].skipped) {
                        children.push(child);
                    }
                }
                behavior.children = children;
            }
            if (node.decorators) {
                var decorators = [];
                for (j = 0; j < node.decorators.length; j++) {
                    var decorator = map[node.decorators[j]];
                    delete possibleRoots[node.decorators[j]];
                    if (!tree[node.decorators[j]].skipped) {
                        decorators.push(decorator);
                    }
                }
                if (decorators.length > 0) {
                    behavior.decorators = decorators;
                }
            }
        }
        var root = map[Object.keys(possibleRoots)[0]];
        return new BehaviorTree_1.default(root, this.blackboard, notepad, result, emitter);
    };
    return Factory;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Factory;

//# sourceMappingURL=../map/bt/Factory.js.map
