"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Decorator_1 = require('../Decorator');
var Status_1 = require('../Status');
var events_1 = require('events');
var Runtime_1 = require('../../Runtime');
/**
 * @class ListenEmitter
 * @description Used to listen for cloud events.
 * @extends EventEmitter
 * @memberof module:jibo/bt
 */
/**
 * @typedef {Object} module:jibo/bt/decorators.SucceedOnListenJs~Options
 * @property {boolean} heyJibo Listen for "Hey, Jibo" first.
 * @property {boolean} detectEnd Listen for end of speech.
 * @property {boolean} incremental Return incremental ASR results as they are streamed from the cloud.
 * @property {String} authenticateSpeaker Authenticates against that person.
 */
/**
 * Function that returns the options object.
 * @callback module:jibo/bt/decorators.SucceedOnListenJs~GetOptions
 * @returns {module:jibo/bt/decorators.SucceedOnListenJs~Options}
 */
/**
 * Called when the {@link module:jibo/bt/behaviors.ListenEmitter|ListenEmitter} is constructed.
 * @callback module:jibo/bt/decorators.SucceedOnListenJs~OnResult
 * @param {module:jibo/bt.ListenEmitter} listener Use this instance to listen for listen events.
 */
/**
 * @class SucceedOnListenJs
 * @extends module:jibo/bt.Decorator
 * @memberof module:jibo/bt/decorators
 * @description Performs audio speech recognition and applies and parses the results according to a rules file.
 * @param {Object} options See {@link module:jibo/bt.Decorator|Decorator} for all options.
 * @param {module:jibo/bt/decorators.SucceedOnListenJs~GetOptions} options.getOptions Returns the options object.
 * @param {Function} options.getRule This function returns a string representation of a rule. Use this decorator to dynamically generate rules files instead
 *                      of loading a rule file from disk.
 * @param {module:jibo/bt/decorators.SucceedOnListenJs~OnResult} options.onResult Called and passed a {@link module:jibo/bt/behaviors.ListenEmitter|ListenEmitter} object. Events are fired from the Listener
 *                                   at certain points in this behavior's lifecycle.
 */
var SucceedOnListenJs = (function (_super) {
    __extends(SucceedOnListenJs, _super);
    function SucceedOnListenJs(options) {
        _super.call(this, options);
        this.status = Status_1.default.INVALID;
    }
    SucceedOnListenJs.prototype.start = function () {
        var _this = this;
        this.starting = true;
        var options = this.options.getOptions();
        var asr = Runtime_1.default.instance.asr;
        this.status = Status_1.default.IN_PROGRESS;
        if (!asr.isInitialized) {
            console.warn('Running listen without ASR service');
            return true;
        }
        this.emitter = new events_1.EventEmitter();
        // read the string from the rule file.
        this.options.getRule(function (data) {
            _this.listener = asr.createListener(options, data);
            _this.listener.start();
            _this.listener.on('cloud', function (result, speaker) {
                /**
                 * This event is fired when there is a cloud result.
                 * @event module:jibo/bt.ListenEmitter#cloud
                 * @param {Object} result
                 * @param {String} result.Input The text recognized so far.
                 * @param {Object} result.NLParse Key value pairs from parsing of a `.rule` file.
                 * @param {Array} speakers Text independent speaker ID results.
                 */
                _this.emitter.emit('cloud', result, speaker);
            });
            _this.listener.on('incremental', function (result) {
                /**
                 * ASR incremental results.
                 * @event module:jibo/bt.ListenEmitter#incremental
                 * @param {Object} result
                 * @param {Object} result.Input The text recognized so far.
                 * @param {Object} result.NLParse Key value pairs from parsing of a `.rule` file.
                 * @param {Function} stop Call this function to succeed the behavior on an incremental result. For example, if an incremental
                 *                        result returns a valid parse against a rule, then there is no need to continue listening.
                 */
                _this.emitter.emit('incremental', result, function () {
                    _this.listener.stop();
                });
            });
            _this.listener.on('embedded', function (result, speaker) {
                /**
                 * An embedded recognition event occurred such as someone saying 'Hey Jibo'.
                 * @event module:jibo/bt.ListenEmitter#hey-jibo
                 * @param {Object} result
                 * @param {String} result.Input The result of an embedded recognition.
                 * @param {Array} speakers Text dependent speaker ID results.
                 */
                _this.emitter.emit('hey-jibo', result, speaker);
            });
            _this.listener.on('end', function () {
                /**
                 * Fired when end of speech is detected.
                 * @event module:jibo/bt.ListenEmitter#end
                 */
                _this.emitter.emit('end');
            });
            _this.listener.on('error', function (error) {
                /**
                 * Fired when there is an error.
                 * @event module:jibo/bt.ListenEmitter#error
                 * @param {String} error
                 */
                _this.emitter.emit('error', error);
            });
            _this.listener.on('finished', function () {
                _this.listener.removeAllListeners();
                _this.emitter.removeAllListeners();
                _this.status = Status_1.default.SUCCEEDED;
            });
            _this.options.onResult(_this.emitter);
            _this.status = Status_1.default.IN_PROGRESS;
            _this.starting = false;
        });
        return true;
    };
    SucceedOnListenJs.prototype.stop = function () {
        if (!this.starting) {
            if (this.emitter) {
                this.emitter.removeAllListeners();
                this.emitter = undefined;
            }
            if (this.listener) {
                this.listener.removeAllListeners();
                this.listener.action.stop();
                this.listener.action.clear();
                this.listener = undefined;
            }
        }
    };
    SucceedOnListenJs.prototype.update = function (result) {
        if (this.status === Status_1.default.IN_PROGRESS) {
            return result;
        }
        else {
            return this.status;
        }
    };
    return SucceedOnListenJs;
}(Decorator_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SucceedOnListenJs;

//# sourceMappingURL=../../map/bt/decorators/SucceedOnListenJs.js.map
