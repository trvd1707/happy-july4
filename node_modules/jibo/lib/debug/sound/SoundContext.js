"use strict";
/**
 * Main class to handle webkit audio.
 *
 * @class SoundContext
 * @private
 */
var SoundContext = (function () {
    function SoundContext() {
        /**
         * The instance of the AudioContext for WebAudio API.
         * @private
         * @property {AudioContext} _ctx
         */
        this._ctx = new AudioContext();
        // setup the end of the node chain
        this._gainNode = this._ctx.createGain();
        this._compressor = this._ctx.createDynamicsCompressor();
        this._gainNode.connect(this._compressor);
        this._compressor.connect(this._ctx.destination);
        // Set the defaults
        this.volume = 1;
        this.muted = false;
        this.paused = false;
    }
    SoundContext.prototype.destroy = function () {
        this._ctx = null;
        this._gainNode = null;
        this._compressor = null;
    };
    Object.defineProperty(SoundContext.prototype, "context", {
        /**
         * The WebAudio API AudioContext object.
         * @property {AudioContext} context
         * @private
         * @name SoundContext#context
         * @type {AudioContext}
         */
        get: function () {
            return this._ctx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundContext.prototype, "muted", {
        /**
         * Sets the muted state.
         * @type {Boolean}
         * @name SoundContext#muted
         * @default false
         */
        get: function () {
            return this._muted;
        },
        set: function (muted) {
            this._muted = !!muted;
            this._gainNode.gain.value = this._muted ? 0 : this._volume;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundContext.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        /**
         * Sets the volume from 0 to 1.
         * @type {Number}
         * @name SoundContext#volume
         * @default 1
         */
        set: function (volume) {
            // update volume
            this._volume = volume;
            // update actual volume IIF not muted
            if (!this._muted) {
                this._gainNode.gain.value = this._volume;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundContext.prototype, "paused", {
        get: function () {
            return this._paused;
        },
        /**
         * Pauses all sounds.
         * @type {Boolean}
         * @name SoundContext#paused
         * @default false
         */
        set: function (paused) {
            if (paused && this._ctx.state === 'running') {
                this._ctx.suspend();
            }
            else if (!paused && this._ctx.state === 'suspended') {
                this._ctx.resume();
            }
            this._paused = paused;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the entry node in the master node chains.
     * @private
     */
    SoundContext.prototype._entryNode = function () {
        //return this._ctx.destination;
        return this._gainNode;
    };
    /**
     * Toggles the muted state.
     * @method SoundContext#toggleMute
     * @return {Boolean} The current muted state.
     */
    SoundContext.prototype.toggleMute = function () {
        this.muted = !this.muted;
        return this._muted;
    };
    return SoundContext;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SoundContext;

//# sourceMappingURL=../map/sound/SoundContext.js.map
