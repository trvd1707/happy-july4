"use strict";
var ChainBuilder_1 = require('./ChainBuilder');
var SoundInstance_1 = require('./SoundInstance');
/**
 * Represents a single sound element. Can be used to play, pause, etc. sound instances.
 *
 * @class Sound
 * @memberof module:jibo/sound
 * @constructor
 * @param {SoundContext} [context] The context.
 * @param {ArrayBuffer|String|Object} options Either the path or url to the source file.
 *        or the object of options to use.
 * @param {ArrayBuffer|String} [options.src] If `options` is an object, the source of file.
 * @param {Boolean} [options.autoPlay=false] true to play after loading.
 * @param {Boolean} [options.preload=false] true to immediately start preloading.
 * @param {Boolean} [options.block=false] true to only play one instance of the sound at a time.
 * @param {Number} [options.volume=1] The amount of volume 1 = 100%.
 * @param {Boolean} [options.useXHR=false] true to use XMLHttpRequest to load the sound. Default is false, loaded with NodeJS's `fs` module.
 * @param {Number} [options.panning=0] The panning amount from -1 (left) to 1 (right).
 * @param {module:jibo/sound.Sound~completeCallback} [options.complete=null] Global complete callback when play is finished.
 * @param {module:jibo/sound.Sound~loadedCallback} [options.loaded=null] Call when finished loading.
 * @param {Boolean} [options.loop=false] true to loop the audio playback.
 */
var Sound = (function () {
    function Sound(context, options) {
        if (typeof options === "string" || options instanceof ArrayBuffer) {
            options = { src: options };
        }
        // Default settings
        options = Object.assign({
            autoPlay: false,
            block: false,
            src: null,
            preload: false,
            volume: 1,
            panning: 0,
            complete: null,
            loaded: null,
            loop: false,
            useXHR: false
        }, options || {});
        /**
         * Reference to the sound context.
         * @name module:jibo/sound.Sound#_context
         * @type {SoundContext}
         * @private
         */
        this._context = context;
        /**
         * Reference to the WebAudio API AudioContext.
         * @name module:jibo/sound.Sound#_ctx
         * @type {AudioContext}
         * @private
         */
        this._ctx = this._context.context;
        /**
         * Instance of the chain builder.
         * @name module:jibo/sound.Sound#_chain
         * @type {ChainBuilder}
         * @private
         */
        this._chain = new ChainBuilder_1.default(this._ctx)
            .bufferSource()
            .gainNode()
            .analyser()
            .panner();
        /**
         * true if the buffer is loaded.
         * @name module:jibo/sound.Sound#isLoaded
         * @type {Boolean}
         * @default false
         */
        this.isLoaded = false;
        /**
         * true if the sound is currently being played.
         * @name module:jibo/sound.Sound#isPlaying
         * @type {Boolean}
         * @default false
         * @readOnly
         */
        this.isPlaying = false;
        /**
         * true to start playing immediate after load.
         * @name module:jibo/sound.Sound#autoPlay
         * @type {Boolean}
         * @private
         * @default false
         * @readOnly
         */
        this.autoPlay = options.autoPlay;
        /**
         * true to block successive plays.
         * @name module:jibo/sound.Sound#block
         * @type {Boolean}
         * @default false
         */
        this.block = options.block;
        /**
         * true to immediately start preloading.
         * @name module:jibo/sound.Sound#preload
         * @type {Boolean}
         * @default false
         * @readOnly
         */
        this.preload = options.preload;
        /**
         * Callback when finished playing.
         * @name module:jibo/sound.Sound#complete
         * @type {module:jibo/sound.Sound~completeCallback}
         * @default false
         */
        this.complete = options.complete;
        /**
         * Callback when load is finished.
         * @type {module:jibo/sound.Sound~loadedCallback}
         * @name module:jibo/sound.Sound#loaded
         * @readOnly
         */
        this.loaded = options.loaded;
        /**
         * The file source to load.
         * @name module:jibo/sound.Sound#src
         * @type {String|ArrayBuffer}
         * @readOnly
         */
        this.src = options.src;
        /**
         * `true` to use XMLHttpRequest object to load.
         * Default is to use NodeJS's fs module to read the sound.
         * @name module:jibo/sound.Sound#useXHR
         * @type {Boolean}
         * @default false
         */
        this.useXHR = options.useXHR;
        /**
         * The collection of instances being played.
         * @name module:jibo/sound.Sound#_instances
         * @type {Array<SoundInstance>}
         * @private
         */
        this._instances = [];
        // connect this._chain.last() node to this._context._entryNode()
        this._chain.last().connect(this._context._entryNode());
        // create some alias
        this._source = this._chain.nodes().bufferSource;
        this._gainNode = this._chain.nodes().gainNode;
        this._analyser = this._chain.nodes().analyser;
        this._panner = this._chain.nodes().panner;
        // sanity check
        console.assert(this._source, "No bufferSource: not yet supported");
        console.assert(this._gainNode, "No gainNode: not yet supported");
        console.assert(this._analyser, "No analyser: not yet supported");
        console.assert(this._panner, "No panner: not yet supported");
        this.volume = options.volume;
        this.panning = options.panning;
        this.loop = options.loop;
        if (this.preload) {
            this._beginPreload();
        }
    }
    /**
     * Starts the preloading of sound.
     * @method module:jibo/sound.Sound#_beginPreload
     * @private
     */
    Sound.prototype._beginPreload = function () {
        // Load from the file path
        if (typeof this.src === "string") {
            this.useXHR ? this.loadUrl() : this.loadPath();
        }
        else if (this.src instanceof ArrayBuffer) {
            this.decode(this.src);
        }
        else if (this.loaded) {
            this.loaded(new Error("sound.src must be ArrayBuffer or string"));
        }
        else {
            console.error('sound.src must be ArrayBuffer or string');
        }
    };
    /**
     * Destructor, safer to use `SoundPlugin.remove(alias)` to remove this sound.
     * @private
     * @method module:jibo/sound.Sound#destroy
     */
    Sound.prototype.destroy = function () {
        // disconnect from this._context
        this._chain.last().disconnect();
        // destroy this._chain
        this._chain.destroy();
        this._chain = null;
        this._context = null;
        this._ctx = null;
        this._source = null;
        this._removeInstances();
        this._instances = null;
    };
    Object.defineProperty(Sound.prototype, "isPlayable", {
        get: function () {
            return this.isLoaded && !!this._source.buffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "nodes", {
        /**
         * Getter of the chain nodes.
         * @name module:jibo/sound.Sound#nodes
         * @type {Object}
         * @private
         * @readOnly
         */
        get: function () {
            return this._chain.nodes();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "volume", {
        /**
         * Gets and sets the volume.
         * @name module:jibo/sound.Sound#volume
         * @type {Number}
         */
        get: function () {
            return this._gainNode.gain.value;
        },
        set: function (volume) {
            this._gainNode.gain.value = volume;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "loop", {
        /**
         * Gets and sets the looping.
         * @name module:jibo/sound.Sound#loop
         * @type {Boolean}
         */
        get: function () {
            return this._source.loop;
        },
        set: function (loop) {
            this._source.loop = !!loop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "buffer", {
        /**
         * Gets and sets the buffer.
         * @name module:jibo/sound.Sound#buffer
         * @type {AudioBuffer}
         */
        get: function () {
            return this._source.buffer;
        },
        set: function (buffer) {
            this._source.buffer = buffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "panning", {
        /**
         * Gets and sets the panning -1 (full left pan) and 1 (full right pan).
         * @name module:jibo/sound.Sound#panning
         * @type {Number}
         * @default 0
         */
        get: function () {
            return this._panner.pan;
        },
        set: function (pan) {
            this._panner.pan.value = pan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sound.prototype, "instances", {
        /**
         * Gets the list of instances that are currently being played of this sound.
         * @name module:jibo/sound.Sound#instances
         * @type {Array<SoundInstance>}
         * @readOnly
         */
        get: function () {
            return this._instances;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Plays the sound.
     * @method module:jibo/sound.Sound#play
     * @param {module:jibo/sound.Sound~completeCallback|object} options Either completed function or play options.
     * @param {Number} [options.offset=0] time when to play the sound.
     * @param {module:jibo/sound.Sound~completeCallback} [options.complete] Callback when complete.
     * @param {module:jibo/sound.Sound~loadedCallback} [options.loaded] If the sound isn't already preloaded, callback when
     *        the audio has completely finished loading and decoded.
     * @return {SoundInstance} Current playing instance.
     */
    Sound.prototype.play = function (options) {
        var _this = this;
        if (typeof options === "function") {
            options = { complete: options };
        }
        options = Object.assign({
            complete: null,
            loaded: null,
            offset: 0
        }, options || {});
        // if not yet playable, ignore
        // - usefull when the sound download isnt yet completed
        if (!this.isPlayable) {
            this.autoPlay = true;
            if (!this.isLoaded) {
                var loaded = options.loaded;
                if (loaded) {
                    this.loaded = loaded;
                }
                this._beginPreload();
            }
            return;
        }
        // Stop all sounds
        if (this.block) {
            this._removeInstances();
        }
        // clone the bufferSource
        var instance = SoundInstance_1.default.create(this._chain);
        this._instances.push(instance);
        this.isPlaying = true;
        instance.once('complete', function () {
            _this._onComplete(instance);
            if (options.complete) {
                options.complete(_this);
            }
        });
        instance.play(options.offset);
        return instance;
    };
    /**
     * Sound instance completed.
     * @method module:jibo/sound.Sound#_onComplete
     * @private
     * @param {SoundInstance} instance
     */
    Sound.prototype._onComplete = function (instance) {
        if (this._instances) {
            var index = this._instances.indexOf(instance);
            if (index > -1) {
                this._instances.splice(index, 1);
            }
            this.isPlaying = this._instances.length > 0;
        }
        instance.destroy();
    };
    /**
     * Stops all the instances of this sound from playing.
     * @method module:jibo/sound.Sound#stop
     * @return {module:jibo/sound.Sound} Instance of this sound.
     */
    Sound.prototype.stop = function () {
        if (!this.isPlayable) {
            this.autoPlay = false;
            return this;
        }
        this.isPlaying = false;
        this._instances.forEach(function (instance) {
            instance.stop();
        });
        return this;
    };
    /**
     * Stops all the instances of this sound from playing.
     * @method module:jibo/sound.Sound#pause
     * @return {module:jibo/sound.Sound} Instance of this sound.
     */
    Sound.prototype.pause = function () {
        this._instances.forEach(function (instance) {
            instance.paused = true;
        });
        this.isPlaying = false;
        return this;
    };
    ;
    /**
     * Stops all the instances of this sound from playing
     * @method module:jibo/sound.Sound#stop
     * @return {module:jibo/sound.Sound} Instance of this sound.
     */
    Sound.prototype.resume = function () {
        this._instances.forEach(function (instance) {
            instance.paused = false;
        });
        this.isPlaying = this._instances.length > 0;
        return this;
    };
    /**
     * Removes all instances.
     * @method module:jibo/sound.Sound#_removeInstances
     * @private
     */
    Sound.prototype._removeInstances = function () {
        // destroying also stops
        this._instances.forEach(function (instance) {
            instance.destroy();
        });
        this._instances.length = 0;
    };
    /**
     * Loads a sound using XHMLHttpRequest object.
     * @method module:jibo/sound.Sound#loadUrl
     * @private
     */
    Sound.prototype.loadUrl = function () {
        var _this = this;
        var request = new XMLHttpRequest();
        request.open('GET', this.src, true);
        request.responseType = 'arraybuffer';
        // Decode asynchronously
        request.onload = function () {
            _this.isLoaded = true;
            _this.decode(request.response);
        };
        // actually start the request
        request.send();
    };
    /**
     * Loads using the file system (NodeJS's fs module).
     * @method module:jibo/sound.Sound#loadPath
     * @private
     */
    Sound.prototype.loadPath = function () {
        var _this = this;
        var fs = require('fs');
        fs.readFile(this.src, function (err, data) {
            if (err) {
                console.error(err);
                if (_this.loaded) {
                    _this.loaded(new Error("File not found " + _this.src));
                }
                return;
            }
            var arrayBuffer = new ArrayBuffer(data.length);
            var view = new Uint8Array(arrayBuffer);
            for (var i = 0; i < data.length; ++i) {
                view[i] = data[i];
            }
            _this.decode(arrayBuffer);
        });
    };
    /**
     * Decodes the array buffer.
     * @method module:jibo/sound.Sound#decode
     * @param {ArrayBuffer} arrayBuffer From load.
     * @private
     */
    Sound.prototype.decode = function (arrayBuffer) {
        var _this = this;
        this._ctx.decodeAudioData(arrayBuffer, function (buffer) {
            _this.isLoaded = true;
            _this.buffer = buffer;
            if (_this.loaded) {
                _this.loaded(null, _this);
            }
            if (_this.autoPlay) {
                _this.play(_this.complete);
            }
        }, function () {
            _this.loaded(new Error('Unable to decode file'));
        });
    };
    return Sound;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Sound;

//# sourceMappingURL=../map/sound/Sound.js.map
