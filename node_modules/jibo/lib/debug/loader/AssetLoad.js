"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var events_1 = require('events');
var Task_1 = require('./tasks/Task');
var AssetUtils_1 = require('./AssetUtils');
/**
 * Class that represents a single multi load.
 * @class AssetLoad
 * @memberof module:jibo/loader
 */
var AssetLoad = (function (_super) {
    __extends(AssetLoad, _super);
    /**
     * @constructor
     * @param {module:jibo/loader.AssetManager} manager Reference to the manager.
     */
    function AssetLoad(manager) {
        _super.call(this);
        /**
         * Reference to the Task Manager.
         * @type {module:jibo/loader.AssetManager}
         * @name module:jibo/loader.AssetLoad#manager
         */
        this.manager = manager;
        this.id = AssetLoad.ID++;
        /**
         * How to display the results, either as single (0), map (1) or list (2).
         * @type {int}
         * @name module:jibo/loader.AssetLoad#mode
         * @default 1
         */
        this.mode = MAP_MODE;
        /**
         * If we should run the tasks in parallel (`true`) or serial (`false`).
         * @type {Boolean}
         * @name module:jibo/loader.AssetLoad#startAll
         * @default true
         */
        this.startAll = true;
        /**
         * `true` if we should try to cache all items in the load.
         * @type {Boolean}
         * @name module:jibo/loader.AssetLoad#cacheAll
         * @default false
         */
        this.cacheAll = false;
        /**
         * The list of tasks to load.
         * @type {Array<module:jibo/loader.Task>}
         * @name module:jibo/loader.AssetLoad#tasks
         */
        this.tasks = [];
        /**
         * The results to return when we're done.
         * @type {Array|Object}
         * @name module:jibo/loader.AssetLoad#results
         */
        this.results = null;
        /**
         * `true` if the load is currently running.
         * @type {Boolean}
         * @name module:jibo/loader.AssetLoad#running
         * @default false
         */
        this.running = false;
        /**
         * The total number of assets loaded.
         * @type {int}
         * @name module:jibo/loader.AssetLoad#numLoaded
         * @default 0
         */
        this.numLoaded = 0;
        /**
         * The total number of assets.
         * @type {int}
         * @name module:jibo/loader.AssetLoad#total
         * @default 0
         */
        this.total = 0;
    }
    /**
     * When an asset is finished.
     * @event module:jibo/loader.AssetLoad#taskDone
     * @param {*} result The loader result.
     * @param {object} originalAsset The original load asset.
     * @param {array} assets Collection to add additional assets to.
     */
    /**
     * When all assets have been completely loaded.
     * @event module:jibo/loader.AssetLoad#complete
     * @param {Array|Object} results The results of load.
     */
    /**
     * Checks how many assets have finished loading.
     * @event module:jibo/loader.AssetLoad#progress
     * @param {number} percentage The amount loaded from 0 to 1.
     */
    /**
     * Debugging purposes.
     * @method module:jibo/loader.AssetLoad#toString
     * @return {String}
     */
    AssetLoad.prototype.toString = function () {
        return "[AssetLoad (index: " + this.id + ")]";
    };
    /**
     * Initializes the Load.
     * @method module:jibo/loader.AssetLoad#setup
     * @param {object|array} assets The collection of assets to load.
     * @param {object} [options] The loading options.
     * @param {Boolean} [options.startAll=true] `true` to start all load requests at once, false to start a chain of loads.
     * @param {Boolean} [options.autoStart=true] `true` to start running automatically.
     * @param {Boolean} [options.cacheAll=false] `true` to cache all load results, `false` to allow assets to cache themselves.
     */
    AssetLoad.prototype.setup = function (assets, options) {
        // Save options to load
        this.startAll = options.startAll;
        this.cacheAll = options.cacheAll;
        // Update the results mode and tasks
        this.mode = this.addTasks(assets);
        // Set the default container for the results
        this.results = this.getAssetsContainer(this.mode);
        // Start running
        if (options.autoStart) {
            this.start();
        }
    };
    /**
     * Starts the load process.
     * @method module:jibo/loader.AssetLoad#start
     */
    AssetLoad.prototype.start = function () {
        // Empty load percentage
        this.emit('progress', 0);
        // Keep track if we're currently running
        this.running = true;
        this.nextTask();
    };
    /**
     * Sets back to the original state.
     * @method module:jibo/loader.AssetLoad#reset
     */
    AssetLoad.prototype.reset = function () {
        this.removeAllListeners('complete');
        this.removeAllListeners('progress');
        this.removeAllListeners('taskDone');
        // Cancel any tasks
        this.tasks.forEach(function (task) {
            task.status = Task_1.default.FINISHED;
            task.destroy();
        });
        this.total = 0;
        this.numLoaded = 0;
        this.mode = MAP_MODE;
        this.tasks.length = 0;
        this.results = null;
        this.startAll = true;
        this.cacheAll = false;
        this.running = false;
    };
    /**
     * Creates a list of tasks from assets.
     * @method  module:jibo/loader.AssetLoad#addTasks
     * @private
     * @param  {Object|Array} assets The assets to load.
     */
    AssetLoad.prototype.addTasks = function (assets) {
        var asset;
        var mode = MAP_MODE;
        // Apply the defaults incase this is a single
        // thing that we're trying to load
        assets = this.applyDefaults(assets);
        var isSingle = this.getTaskByAsset(assets);
        if (isSingle) {
            this.addTask(assets);
            return SINGLE_MODE;
        }
        else {
            var task = void 0;
            if (Array.isArray(assets)) {
                for (var i = 0; i < assets.length; i++) {
                    asset = this.applyDefaults(assets[i]);
                    task = this.addTask(asset);
                    if (!task.id) {
                        // If we don't have the id to return
                        // a mapped result, we'll fallback to array results
                        mode = LIST_MODE;
                    }
                }
            }
            else if (AssetUtils_1.default.isPlain(assets)) {
                for (var id in assets) {
                    asset = this.applyDefaults(assets[id]);
                    asset.id = id;
                    task = this.addTask(asset);
                }
            }
            else {
                console.error("Asset type unsupported", asset);
            }
        }
        return mode;
    };
    /**
     * Converts assets into object defaults.
     * @method module:jibo/loader.AssetLoad#applyDefaults
     * @private
     * @static
     * @param  {*} asset The function to convert.
     * @return {Object} The object asset to use.
     */
    AssetLoad.prototype.applyDefaults = function (asset) {
        // convert to a LoadTask
        if (isString(asset)) {
            return {
                src: asset
            };
        }
        else if (isFunction(asset)) {
            return {
                async: asset
            };
        }
        return asset;
    };
    /**
     * Loads a single asset.
     * @method module:jibo/loader.AssetLoad#addTask
     * @private
     * @param {Object} asset The asset to load.
     *      Can either be an object, URL/path, or async function.
     * @return {Task} New task instance.
     */
    AssetLoad.prototype.addTask = function (asset) {
        var TaskClass = this.getTaskByAsset(asset);
        var task;
        if (TaskClass) {
            if (asset.cache === undefined && this.cacheAll) {
                asset.cache = true;
            }
            task = new TaskClass(this.manager, asset);
            this.tasks.push(task);
            ++this.total;
        }
        else {
            console.error("Unable to find a task definition for asset", asset);
        }
        return task;
    };
    /**
     * Gets the Task definition for an asset.
     * @method  module:jibo/loader.AssetLoad#getTaskByAsset
     * @private
     * @static
     * @param  {Object} asset The asset to check.
     * @return {Function} The Task class.
     */
    AssetLoad.prototype.getTaskByAsset = function (asset) {
        var TaskClass;
        var taskDefs = this.manager.taskDefs;
        // Loop backwards to get the registered tasks first
        // then will default to the basic Loader task
        for (var i = 0, len = taskDefs.length; i < len; i++) {
            TaskClass = taskDefs[i];
            if (TaskClass.test(asset)) {
                return TaskClass;
            }
        }
        return null;
    };
    /**
     * Runs the next task that's waiting.
     * @method  module:jibo/loader.AssetLoad#nextTask
     * @private
     */
    AssetLoad.prototype.nextTask = function () {
        var tasks = this.tasks;
        for (var i = 0; i < tasks.length; i++) {
            var task = tasks[i];
            if (task.status === Task_1.default.WAITING) {
                task.status = Task_1.default.RUNNING;
                task.start(this.taskDone.bind(this, task));
                // If we aren't running in parallel, then stop
                if (!this.startAll) {
                    return;
                }
            }
        }
    };
    /**
     * Handler when a task has completed.
     * @method  module:jibo/loader.AssetLoad#taskDone
     * @private
     * @param  {Task} task Reference to original task.
     * @param {LoaderError} err The error thrown by load.
     * @param  {*} [result] The result of load.
     */
    AssetLoad.prototype.taskDone = function (task, err, result) {
        if (result === void 0) { result = null; }
        // Ignore if we're destroyed
        if (!this.running) {
            return;
        }
        var index = this.tasks.indexOf(task);
        // Task was already removed, because a clear
        if (index === -1) {
            return;
        }
        // Remove the completed task
        this.tasks.splice(index, 1);
        // Assets
        var assets = [];
        // Handle the file load tasks
        if (result) {
            // Handle the result
            switch (this.mode) {
                case SINGLE_MODE:
                    this.results = result;
                    break;
                case LIST_MODE:
                    this.results.push(result);
                    break;
                case MAP_MODE:
                    this.results[task.id] = result;
                    break;
            }
            // Should we cache the task?
            if (task.cache) {
                this.manager.cache.write(task.id, result);
            }
        }
        // If the task has a complete method
        // we'll make sure that gets called
        // with a reference to the tasks
        // can potentially add more
        if (task.complete) {
            task.complete(err, result, task.original, assets);
        }
        if (!err) {
            this.emit('taskDone', result, task.original, assets);
        }
        task.destroy();
        // Add new assets to the things to load
        var mode = this.addTasks(assets);
        // Update the progress total
        this.emit('progress', ++this.numLoaded / this.total);
        // Check to make sure if we're in
        // map mode, we keep it that way
        if (this.mode === MAP_MODE && mode !== this.mode) {
            console.error("Load assets require IDs to return mapped results", assets);
            return;
        }
        // There was an error, pass it along
        if (err) {
            console.error('Unable to load asset', task.original);
            this.emit('complete', err, null);
            return;
        }
        if (this.tasks.length) {
            // Run the next task
            this.nextTask();
        }
        else {
            // We're finished!
            this.emit('complete', err, this.results);
        }
    };
    /**
     * Gets an empty assets collection.
     * @method module:jibo/loader.AssetLoad#getAssetsContainer
     * @private
     * @param {int} mode The mode.
     * @return {Array|Object|null} Empty container for assets.
     */
    AssetLoad.prototype.getAssetsContainer = function (mode) {
        switch (mode) {
            case SINGLE_MODE:
                return null;
            case LIST_MODE:
                return [];
            case MAP_MODE:
                return {};
        }
    };
    /**
     * Destroys this and discards.
     * @private
     * @method module:jibo/loader.AssetLoad#destroy
     */
    AssetLoad.prototype.destroy = function () {
        this.removeAllListeners();
        this.reset();
        this.tasks = null;
        this.manager = null;
    };
    return AssetLoad;
}(events_1.EventEmitter));
/**
 * The result is a single result.
 * @property {int} module:jibo/loader.AssetLoad.SINGLE_MODE
 * @private
 * @final
 * @static
 * @default 0
 */
var SINGLE_MODE = 0;
/**
 * The result is a map of result objects.
 * @property {int} module:jibo/loader.AssetLoad.MAP_MODE
 * @private
 * @final
 * @static
 * @default 1
 */
var MAP_MODE = 1;
/**
 * The result is an array of result objects.
 * @property {int} module:jibo/loader.AssetLoad.LIST_MODE
 * @private
 * @final
 * @static
 * @default 2
 */
var LIST_MODE = 2;
/**
 * Checks if an object is a String type.
 * @method module:jibo/loader.AssetLoad.isString
 * @private
 * @param  {*}  obj The object to check.
 * @return {Boolean} `true` if object is a String, `false` otherwise.
 */
function isString(obj) {
    return typeof obj === "string";
}
/**
 * Checks if an object is a function type.
 * @method module:jibo/loader.AssetLoad.isFunction
 * @private
 * @param  {*}  obj The object to check.
 * @return {Boolean} `true` if object is a function, `false` otherwise.
 */
function isFunction(obj) {
    return typeof obj === "function";
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AssetLoad;

//# sourceMappingURL=../map/loader/AssetLoad.js.map
