"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var DelayedCall_1 = require('./DelayedCall');
var events_1 = require('events');
/**
 * @description
 * Handles the update loop and timing events.
 * ```
 * let jibo = require('jibo');
 * jibo.timer.on('update', (elapsed) => {
 *     // do update
 * });
 * ```
 * @module jibo/timer
 */
var Timer = (function (_super) {
    __extends(Timer, _super);
    function Timer() {
        _super.call(this);
        this.update = this.update.bind(this);
        this._paused = true;
    }
    /**
     * Fires when timer pause state changes.
     * @event module:jibo/timer#pause
     * @param {boolean} pause true if currently paused, false if resumed from stop.
     */
    /**
     * Fires when sound is resumed.
     * @event module:jibo/timer#resumed
     */
    /**
     * Fires when sound is paused.
     * @event module:jibo/timer#paused
     */
    /**
     * Fires every requestAnimationFrame. Should be considered
     * the main update "loop." All skills should use this for frame updates.
     * @event module:jibo/timer#update
     * @param {int} elapse The time in milliseconds since the last frame update.
     */
    /**
     * Starts the update loop.
     * @method module:jibo/timer#start
     */
    Timer.prototype.start = function () {
        if (this._paused) {
            this.emit('pause', false);
            this.emit('resumed');
            this._paused = false;
            this._lastUpdate = performance.now();
            this.update();
        }
    };
    /**
     * Stops the update loop.
     * @method module:jibo/timer#stop
     */
    Timer.prototype.stop = function () {
        if (!this._paused) {
            this.emit('pause', true);
            this.emit('paused');
            this._paused = true;
            if (this._frameRequest) {
                cancelAnimationFrame(this._frameRequest);
                this._frameRequest = null;
            }
        }
    };
    /**
     * Updates loop callback.
     * @method module:jibo/timer#update
     * @private
     */
    Timer.prototype.update = function () {
        if (this._paused) {
            return;
        }
        var now = performance.now();
        var elapsed = now - this._lastUpdate;
        this.emit('update', elapsed);
        this._lastUpdate = now;
        this._frameRequest = requestAnimationFrame(this.update);
    };
    Object.defineProperty(Timer.prototype, "paused", {
        /**
         * Pauses loop callback.
         * @name module:jibo/timer#paused
         * @type {Boolean}
         * @readOnly
         */
        get: function () {
            return this._paused;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Works just like `window.setTimeout` but respects the pause.
     * state of jibo.timer.
     * @method  module:jibo/timer#setTimeout
     * @param {Function} callback    The callback function, passes one argument which is the DelayedCall instance.
     * @param {int}   delay       The time in milliseconds or the number of frames (useFrames must be true).
     * @param {Boolean}   [useFrames=false]   If the delay is frames (true) or milliseconds (false).
     * @param {Boolean}   [autoDestroy=true] If the DelayedCall object should be destroyed after completing.
     * @return {module:jibo/timer.DelayedCall} The object for pausing, restarting, destroying etc.
     */
    Timer.prototype.setTimeout = function (callback, delay, useFrames, autoDestroy) {
        if (useFrames === void 0) { useFrames = false; }
        if (autoDestroy === void 0) { autoDestroy = true; }
        return new DelayedCall_1.default(this, callback, delay, {
            repeat: false,
            autoDestroy: autoDestroy,
            useFrames: useFrames
        });
    };
    /**
     * Works just like `window.setInterval` but respects the pause.
     * state of jibo.timer.
     * @method  module:jibo/timer#setInterval
     * @param {Function} callback    The callback function, passes one argument which is the DelayedCall instance.
     * @param {int}   delay       The time in milliseconds or the number of frames (useFrames must be true).
     * @param {Boolean}   [useFrames=false]   If the delay is frames (true) or milliseconds (false).
     * @return {module:jibo/timer.DelayedCall} The object for pausing, restarting, destroying etc.
     */
    Timer.prototype.setInterval = function (callback, delay, useFrames) {
        if (useFrames === void 0) { useFrames = false; }
        return new DelayedCall_1.default(this, callback, delay, {
            repeat: true,
            autoDestroy: false,
            useFrames: useFrames
        });
    };
    /**
     * Destroys the timer object.
     * @method module:jibo/timer#destroy
     * @private
     */
    Timer.prototype.destroy = function () {
        this.removeAllListeners();
        this.stop();
    };
    return Timer;
}(events_1.EventEmitter));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Timer;

//# sourceMappingURL=../map/utils/Timer.js.map
