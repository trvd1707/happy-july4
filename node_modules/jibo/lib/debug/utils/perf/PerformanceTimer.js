"use strict";
/*
 * Basic timer timing functions.
 */
var assert = require('assert');
/*
 * Fallback to using Date.now if performance object doesn't exist. This makes it easier
 * to test this module in pure node which doesn't have the performance API.
 */
var TimerTypes = {
    SERIAL: "SERIAL",
    PARALLEL: "PARALLEL"
};
/**
 * Base Timer for measuring performance.
 * @class PerformanceTimer
 * @memberof module:jibo/utils/perf
 * @private
 */
var PerformanceTimer = (function () {
    function PerformanceTimer(name, type, parent) {
        this.name = name;
        this.type = type;
        this.parent = parent;
        this.start = this.now();
        this.children = [];
        // Add our selves to the parent if one was provided
        if (this.parent) {
            this.parent.children.push(this);
        }
    }
    Object.defineProperty(PerformanceTimer, "TimerTypes", {
        get: function () {
            return TimerTypes;
        },
        enumerable: true,
        configurable: true
    });
    PerformanceTimer.prototype.stop = function () {
        assert(!this.end, "PerformanceTimer.stop() was called twice.");
        this.end = this.now();
    };
    PerformanceTimer.prototype.getTimings = function () {
        assert(this !== null, "PerformanceTimer.printTimings() called without there being any timing data");
        // Defer string build up to recursive private function
        return _getTimings(this, "");
    };
    /*
     * Get a reference to the performance timer API or it's fallback. We do this
     * this dynamically to make it easier to mockup the timer in the matching tests
     * for this module which uses sinon for mocks, which doesn't have support for replacing
     * the performance.* APIs, but does for the Date.now() function. The performance API
     * doesn't exist in pure node, so we have to replace performance.now with Date.now anyway.
     */
    PerformanceTimer.prototype.now = function () {
        return typeof performance !== 'undefined' ?
            performance.now() : Date.now();
    };
    return PerformanceTimer;
}());
function _getTimings(parentTimer, indentLevel) {
    // To help know which type a timer is we mark them as following:
    // SerialTimer      = "-"
    // ParallelTimer    = "~"
    // TopLevelTimer    = " "
    var timerTypeSymbol = '-';
    if (!parentTimer.parent) {
        timerTypeSymbol = " ";
    }
    else if (parentTimer.parent.type === TimerTypes.PARALLEL) {
        timerTypeSymbol = "~";
    }
    var output = "";
    output += "" + indentLevel + timerTypeSymbol + " \"" + parentTimer.name + "\" " + (parentTimer.end - parentTimer.start).toFixed(1) + "ms\n";
    // Sort the children of parallel timers by their duration to make it easier
    // to see the worst offenders that causes the overall completion time.
    // We don't do the same for serial timers as their ordering is meaningful
    if (parentTimer.type === TimerTypes.PARALLEL) {
        parentTimer.children.sort(function (a, b) {
            return (a.end - a.start) < (b.end - b.start);
        });
    }
    parentTimer.children.forEach(function (childTimer) {
        output += _getTimings(childTimer, indentLevel + "\t");
    });
    return output;
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PerformanceTimer;

//# sourceMappingURL=../../map/utils/perf/PerformanceTimer.js.map
