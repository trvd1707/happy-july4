"use strict";
/**
 * A class for delaying a call through the application, instead of relying on setInterval() or
 * setTimeout().
 *
 * @class DelayedCall
 * @memberof module:jibo/timer
 * @constructor
 * @param {function} callback The function to call when the delay has completed.
 * @param {int} delay The time to delay the call, in milliseconds (or optionally frames).
 * @param {Object|Boolean} [options=false] The options to use or repeat value.
 * @param {Boolean} [options.repeat=false] `true` if the DelayedCall should automatically repeat itself when
 *                              completed.
 * @param {Boolean} [options.autoDestroy=true] `true` if the DelayedCall should clean itself up when completed.
 * @param {Boolean} [options.useFrames=false] `true` if the DelayedCall should use frames instead of
 *                                 milliseconds for the delay.
 */
var DelayedCall = (function () {
    function DelayedCall(parent, callback, delay, options) {
        // Set the default options
        options = Object.assign({
            repeat: false,
            autoDestroy: true,
            useFrames: false
        }, options || {});
        /**
         * The root timer.
         * @private
         * @type {Timer}
         * @name module:jibo/timer.DelayedCall#parent
         */
        this.parent = parent;
        /**
         * The function to call when the delay is completed.
         * @private
         * @type {function}
         * @name module:jibo/timer.DelayedCall#_callback
         */
        this._callback = callback;
        /**
         * The delay time, in milliseconds.
         * @private
         * @type {int}
         * @name module:jibo/timer.DelayedCall#_delay
         */
        this._delay = delay;
        /**
         * The timer counting down from _delay, in milliseconds.
         * @private
         * @type {int}
         * @name module:jibo/timer.DelayedCall#_timer
         */
        this._timer = delay;
        /**
         * `true` if the DelayedCall should repeat itself automatically.
         * @private
         * @type {Boolean}
         * @name module:jibo/timer.DelayedCall#_repeat
         * @default false
         */
        this._repeat = !!options.repeat;
        /**
         * `true` if the DelayedCall should destroy itself after completing
         * @private
         * @type {Boolean}
         * @name module:jibo/timer.DelayedCall#_autoDestroy
         * @default true
         */
        this._autoDestroy = !!options.autoDestroy;
        /**
         * `true` if the DelayedCall should use frames instead of milliseconds for the delay.
         * @private
         * @type {Boolean}
         * @name module:jibo/timer.DelayedCall#_useFrames
         * @default false
         */
        this._useFrames = !!options.useFrames;
        /**
         * `true` if the DelayedCall is currently paused (not stopped).
         * @private
         * @type {Boolean}
         * @name module:jibo/timer.DelayedCall#_paused
         */
        this._paused = false;
        //save a bound version of the update function
        this._update = this.update.bind(this);
        //start the delay
        this.enabled = true;
    }
    /**
     * The callback supplied to the Application for an update each frame.
     * @private
     * @method module:jibo/timer.DelayedCall#update
     * @param {int} elapsed The time elapsed since the previous frame.
     */
    DelayedCall.prototype.update = function (elapsed) {
        if (!this._callback) {
            this.destroy();
            return;
        }
        this._timer -= this._useFrames ? 1 : elapsed;
        if (this._timer <= 0) {
            this._callback(this);
            if (this._repeat) {
                this._timer += this._delay;
            }
            else if (this._autoDestroy) {
                this.destroy();
            }
            else {
                this.enabled = false;
            }
        }
    };
    ;
    /**
     * Restarts the DelayedCall, whether it is running or not.
     * @method module:jibo/timer.DelayedCall#restart
     */
    DelayedCall.prototype.restart = function () {
        if (!this._callback) {
            return;
        }
        if (!this.enabled) {
            this.enabled = true;
        }
        this._timer = this._delay;
        this._paused = false;
    };
    /**
     * Stops the DelayedCall, without destroying it.
     * @method module:jibo/timer.DelayedCall#stop
     */
    DelayedCall.prototype.stop = function () {
        this.enabled = false;
        this._paused = false;
    };
    Object.defineProperty(DelayedCall.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        /**
         * `true` if enabled for updates, `false` otherwise.
         * @private
         * @type {Boolean}
         * @name module:jibo/timer.DelayedCall#enabled
         */
        set: function (value) {
            this._enabled = value;
            this.parent.removeListener('update', this._update);
            if (value) {
                this.parent.on('update', this._update);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelayedCall.prototype, "paused", {
        /**
         * `true` if the DelayedCall is paused, `false` otherwise.
         * @type {Boolean}
         * @name module:jibo/timer.DelayedCall#paused
         */
        get: function () {
            return this._paused;
        },
        set: function (value) {
            if (!this._callback) {
                return;
            }
            if (this._paused && !value) {
                this._paused = false;
                if (!this.enabled) {
                    this.enabled = true;
                }
            }
            else if (value) {
                if (this.enabled) {
                    this._paused = true;
                    this.enabled = false;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stops and cleans up the DelayedCall. Do not use it after calling.
     * destroy().
     * @method module:jibo/timer.DelayedCall#destroy
     */
    DelayedCall.prototype.destroy = function () {
        this.stop();
        this._callback = null;
    };
    ;
    return DelayedCall;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DelayedCall;

//# sourceMappingURL=../map/utils/DelayedCall.js.map
