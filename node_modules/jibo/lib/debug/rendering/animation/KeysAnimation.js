"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var events_1 = require('events');
/**
 * A layer of the KeysAnimation class.
 * @class Layer
 * @private
 */
var Layer = (function () {
    function Layer(layerNum, name, instance) {
        if (instance === void 0) { instance = null; }
        this.layerNum = layerNum;
        this.name = name;
        this.instance = instance;
    }
    Object.defineProperty(Layer.prototype, "isEye", {
        get: function () {
            return this.name === Layer.EYE;
        },
        enumerable: true,
        configurable: true
    });
    Layer.prototype.destroy = function () {
        this.instance = null;
    };
    Layer.EYE = 'Eye';
    return Layer;
}());
/**
 * Class used by Animation Utilities to provide playback
 * of keys files.
 * @class KeysAnimation
 * @memberof module:jibo/rendering/animation
 * @extends EventEmitter
 * @param {module:jibo/rendering/animation.FaceRenderer} renderer The face renderer.
 */
var KeysAnimation = (function (_super) {
    __extends(KeysAnimation, _super);
    function KeysAnimation(renderer) {
        _super.call(this);
        this.renderer = renderer;
        this.layers = [];
        this.animationNum = 0;
        this.timelines = {};
        this.sounds = {};
        // Bind event callbacks
        this.onPlayTimeline = this.onPlayTimeline.bind(this);
        this.onBuilderStopped = this.onBuilderStopped.bind(this);
        this.onPlayAudio = this.onPlayAudio.bind(this);
        this.onEvent = this.onEvent.bind(this);
    }
    Object.defineProperty(KeysAnimation.prototype, "builder", {
        get: function () {
            return this._builder;
        },
        /**
         * The animation builder.
         * @name module:jibo/rendering/animation.KeysAnimation#builder
         * @type {Builder}
         * @private
         */
        set: function (builder) {
            if (this._builder) {
                this._builder.off(KeysAnimation.PLAY_AUDIO, this.onPlayAudio);
                this._builder.off(KeysAnimation.PLAY_TIMELINE, this.onPlayTimeline);
                this._builder.off(KeysAnimation.STOPPED, this.onBuilderStopped);
                this._builder.off(KeysAnimation.EVENT, this.onEvent);
                this._builder.off(KeysAnimation.CANCELLED, this.onEvent);
                this._builder.off(KeysAnimation.STARTED, this.onEvent);
            }
            this._builder = builder;
            if (builder) {
                builder.on(KeysAnimation.PLAY_AUDIO, this.onPlayAudio);
                builder.on(KeysAnimation.STOPPED, this.onBuilderStopped);
                builder.on(KeysAnimation.PLAY_TIMELINE, this.onPlayTimeline);
                builder.on(KeysAnimation.EVENT, this.onEvent);
                builder.on(KeysAnimation.CANCELLED, this.onEvent);
                builder.on(KeysAnimation.STARTED, this.onEvent);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeysAnimation.prototype, "data", {
        get: function () {
            return this._data;
        },
        /**
         * Set the keys animation data.
         * @name module:jibo/rendering/animation.KeysAnimation#data
         * @type {Object}
         * @private
         */
        set: function (data) {
            for (var i = 0; i < data.layers.length; i++) {
                if (data.layers[i].type === Layer.EYE) {
                    this.layers.push(new Layer(i, Layer.EYE));
                    break;
                }
            }
            this._data = data;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reset the animation and reorder.
     * @method module:jibo/rendering/animation.KeysAnimation#reset
     */
    KeysAnimation.prototype.reset = function () {
        this.data = this._data;
        this.reorder();
    };
    /**
     * Adds a sound to the animation for playing.
     * @method module:jibo/rendering/animation.KeysAnimation#addSound
     * @param {String} id The ID of the sound
     * @param {module:jibo/sound.Sound} sound Instance of sound.
     */
    KeysAnimation.prototype.addSound = function (id, sound) {
        this.sounds[id] = sound;
    };
    /**
     * Adds a timeline to the animation for playing.
     * @method module:jibo/rendering/animation.KeysAnimation#addTimeline
     * @param {String} id The ID of the timeline
     * @param {module:jibo/rendering/animation.Timeline} timeline Instance of timeline.
     */
    KeysAnimation.prototype.addTimeline = function (id, timeline) {
        this.animationNum++;
        this.timelines[id] = timeline;
    };
    /**
     * Destroys the keys animation completely.
     * @method module:jibo/rendering/animation.KeysAnimation#destroy
     */
    KeysAnimation.prototype.destroy = function () {
        this.layers.forEach(function (layer) {
            layer.destroy();
        });
        for (var id in this.timelines) {
            this.timelines[id].destroy();
        }
        for (var id in this.sounds) {
            this.sounds[id].destroy();
        }
        this.builder = null;
        this.renderer.reset();
        this.renderer = null;
        this.layers = null;
        this.timelines = null;
        this.sounds = null;
    };
    /**
     * Handles animation custom events.
     * @method module:jibo/rendering/animation.KeysAnimation#onEvent
     * @private
     * @param {String} event
     * @param {AnimationInst} animInstance
     * @param {Object} playload
     */
    KeysAnimation.prototype.onEvent = function (event, animInstance, payload) {
        this.emit(event, event, animInstance, payload);
        var eventName = payload.eventName;
        this.emit(eventName, eventName, animInstance, payload.payload);
    };
    /**
     * Handles playing audio within the animation.
     * @method module:jibo/rendering/animation.KeysAnimation#onPlayAudio
     * @private
     * @param {String} event
     * @param {AnimationInst} animInstance
     * @param {Object} playload
     */
    KeysAnimation.prototype.onPlayAudio = function (event, animInstance, payload) {
        this.sounds[payload.file].play();
        this.emit(event, event, animInstance, payload);
    };
    /**
     * Handles animation stopped playing.
     * @method module:jibo/rendering/animation.KeysAnimation#onBuilderStopped
     * @private
     * @param {String} event
     * @param {AnimationInst} animInstance
     * @param {Object} playload
     */
    KeysAnimation.prototype.onBuilderStopped = function (event, animInstance, payload) {
        this.renderer.renderOnlyWhenDirty = true;
        this.renderer.reset();
        this.emit(event, event, animInstance, payload);
    };
    /**
     * Reorder the layers of the animation.
     * @method module:jibo/rendering/animation.KeysAnimation#reorder
     * @private
     */
    KeysAnimation.prototype.reorder = function () {
        var _this = this;
        // Turn the render back to what it was before we added to it
        this.renderer.reset();
        // Sort the layers by depth
        this.layers = this.layers.sort(function (a, b) {
            return a.layerNum - b.layerNum;
        });
        // Keep track if we should place object above or below the eye
        var aboveEye = false;
        this.layers.forEach(function (layer) {
            if (layer.isEye) {
                aboveEye = true;
            }
            else {
                if (aboveEye) {
                    _this.renderer.addChildAboveEye(layer.instance);
                }
                else {
                    _this.renderer.addChildBelowEye(layer.instance);
                }
            }
        });
    };
    /**
     * Handles the playing of a timeline event.
     * @method module:jibo/rendering/animation.KeysAnimation#onPlayTimeline
     * @private
     * @param {String} event
     * @param {AnimationInst} animInstance
     * @param {Object} playload
     */
    KeysAnimation.prototype.onPlayTimeline = function (event, animInstance, payload) {
        this.renderer.renderOnlyWhenDirty = false;
        var timeline = this.timelines[payload.file];
        if (!timeline) {
            throw new Error("No timeline matching " + payload.file);
        }
        var layer = new Layer(payload.layerNum, payload.file, timeline.instance);
        timeline.instance.play();
        this.layers.push(layer);
        this.reorder();
        this.emit(event, event, animInstance, payload);
    };
    /**
     * Event name when animation starts.
     * @name module:jibo/rendering/animation.KeysAnimation.STARTED
     * @type {String}
     */
    KeysAnimation.STARTED = 'STARTED';
    /**
     * Event name when animation stops.
     * @name module:jibo/rendering/animation.KeysAnimation.STOPPED
     * @type {String}
     */
    KeysAnimation.STOPPED = 'STOPPED';
    /**
     * Event name when builder event is fired.
     * @name module:jibo/rendering/animation.KeysAnimation.EVENT
     * @type {String}
     */
    KeysAnimation.EVENT = 'EVENT';
    /**
     * Event name when animation is cancelled.
     * @name module:jibo/rendering/animation.KeysAnimation.CANCELLED
     * @type {String}
     */
    KeysAnimation.CANCELLED = 'CANCELLED';
    /**
     * Event name when audio is played.
     * @name module:jibo/rendering/animation.KeysAnimation.PLAY_AUDIO
     * @type {String}
     */
    KeysAnimation.PLAY_AUDIO = 'play-audio';
    /**
     * Event name when timeline is played.
     * @name module:jibo/rendering/animation.KeysAnimation.PLAY_TIMELINE
     * @type {String}
     */
    KeysAnimation.PLAY_TIMELINE = 'play-pixi';
    return KeysAnimation;
}(events_1.EventEmitter));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = KeysAnimation;

//# sourceMappingURL=../../map/rendering/animation/KeysAnimation.js.map
