"use strict";
var animation_utilities_1 = require("animation-utilities");
var path = require('path');
var fs = require('fs');
var async = require('async');
var LoaderPlugin_1 = require('./loader/LoaderPlugin');
var SoundPlugin_1 = require('./sound/SoundPlugin');
var GlobalPerfTimer_1 = require('./utils/perf/GlobalPerfTimer');
var SerialTimer_1 = require('./utils/perf/SerialTimer');
var ParallelTimer_1 = require('./utils/perf/ParallelTimer');
var ipc = null;
try {
    ipc = require('ipc');
}
catch (e) {
    console.warn("Not running inside Electron");
}
/**
 * The Jibo SDK singleton.
 * @prop {module:jibo/animate} animate Jibo's animation and IK systems.
 * @prop {module:jibo/asr} asr Automatic Speech Recognition (embedded recognition).
 * @prop {module:jibo/body} body Non-motion related body services.
 * @prop {module:jibo/bt} bt SDK behaviors.
 * @prop {module:jibo/lps} lps Jibo's Local Perceptual Space.
 * @prop {module:jibo/nlu} nlu Natural Language Understanding (cloud recognition).
 * @prop {module:jibo/tts} tts Text-to-speech.
 * @prop {module:jibo/audio} audio Jibo's audio system.
 * @prop {module:jibo/timer} timer Jibo's main update loop.
 * @prop {module:jibo/face} face API to jibo's face.
 * @prop {module:jibo/sound} sound Manage playback of audio media.
 * @module jibo
 */
var Runtime = (function () {
    function Runtime(jibo) {
        var _this = this;
        // Make sure there isn't a singleton already created, or warn
        if (GLOBAL.jibo) {
            throw new Error("Jibo Singleton may only be initialized once.");
        }
        // Assign as global singleton to the global space
        GLOBAL.jibo = this;
        // Pass in class references
        this.utils = jibo.utils;
        this.services = jibo.services;
        // Services
        this.animate = animation_utilities_1.animate.createAnimationUtilities();
        this.asr = new jibo.services.asr.ASRService();
        this.bt = new jibo.bt.Factory(jibo.bt);
        this.nlu = new jibo.services.NLUService();
        this.lps = new jibo.services.LPSService();
        this.tts = new jibo.services.TTSService();
        this.body = new jibo.services.BodyService();
        this.audio = new jibo.services.AudioService();
        this.timer = new jibo.utils.Timer();
        this.loader = new LoaderPlugin_1.default();
        this.face = new jibo.rendering.FaceRenderer(this.timer);
        this.sound = new SoundPlugin_1.default();
        // Add tasks from other modules
        this.loader.register(jibo.sound.tasks.SoundTask, 50)
            .register(jibo.rendering.tasks.ColorAlphaTask, 40)
            .register(jibo.rendering.tasks.TimelineTask, 60)
            .register(jibo.rendering.tasks.ShapesTask, 70)
            .register(jibo.rendering.tasks.KeysTask, 80)
            .register(jibo.rendering.tasks.SpritesheetTask, 90)
            .register(jibo.rendering.tasks.TextureTask, 30);
        /** For the SDK tool */
        this.FaceRenderer = jibo.rendering.FaceRenderer;
        this.rendering = jibo.rendering;
        /**
         * @name module:jibo#session
         * @type {SessionManager}
         * @private
         */
        this.session = new jibo.services.SessionManager();
        /**
         * @name module:jibo#systemManager
         * @type {SystemManager}
         * @private
         */
        this.systemManager = new jibo.services.SystemManager();
        /**
         * @name module:jibo#behaviorEmitter
         * @type {BehaviorEmitter}
         * @private
         */
        this.behaviorEmitter = new jibo.bt.BehaviorEmitter();
        /**
         * @name module:jibo#visualize
         * @type {Object}
         * @private
         */
        this.visualize = animation_utilities_1.visualize;
        /**
         * Initialization options
         * @name module:jibo#options
         * @type {Object}
         * @private
         */
        this.options = null;
        /**
         * The map of service calls to init
         * @name module:jibo#_serviceInit
         * @type {Object}
         * @private
         */
        this._serviceInit = {
            tts: function (service, cb) {
                _this.tts.init(service, cb);
            },
            lps: function (service, cb) {
                _this.lps.init(service, cb);
            },
            body: function (service, cb) {
                var uri = "ws:" + service.host + ":" + service.port;
                var bodyOutput = new animation_utilities_1.body.BodyPosVelOutput(_this.visualize.timeline.getClock(), _this.visualize.robotInfo, uri, true, 33);
                _this.visualize.timeline.addOutput(bodyOutput, null);
                var ledOutput = new animation_utilities_1.LEDOutput(_this.visualize.timeline.getClock(), _this.visualize.robotInfo, uri, true, 33);
                _this.visualize.timeline.addOutput(ledOutput, null);
                _this.body.init(service, cb);
            },
            nlu: function (service, cb) {
                _this.nlu.init(service, cb);
            },
            asr: function (service, cb) {
                _this.asr.init(service, cb);
            },
            systemManager: function (service, cb) {
                _this.systemManager.init(service, cb);
            },
            audio: function (service, cb) {
                _this.audio.init(service, cb);
            }
        };
    }
    Runtime.prototype.requireAssetPack = function (assetPackPackage) {
        if (fs.existsSync(assetPackPackage)) {
            var pj = require(assetPackPackage);
            if (pj.jibo && pj.jibo.type === "asset-pack") {
                var main = path.resolve(path.parse(assetPackPackage).dir, pj.main);
                return require(main);
            }
        }
    };
    /**
     * @description
     * Initializes the jibo SDK.
     *
     * ```
     * let jibo = require('jibo');
     * jibo.init('face', (e) => {
     *    if (e) return console.error(e);
     *    // Setup!
     * });
     * ```
     * @method module:jibo#init
     * @param {Object|Function|String|HTMLElement} [options] Either the options, canvas DOM ID or DOM Element for canvas or callback
     * @param {DOMElement|String} [options.display] Either the canvas DOM or DOM ID
     * @param {Function} [callback] Called when the SDK is finished initializing.
     */
    Runtime.prototype.init = function (options, cb) {
        var _this = this;
        // Support for old-style init(callback)
        if (typeof options === 'function') {
            cb = options;
            options = null;
        }
        else if (typeof options === 'string' || options instanceof HTMLElement) {
            options = { display: options };
        }
        // Save options with defaults
        this.options = Object.assign({
            display: null
        }, options || {});
        if (typeof cb === 'function') {
            this._init(cb);
        }
        else {
            // Deprecate this, use direct callback
            return new Promise(function (resolve, reject) {
                _this._init(function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
    };
    Runtime.prototype._init = function (callback) {
        var _this = this;
        if (Runtime.isInitializing || Runtime.isInitialized) {
            throw new Error('Jibo Singleton may only be initialized once.');
        }
        Runtime.isInitializing = true;
        var initNetworkServices = function (done) {
            _this.initNetworkServices(done);
        };
        var initAnimate = function (done) {
            var initAnimateTimer = new SerialTimer_1.default("initAnimate", GlobalPerfTimer_1.default.get());
            _this.utils.AnimationUtils.init(_this.animate, function () {
                initAnimateTimer.stop();
                done.apply(this, arguments);
            });
        };
        async.series([initAnimate, initNetworkServices], function (err) {
            if (err) {
                // add splash on top of everything to say what the error was
                var div = "<div style=\"position:absolute;top:0px;left:0px;width:100%;height:100%;z-index:999999;background:#a7a7a7;text-align:center;\">";
                div += "<span style=\"position:absolute;top:250px;left:0px;font-size:44px;font-weight:bold;font-family:Arial;color:#c50000;padding:20px;\">" + err + "</span>";
                div += "</div>";
                document.body.innerHTML += div;
                callback(err);
            }
            else {
                var display = _this.options.display;
                if (display) {
                    if (typeof display === "string") {
                        display = document.getElementById(display);
                    }
                    if (!display) {
                        throw new Error("Display canvas element is invalid");
                    }
                    _this.visualize.createFaceRenderer(display);
                }
                Runtime.isInitialized = true;
                _this.timer.start();
                callback();
            }
        });
    };
    Runtime.prototype.initNetworkServices = function (done) {
        var _this = this;
        var registryHost;
        var services;
        var initNetworkServicesTimer = new SerialTimer_1.default("initNetworkServices", GlobalPerfTimer_1.default.get());
        async.series([
            // Get registry host and session token
            function (cb) {
                var getRegistryHostTimer = new SerialTimer_1.default('getRegistryHost', initNetworkServicesTimer);
                // Ignore if not running Electron
                if (!ipc) {
                    getRegistryHostTimer.stop();
                    return cb(null, null);
                }
                if (_this.options.registryHost) {
                    registryHost = _this.options.registryHost;
                    cb(null, null);
                }
                else {
                    ipc.on('set-registry-host', function (initData) {
                        if (typeof initData === 'string' || initData instanceof String) {
                            registryHost = initData;
                        }
                        else {
                            registryHost = initData.registryHost;
                            if (initData.token) {
                                _this.session.token = initData.token;
                                console.warn('Session Token = ' + _this.session.token);
                            }
                        }
                        getRegistryHostTimer.stop();
                        cb(null, null);
                    });
                }
            },
            // Fetch the list of services from the registry
            function (cb) {
                var fetchServicesTimer = new SerialTimer_1.default('fetchServicesTimer', initNetworkServicesTimer);
                var request = new XMLHttpRequest();
                // Set to be minimum of 3 secs to avoid the 'can't find registry' issue when running remotely
                request.timeout = 3000;
                request.onreadystatechange = function () {
                    if (request.readyState === 4 && request.status === 200) {
                        services = JSON.parse(request.responseText);
                        if (services.records) {
                            services = services.records;
                            // sort them so service-manager is at the top
                            services.sort(function (a, b) {
                                if (a.name === "system-manager") {
                                    return -1;
                                }
                                if (b.name === "system-manager") {
                                    return 1;
                                }
                                return -1;
                            });
                        }
                        fetchServicesTimer.stop();
                        cb(null, null);
                    }
                    else if (request.readyState === 4 && request.status === 0) {
                        cb(new Error('Could not find registry service at ' + registryHost), null);
                    }
                };
                request.open("GET", registryHost, true);
                request.send(null);
            },
            function (cb) {
                var parallelInitializeServices = new ParallelTimer_1.default('parallelInitializedServices', initNetworkServicesTimer);
                var tasks = [];
                services.forEach(function (service) {
                    var initFunction = _this._serviceInit[service.name];
                    if (service.name === 'system-manager') {
                        initFunction = _this._serviceInit.systemManager;
                    }
                    if (initFunction) {
                        tasks.push(function (_cb) {
                            // We wrap the service init callback so that we can
                            // time each servicie initialization automatically
                            var serviceInitFunctionTimer = new SerialTimer_1.default(service.name, parallelInitializeServices);
                            initFunction(service, function (error, param) {
                                serviceInitFunctionTimer.stop();
                                _cb.apply(this, arguments);
                            });
                        });
                    }
                });
                async.parallel(tasks, function (error, results) {
                    if (error) {
                        console.error('Error: ' + error);
                        cb(error, null);
                    }
                    else {
                        parallelInitializeServices.stop();
                        cb(null, results);
                    }
                });
            }
        ], function (error, results) {
            if (error) {
                console.error('Error: ' + error);
                done(error);
            }
            else {
                // End of serviceInit timer
                initNetworkServicesTimer.stop();
                // End top most jibo timer
                GlobalPerfTimer_1.default.get().stop();
                // Comment/uncomment this line to see the timing info
                // TODO: Consider setting up a performance regression test suite
                //console.log(GlobalPerfTimer.get().getTimings());
                done(null, results);
            }
        });
        // Ignore if not running Electron
        if (ipc) {
            ipc.send('get-registry-host');
        }
    };
    Object.defineProperty(Runtime, "instance", {
        /**
         * Gets singleton instance of Jibo.
         * @name module:jibo.instance
         * @type {jibo}
         * @private
         * @readOnly
         */
        get: function () {
            return GLOBAL.jibo;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * true if Jibo is currently being initialized.
     * @name module:jibo.Runtime.isInitializing
     * @type {Boolean}
     * @readOnly
     * @default false
     */
    Runtime.isInitializing = false;
    /**
     * true if Jibo has finished being initialized.
     * @name module:jibo.Runtime.isInitialized
     * @type {Boolean}
     * @readOnly
     * @default false
     */
    Runtime.isInitialized = false;
    return Runtime;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Runtime;

//# sourceMappingURL=map/Runtime.js.map
